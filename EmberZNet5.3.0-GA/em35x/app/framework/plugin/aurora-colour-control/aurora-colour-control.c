#include <string.h>
#include "app/framework/include/af.h"
#include "app/framework/include/af-types.h"
#include "aurora-colour-control.h"
#include "aurora-colour-conversion.h"
#include "../aurora-level-control/aurora-level-control.h"
#include "../aurora-level-control/aurora-level-control-hal.h"

#include "../aurora-pwm/aurora-pwm.h"



#define COL_1               0
#define COL_2               1
#define COL_3               2

#define ROW_1               0
#define ROW_2               1
#define ROW_3               2

// CIE1931 correction table
// Automatically generated

const int8u intensityCorrection[256] = {
	0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 
	3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 
	5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 
	7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 
	10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 
	13, 14, 14, 15, 15, 15, 16, 16, 17, 17, 
	17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 
	22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 
	28, 28, 29, 29, 30, 31, 31, 32, 32, 33, 
	34, 34, 35, 36, 37, 37, 38, 39, 39, 40, 
	41, 42, 43, 43, 44, 45, 46, 47, 47, 48, 
	49, 50, 51, 52, 53, 54, 54, 55, 56, 57, 
	58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 
	68, 70, 71, 72, 73, 74, 75, 76, 77, 79, 
	80, 81, 82, 83, 85, 86, 87, 88, 90, 91, 
	92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 
	106, 108, 109, 110, 112, 113, 115, 116, 118, 120, 
	121, 123, 124, 126, 128, 129, 131, 132, 134, 136, 
	138, 139, 141, 143, 145, 146, 148, 150, 152, 154, 
	155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 
	175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 
	196, 198, 200, 202, 204, 207, 209, 211, 214, 216, 
	218, 220, 223, 225, 228, 230, 232, 235, 237, 240, 
	242, 245, 247, 250, 252, 255, 
};
#define CIE_RGB         1
#define SRGB            2

#define COLOR_SPACE    CIE_RGB
//------------------------------------------------------------------------------------------------------
// Color space conversion matrix source: http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
//------------------------------------------------------------------------------------------------------
#if (COLOR_SPACE == CIE_RGB)
const float conversionMatrix[3][3] = {
                                {2.3706743, -0.9000405, -0.4706338},
                                {-0.5138850,  1.4253036,  0.0885814},
                                {0.0052982, -0.0146949,  1.0093968},
                                };
#elif (COLOR_SPACE == SRGB)
const float conversionMatrix[3][3] = {
                                {3.2404542, -1.5371385, -0.4985314},
                                {-0.9692660,  1.8760108,  0.0415560},
                                { 0.0556434, -0.2040259,  1.0572252},
                                };
#endif




// This structure holds the definition of the gamut, the Color space that can be generated by the light
typedef struct {
    float x1;
    float y1;
    float x2;
    float y2;
    float x3;
    float y3;
} t_gamut;

typedef struct {
    int16u originalColorX;
    int16u originalColorY;
    int16u currentColorX;
    int16u currentColorY;
    int16u targetColorX;
    int16u targetColorY;    
    int16s stepSize;       
    int16u transitionTime;
} t_moveToColor;


typedef struct {
    int16u currentColorX;
    int16u currentColorY;
    int16s rateX;
    int16s rateY;
} t_moveColor;


//------------------------------------------------------------------------------------------------------
// CIE 1931 RGB Color space: http://en.wikipedia.org/wiki/RGB_color_space
//------------------------------------------------------------------------------------------------------
static t_gamut gamut = {0.7347, 0.2653, 0.2738, 0.7174, 0.1666, 0.00896}; 
static t_moveToColor moveToColor;
static t_moveColor moveColor;


EmberEventControl emberAfPluginAuroraColourControlMoveToColorEventControl;
EmberEventControl emberAfPluginAuroraColourControlMoveColorEventControl;
EmberEventControl emberAfPluginAuroraColourControlMoveStepEventControl;
EmberEventControl emberAfPluginAuroraColourControlMoveToColorTemperatureEventControl;

void emberAfPluginAuroraColourControlMoveToColorEventHandler(void);
void emberAfPluginAuroraColourControlMoveColorEventHandler(void);
void emberAfPluginAuroraColourControlMoveStepEventHandler(void);
void emberAfPluginAuroraColourControlMoveToColorTemperatureEventHandler(void);

static int16u interpolate(int16u x0, int16u y0, int16u x1, int16u y1, int16u x);
static boolean isColorInGamut(int16u x, int16u y);
static void xyYtoRGBConversion(int16u currentX, int16u currentY, t_RGB *RGB);
static EmberAfStatus getCurrentColor(int16u *currentX, int16u *currentY);
static EmberAfStatus setCurrentColor(int16u currentX, int16u currentY);
static void stopAllEvents(void);


EmberAfStatus emberAfPluginAuroraColourControlMoveToColor(int16u colorX, int16u colorY, int16u transitionTime)
{
    EmberAfStatus status;
    int16u currentX;
    int16u currentY;

    //emberAfDebugPrintln("MoveToColor(strt), tran=%d", transitionTime);    
    
    stopAllEvents(); // Stop any other events
    
    if (isColorInGamut(colorX, colorY)) 
    {    
        status = getCurrentColor(&currentX, &currentY);
        if (status == EMBER_ZCL_STATUS_SUCCESS) 
        {
            moveToColor.originalColorX = currentX;
            moveToColor.originalColorY = currentY;
            moveToColor.currentColorX = currentX;
            moveToColor.currentColorY = currentY;
            moveToColor.targetColorX = colorX;
            moveToColor.targetColorY = colorY;
            moveToColor.transitionTime = transitionTime > 0 ? transitionTime : 1;
            moveToColor.stepSize = moveToColor.transitionTime > 1 ? (((int)moveToColor.targetColorX - (int)moveToColor.originalColorX) / moveToColor.transitionTime) : 
                                                                    ((int)moveToColor.targetColorX - (int)moveToColor.originalColorX);
            //emberAfDebugPrint("MTC step size %d\r\n", moveToColor.stepSize); 
                                                                       
            emberEventControlSetActive(emberAfPluginAuroraColourControlMoveToColorEventControl); 
        }
    }
    else
    {
        status = EMBER_ZCL_STATUS_INVALID_VALUE;          
    }
        
    return status;
}

void emberAfPluginAuroraColourControlMoveToColorEventHandler(void)
{
    t_RGB RGB;
    boolean finished = FALSE;

    //emberAfDebugPrintln("MoveToColor (hdlr), tran=%d", moveToColor.transitionTime);    
    
    emberEventControlSetInactive(emberAfPluginAuroraColourControlMoveToColorEventControl);
        
    if (moveToColor.transitionTime > 0) 
    {
        // Find the new value for x and then use linear interpolation to find the corresponding y
        moveToColor.currentColorX = moveToColor.currentColorX + moveToColor.stepSize;
        moveToColor.currentColorY = interpolate(moveToColor.originalColorX, 
                                                        moveToColor.originalColorY, 
                                                        moveToColor.targetColorX, 
                                                        moveToColor.targetColorY, 
                                                        moveToColor.currentColorX);
    } 
    else 
    {
        moveToColor.currentColorX = moveToColor.targetColorX;
        moveToColor.currentColorY = moveToColor.targetColorY;
        finished = TRUE;
    }

    if (!finished) 
    {
        // Check that the color is within the gamut for the device
        if (isColorInGamut(moveToColor.currentColorX, moveToColor.currentColorY)) 
        {   
            // Convert the color to RGB and set it
            xyYtoRGBConversion(moveToColor.currentColorX, moveToColor.currentColorY, &RGB);
            emberAfPluginAuroraColourControlSetRgbColorCallback(&RGB);        
            setCurrentColor(moveToColor.currentColorX, moveToColor.currentColorY);
        } 
        else 
        {
            finished = FALSE;
        }
    }

    if (finished) 
    {
        memset(&moveToColor, 0, sizeof(t_moveToColor));
    }
    else
    {
        moveToColor.transitionTime--;
        
        // Set an event for the next step
        emberEventControlSetDelayMS(emberAfPluginAuroraColourControlMoveToColorEventControl, MILLISECOND_TICKS_PER_DECISECOND);          
    }
}

EmberAfStatus emberAfPluginAuroraColourControlMoveColor(int16s rateX, int16s rateY)
{
    EmberAfStatus status;
    int16u currentX;
    int16u currentY;
    
    emberAfDebugPrintln("MoveColor(strt)");    
    
    stopAllEvents();  // Stop any other events
    
    status = getCurrentColor(&currentX, &currentY);
    if (status == EMBER_ZCL_STATUS_SUCCESS) 
    {
        moveColor.currentColorX = currentX;
        moveColor.currentColorY = currentY;
        moveColor.rateX = rateX;
        moveColor.rateY = rateY;

        emberEventControlSetActive(emberAfPluginAuroraColourControlMoveColorEventControl); 
    }
    
    return status;
}

void emberAfPluginAuroraColourControlMoveColorEventHandler(void)
{
    t_RGB RGB;
    int32u delay;
    
    emberAfDebugPrintln("MoveColor(hdlr)");    
    
    emberEventControlSetInactive(emberAfPluginAuroraColourControlMoveColorEventControl);

    if ((moveColor.rateX == 0) && (moveColor.rateY == 0)) 
    {
        return;
    } 
    else if (((moveColor.rateX / 10) == 0) || ((moveColor.rateY / 10) == 0)) 
    {
        moveColor.currentColorX = moveColor.currentColorX + moveColor.rateX;
        moveColor.currentColorY = moveColor.currentColorY + moveColor.rateY;
        delay = MILLISECOND_TICKS_PER_SECOND;
    } 
    else 
    {
        moveColor.currentColorX = moveColor.currentColorX + moveColor.rateX / 10;
        moveColor.currentColorY = moveColor.currentColorY + moveColor.rateY / 10;
        delay = MILLISECOND_TICKS_PER_DECISECOND;
    }
    
    if (isColorInGamut(moveColor.currentColorX, moveColor.currentColorY)) 
    {    
        // Convert the Color to RGB and set it
        xyYtoRGBConversion(moveColor.currentColorX, moveColor.currentColorY, &RGB);
        emberAfPluginAuroraColourControlSetRgbColorCallback(&RGB);
        
        setCurrentColor(moveColor.currentColorX, moveColor.currentColorY);

        // Set an event for the next step
        emberEventControlSetDelayMS(emberAfPluginAuroraColourControlMoveColorEventControl, delay); 
    }
}

EmberAfStatus emberAfPluginAuroraColourControlStepColor(int16s stepX, int16s stepY, int16u transitionTime)
{
    EmberAfStatus status;
    int16u currentX;
    int16u currentY;
    int16u ColorX;
    int16u ColorY;

    emberAfDebugPrintln("StepColor(strt), tran=%d", transitionTime);
    
    stopAllEvents(); // Stop any other events
    
    status = getCurrentColor(&currentX, &currentY);
    if (status == EMBER_ZCL_STATUS_SUCCESS) 
    {        
        ColorX = currentX + stepX;
        ColorY = currentY + stepY;
        
        if (isColorInGamut(ColorX, ColorY)) 
        {
            emberAfPluginAuroraColourControlMoveToColor(ColorX, ColorY, transitionTime);
        }       
    }
    
    return status;
}

EmberAfStatus emberAfPluginAuroraColourControlMoveToColorTemperature(int16u colorTemperature, int16u transitionTime)
{
    // Command not implemented yet, just return success so that we send default response.
    return EMBER_ZCL_STATUS_SUCCESS;
}

void emberAfPluginAuroraColourControlMoveToColorTemperatureEventHandler(void)
{
}

static void stopAllEvents(void)
{
    emberEventControlSetInactive(emberAfPluginAuroraColourControlMoveToColorEventControl);
    emberEventControlSetInactive(emberAfPluginAuroraColourControlMoveColorEventControl);
    emberEventControlSetInactive(emberAfPluginAuroraColourControlMoveToColorTemperatureEventControl);
}

void emberAfPluginAuroraColourControlSetOnOff(boolean on)
{
    EmberAfStatus status;
    int16u currentX;
    int16u currentY;

    status = getCurrentColor(&currentX, &currentY);
    if (status == EMBER_ZCL_STATUS_SUCCESS) 
    {
        emberAfPluginAuroraPwmEnable(on); // Update pwm on/off state.    
        emberAfPluginAuroraColourControlMoveToColor(currentX, currentY, 0);  // Move to the current Color.
    }    
}

void emberAfPluginAuroraColourControlSetNewLevel(void)
{
    EmberAfStatus status;
    int16u currentX;
    int16u currentY;

    status = getCurrentColor(&currentX, &currentY);    
    if (status == EMBER_ZCL_STATUS_SUCCESS) 
    {
        emberAfPluginAuroraColourControlMoveToColor(currentX, currentY, 0);  // Move to the current Color.
    }
}

/** @brief Interpolate
 *
 * Find the value of y for a given x on the line between (x0, y0) and (x1, y1)
 *
 */
static int16u interpolate(int16u x0, int16u y0, int16u x1, int16u y1, int16u x)
{
    int16u y;
    
    if (x0 == x1) 
    {
        y = y0;
    } 
    else 
    {
        y = (int16u)((float)y0 + (float)(y1 - y0) * ((float)(x - x0) / (float)(x1 - x0)));
    }

    //GB emberAfDebugPrint("Interpolate (%2x, %2x) (%2x, %2x)  (%2x, %2x) \r\n", x0, y0, x1, y1, x, y);
    
    return y;
}

/** @brief Is Color in the gamut of the device
 *
 * Find out if the Color is within the gamut triangle in the Color space for the device.
 * Returns TRUE if it is, FALSE otherwise.
 *
 */
static boolean isColorInGamut(int16u x_int, int16u y_int)
{
    float x;
    float y;
    float lambda1;
    float lambda2;
    float lambda3;
    int lambda1_int;
    int lambda2_int;
    int lambda3_int;
    
    
    x = (float)x_int / 65536.0f;
    y = (float)y_int / 65536.0f;

    lambda1 = (((gamut.y2 - gamut.y3)*(x - gamut.x3)) + ((gamut.x3 - gamut.x2) * (y - gamut.y3))) / (((gamut.y2 - gamut.y3) * (gamut.x1 - gamut.x3)) + ((gamut.x3 - gamut.x2) * (gamut.y1 - gamut.y3)));
    lambda2 = (((gamut.y3 - gamut.y1)*(x - gamut.x3)) + ((gamut.x1 - gamut.x3) * (y - gamut.y3))) / (((gamut.y2 - gamut.y3) * (gamut.x1 - gamut.x3)) + ((gamut.x3 - gamut.x2) * (gamut.y1 - gamut.y3)));
    lambda3 = 1 - lambda1 - lambda2;

    lambda1_int = (int)(lambda1 * 1000);
    lambda2_int = (int)(lambda2 * 1000);
    lambda3_int = (int)(lambda3 * 1000);
    
    if (((lambda1_int >= 0) && (lambda1_int <= 1000)) &&
        ((lambda2_int >= 0) && (lambda2_int <= 1000)) &&
        ((lambda3_int >= 0) && (lambda3_int <= 1000))) 
    {
        //emberAfDebugPrint("Color Ok\r\n");
        return TRUE;
    }

#if 0    
    // Floating point version of gamut check...
    if (((lambda1 >= 0.0) && (lambda1 <= 1.0)) &&
        ((lambda2 >= 0.0) && (lambda2 <= 1.0)) &&
        ((lambda3 >= 0.0) && (lambda3 <= 1.0))) 
    {
        //emberAfDebugPrint("Color Ok\r\n");
        return TRUE;
    }
#endif
    
    emberAfDebugPrint("Color Invalid\r\n");
    
    return FALSE;
}

/** @brief Convert from xyY to RGB 
 *
 * Convert from the CIE xyY Color space to the RGB Color space so that the light 
 * can be controlled using the RGB values.
 */
static void xyYtoRGBConversion(int16u currentX, int16u currentY, t_RGB* RGB)
{
    tVec3 RGB_Color;
    tVec2 Yxy_Color;
    float Y;
    int8u currentLevel;
    
    emAfPluginLevelControlClusterGetCurrentLevel(&currentLevel);
    //emberAfDebugPrintln("xyYtoRGB- get current level= 0x%X", currentLevel);
        
    Yxy_Color.x = (float)currentX / 65536.0f; // the given x value
    Yxy_Color.y = (float)currentY / 65536.0f; // the given y value
    Y = ((float)currentLevel / 0xFF);

    //emberAfDebugPrintln("xyYtoRGB (%d, %d)", (int)(Yxy_Color.x * 1000), (int)(Yxy_Color.y * 1000));  
    
    emberAfPluginAuroraColourControlConvertColor(&Yxy_Color, Y, &RGB_Color);
        
    int8u R,G,B,W;
    R = (int)(RGB_Color.x * 255);
    G = (int)(RGB_Color.y * 255);
    B = (int)(RGB_Color.z * 255);
    
    int8u mode = getAuroraDimmerMode();
    if (mode == AURORA_MODE_RGBW)
    {
        // White value is equal to the MINIMUM of the RGB values.    
        W = R < G ? (R < B ? R : B) : (G < B ? G : B);
        
        // Now subtract the found White level from each of the RGB values.
        R -= W;
        G -= W;
        B -= W;
    }
    else
    {
        // Just set the White level to the current Level.
        W = currentLevel;      
        
        if (mode == AURORA_MODE_DIM)
        {
            // Single light mode so set R,G,B levels = 0 (we are only interested in the W level) 
            R = 0;
            G = 0;
            B = 0;        
        }
    }
        
    // Set return values.
    RGB->R = R;
    RGB->G = G;
    RGB->B = B;
    RGB->W = W;             
    
    emberAfDebugPrintln("xyYtoRGB R=%d, G=%d, B=%d, W=%d", RGB->R, RGB->G, RGB->B, RGB->W);  
}

/** @brief Get the current Color on the light
 *
 * Reads the local attributes in the Color control cluster and 
 * returns them in the variables passed in.
 * 
 */
static EmberAfStatus getCurrentColor(int16u *currentX, int16u *currentY)
{
    EmberAfStatus status;
    int8u endpoint = 1;
    EmberAfClusterId cluster = ZCL_COLOR_CONTROL_CLUSTER_ID;
    int8u mask = CLUSTER_MASK_SERVER;
    int16u dataPtr;
    int8u readLength = sizeof(int16u);
    int8u dataType;
    
    status = emberAfReadAttribute(endpoint, cluster, ZCL_COLOR_CONTROL_CURRENT_X_ATTRIBUTE_ID, mask, (int8u*)&dataPtr, readLength, &dataType);
    if (status != EMBER_ZCL_STATUS_SUCCESS) 
    {
        emberAfLevelControlClusterPrintln("ERR: reading currentX", status);
        return status;
    }
    *currentX = dataPtr;

    status = emberAfReadAttribute(endpoint, cluster, ZCL_COLOR_CONTROL_CURRENT_Y_ATTRIBUTE_ID, mask, (int8u*)&dataPtr, readLength, &dataType);
    if (status != EMBER_ZCL_STATUS_SUCCESS) 
    {
        emberAfLevelControlClusterPrintln("ERR: reading currentY", status);
        return status;        
    }    
    *currentY = dataPtr;
    
    return status;
}

/** @brief Set the current Color attributes
 *
 * Writes the local attributes in the Color control cluster.
 * 
 */
static EmberAfStatus setCurrentColor(int16u currentX, int16u currentY)
{
    EmberAfStatus status;
    int8u endpoint = 1;
    EmberAfClusterId cluster = ZCL_COLOR_CONTROL_CLUSTER_ID;

    status = emberAfWriteServerAttribute(endpoint, cluster, ZCL_COLOR_CONTROL_CURRENT_X_ATTRIBUTE_ID, (int8u*)&currentX, sizeof(int16u));
    if (status != EMBER_ZCL_STATUS_SUCCESS) 
    {
        emberAfLevelControlClusterPrintln("ERR: writing currentX %x", status);
        return status;
    }
    
    status = emberAfWriteServerAttribute(endpoint, cluster, ZCL_COLOR_CONTROL_CURRENT_Y_ATTRIBUTE_ID, (int8u*)&currentY, sizeof(int16u));
    if (status != EMBER_ZCL_STATUS_SUCCESS) 
    {
        emberAfLevelControlClusterPrintln("ERR: writing currentY %x", status);
        return status;
    }
    
    emberAfDebugPrint("Set current Color: X=0x%2x,Y=0x%2x\r\n", currentX, currentX);      
    
    return status;
}

