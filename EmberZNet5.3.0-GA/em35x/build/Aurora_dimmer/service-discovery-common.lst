###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:34:31
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\util\service-discovery-common.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\util\service-discovery-common.c"
#        -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"service-discovery-common.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\util\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\service-discovery-common.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\service-discovery-common.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\util\service-discovery-common.c
      1          // *****************************************************************************
      2          // * service-discovery-common.c
      3          // *
      4          // * Service discovery code that is common to different types of service
      5          // * discovery, e.g. match descriptor, NWK address lookup, and IEEE address
      6          // * lookup.
      7          // *
      8          // * Copyright 2010 by Ember Corporation. All rights reserved.              *80*
      9          // *****************************************************************************
     10          
     11          #include "app/framework/include/af.h"
     12          #include "app/util/zigbee-framework/zigbee-device-common.h"
     13          #ifdef EZSP_HOST
     14            #include "app/util/zigbee-framework/zigbee-device-host.h"
     15          #endif
     16          #include "service-discovery.h"
     17          
     18          #if EMBER_SUPPORTED_NETWORKS > 4
     19            #error "Service discovery is limited to four networks."
     20          #endif
     21          
     22          //==============================================================================
     23          // Service discovery state machine
     24          //
     25          //   This code handles initiating a limited set of ZDO, receiving
     26          //   the response and sending it back to the cluster or code element that
     27          //   requested it.  Unfortunately the ZDO message does not have any distinct
     28          //   identifiers that would allow us to determine what cluster/endpoint on our
     29          //   local device initiated the request.  Therefore we can only allow one
     30          //    outstanding request at a time.
     31          

   \                                 In section .bss, align 4
     32          EmberEventControl emAfServiceDiscoveryEventControls[EMBER_SUPPORTED_NETWORKS];
   \                     emAfServiceDiscoveryEventControls:
   \   00000000                      DS8 8
   \   00000008                      DS8 12
     33          
     34          typedef struct {
     35            boolean active;
     36            EmberAfServiceDiscoveryCallback *callback;
     37            // This will contain the target type: broadcast or unicast (high bit)
     38            // and the ZDO cluster ID of the request.  Since ZDO requests
     39            // clear the high bit (only repsonses use it), we can use that leftover bit
     40            // for something else.
     41            int16u requestData;
     42          } State;
     43          static State states[EMBER_SUPPORTED_NETWORKS];
     44          
     45          #define UNICAST_QUERY_BIT (0x8000)
     46          #define isUnicastQuery(state) (UNICAST_QUERY_BIT == (state->requestData & UNICAST_QUERY_BIT))
     47          #define setUnicastQuery(state) (state->requestData |= UNICAST_QUERY_BIT)
     48          #define getRequestCluster(state) (state->requestData & ~UNICAST_QUERY_BIT)
     49          #define serviceDiscoveryInProgress(state) (state->active)
     50          
     51          #ifndef EMBER_AF_DISCOVERY_TIMEOUT_QS
     52            #define EMBER_AF_DISCOVERY_TIMEOUT_QS (2 * 4)
     53          #endif
     54          
     55          // seq. number (1), status (1), address (2), length (1)
     56          #define MATCH_DESCRIPTOR_OVERHEAD               5
     57          #define MINIMUM_MATCH_DESCRIPTOR_SUCCESS_LENGTH MATCH_DESCRIPTOR_OVERHEAD
     58          
     59          // seq. number (1), status (1)
     60          #define ZDO_OVERHEAD 2
     61          // EUI64 (8), node ID (2),
     62          #define MINIMUM_ADDRESS_REQEUST_SUCCESS (ZDO_OVERHEAD + 10)
     63          #define ADDRESS_RESPONSE_NODE_ID_OFFSET (ZDO_OVERHEAD + EUI64_SIZE)
     64          
     65          #define PREFIX "Svc Disc: "
     66          
     67          //==============================================================================
     68          // Forward Declarations
     69          
     70          static void setupDiscoveryData(State *state,
     71                                         EmberNodeId messageDest,
     72                                         EmberAfServiceDiscoveryCallback *callback,
     73                                         int16u zdoClusterId);
     74          
     75          //==============================================================================
     76          

   \                                 In section .text, align 2, keep-with-next
     77          EmberStatus emberAfFindDevicesByProfileAndCluster(EmberNodeId target,
     78                                                            EmberAfProfileId profileId,
     79                                                            EmberAfClusterId clusterId,
     80                                                            boolean serverCluster,
     81                                                            EmberAfServiceDiscoveryCallback *callback)
     82          {
   \                     emberAfFindDevicesByProfileAndCluster: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
     83            State *state = &states[emberGetCurrentNetwork()];
   \   0000000C   0x.... 0x....      BL       emberGetCurrentNetwork
   \   00000010   0x.... 0x....      BL       ?Subroutine0
     84            EmberStatus status;
     85          
     86            if (serviceDiscoveryInProgress(state)) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000014   0xB108             CBZ.N    R0,??emberAfFindDevicesByProfileAndCluster_0
     87              emberAfServiceDiscoveryPrintln("%pDiscovery already in progress", PREFIX);
     88              return EMBER_INVALID_CALL;
   \   00000016   0x2070             MOVS     R0,#+112
   \   00000018   0xE016             B.N      ??emberAfFindDevicesByProfileAndCluster_1
     89            }
     90          
     91            if (EMBER_BROADCAST_ADDRESS <= target
     92                && target != EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS) {
   \                     ??emberAfFindDevicesByProfileAndCluster_0: (+1)
   \   0000001A   0xF64F 0x71FC      MOVW     R1,#+65532
   \   0000001E   0x428C             CMP      R4,R1
   \   00000020   0xDB04             BLT.N    ??emberAfFindDevicesByProfileAndCluster_2
   \   00000022   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000026   0x428C             CMP      R4,R1
   \   00000028   0xBF18             IT       NE 
   \   0000002A   0x460C             MOVNE    R4,R1
     93              // Note:  The core spec. only allows a Match Descriptor broadcast to
     94              // the 'rx on when idle' address.  No other broadcast addresses are allowed.
     95              // The Ember stack will silently discard broadcast match descriptors
     96              // to invalid broadcast addresses.
     97              emberAfServiceDiscoveryPrintln("%pIllegal broadcast address, remapping to valid one.",
     98                                             PREFIX);
     99              target = EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS;
    100            }
    101          
    102            status = emAfSendMatchDescriptor(target, profileId, clusterId, serverCluster);
   \                     ??emberAfFindDevicesByProfileAndCluster_2: (+1)
   \   0000002C   0x4643             MOV      R3,R8
   \   0000002E   0x4632             MOV      R2,R6
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       emAfSendMatchDescriptor
    103            if (status != EMBER_SUCCESS) {
   \   00000038   0xB930             CBNZ.N   R0,??emberAfFindDevicesByProfileAndCluster_1
    104              emberAfServiceDiscoveryPrintln("%pFailed to send match discovery: 0x%x",
    105                                             PREFIX,
    106                                             status);
    107              return status;
    108            }
    109          
    110            emberAfServiceDiscoveryPrintln("%pStarting discovery for cluster 0x%2x",
    111                                           PREFIX,
    112                                           clusterId);
    113          
    114            setupDiscoveryData(state, target, callback, MATCH_DESCRIPTORS_REQUEST);
   \   0000003A   0x9A06             LDR      R2,[SP, #+24]
   \   0000003C   0x2306             MOVS     R3,#+6
   \   0000003E   0x4621             MOV      R1,R4
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0x.... 0x....      BL       setupDiscoveryData
    115          
    116            return EMBER_SUCCESS;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindDevicesByProfileAndCluster_1: (+1)
   \   00000048   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    117          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x210C             MOVS     R1,#+12
   \   00000002   0x....             LDR.N    R2,??DataTable4
   \   00000004   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000008   0xF100 0x0708      ADD      R7,R0,#+8
   \   0000000C   0x7838             LDRB     R0,[R7, #+0]
   \   0000000E   0x4770             BX       LR
    118          

   \                                 In section .text, align 2, keep-with-next
    119          EmberStatus emberAfFindClustersByDeviceAndEndpoint(EmberNodeId target,
    120                                                             int8u targetEndpoint,
    121                                                             EmberAfServiceDiscoveryCallback *callback) {
   \                     emberAfFindClustersByDeviceAndEndpoint: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    122            
    123            State *state = &states[emberGetCurrentNetwork()];
   \   00000008   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000C   0x.... 0x....      BL       ?Subroutine0
    124            EmberStatus status;
    125            
    126            if (serviceDiscoveryInProgress(state)) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000010   0xB108             CBZ.N    R0,??emberAfFindClustersByDeviceAndEndpoint_0
    127              return EMBER_INVALID_CALL;
   \   00000012   0x2070             MOVS     R0,#+112
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    128            }
    129          
    130            status = emberSimpleDescriptorRequest(target,
    131                                                  targetEndpoint,
    132                                                  EMBER_AF_DEFAULT_APS_OPTIONS);
   \                     ??emberAfFindClustersByDeviceAndEndpoint_0: (+1)
   \   00000016   0xF44F 0x5282      MOV      R2,#+4160
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSimpleDescriptorRequest
    133            
    134            if (status != EMBER_SUCCESS) {
   \   00000022   0xB930             CBNZ.N   R0,??emberAfFindClustersByDeviceAndEndpoint_1
    135              emberAfServiceDiscoveryPrintln("%pFailed to send simple descriptor request: 0x%x",
    136                                             PREFIX,
    137                                             status);
    138              return status;
    139            }
    140            
    141            setupDiscoveryData(state, target, callback, SIMPLE_DESCRIPTOR_REQUEST);
   \   00000024   0x2304             MOVS     R3,#+4
   \   00000026   0x4632             MOV      R2,R6
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x4638             MOV      R0,R7
   \   0000002C   0x.... 0x....      BL       setupDiscoveryData
    142            
    143            return status;
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindClustersByDeviceAndEndpoint_1: (+1)
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    144          }
    145          

   \                                 In section .text, align 2, keep-with-next
    146          EmberStatus emberAfFindIeeeAddress(EmberNodeId shortAddress,
    147                                             EmberAfServiceDiscoveryCallback *callback)
    148          {
   \                     emberAfFindIeeeAddress: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    149            State *state = &states[emberGetCurrentNetwork()];
   \   00000006   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000A   0x.... 0x....      BL       ?Subroutine1
    150            EmberStatus status;
    151          
    152            if (serviceDiscoveryInProgress(state)) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000E   0xB108             CBZ.N    R0,??emberAfFindIeeeAddress_0
    153              return EMBER_INVALID_CALL;
   \   00000010   0x2070             MOVS     R0,#+112
   \   00000012   0xBD70             POP      {R4-R6,PC}
    154            }
    155          
    156            status = emberIeeeAddressRequest(shortAddress,
    157                                             FALSE,         // report kids?
    158                                             0,             // child start index
    159                                             EMBER_APS_OPTION_RETRY);
   \                     ??emberAfFindIeeeAddress_0: (+1)
   \   00000014   0x2340             MOVS     R3,#+64
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       emberIeeeAddressRequest
    160          
    161            if (status != EMBER_SUCCESS) {
   \   00000020   0xB930             CBNZ.N   R0,??emberAfFindIeeeAddress_1
    162              emberAfServiceDiscoveryPrintln("%pFailed to send IEEE address request: 0x%x",
    163                                             PREFIX,
    164                                             status);
    165              return status;
    166            }
    167          
    168            setupDiscoveryData(state, shortAddress, callback, IEEE_ADDRESS_REQUEST);
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x462A             MOV      R2,R5
   \   00000026   0x4621             MOV      R1,R4
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       setupDiscoveryData
    169          
    170            return status;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindIeeeAddress_1: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    171          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x210C             MOVS     R1,#+12
   \   00000002   0x....             LDR.N    R2,??DataTable4
   \   00000004   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000008   0xF100 0x0608      ADD      R6,R0,#+8
   \   0000000C   0x7830             LDRB     R0,[R6, #+0]
   \   0000000E   0x4770             BX       LR
    172          

   \                                 In section .text, align 2, keep-with-next
    173          EmberStatus emberAfFindNodeId(EmberEUI64 longAddress,
    174                                        EmberAfServiceDiscoveryCallback *callback)
    175          {
   \                     emberAfFindNodeId: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    176            State *state = &states[emberGetCurrentNetwork()];
   \   00000006   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000A   0x.... 0x....      BL       ?Subroutine1
    177            EmberStatus status;
    178          
    179            if (serviceDiscoveryInProgress(state)) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000000E   0xB108             CBZ.N    R0,??emberAfFindNodeId_0
    180              return EMBER_INVALID_CALL;
   \   00000010   0x2070             MOVS     R0,#+112
   \   00000012   0xBD70             POP      {R4-R6,PC}
    181            }
    182          
    183            status = emberNetworkAddressRequest(longAddress,
    184                                                FALSE,         // report kids?
    185                                                0);            // child start index
   \                     ??emberAfFindNodeId_0: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       emberNetworkAddressRequest
    186          
    187            if (status != EMBER_SUCCESS) {
   \   0000001E   0xB938             CBNZ.N   R0,??emberAfFindNodeId_1
    188              emberAfServiceDiscoveryPrintln("%pFailed to send NWK address request: 0x%x",
    189                                             PREFIX,
    190                                             status);
    191              return status;
    192            }
    193          
    194            setupDiscoveryData(state,
    195                               EMBER_BROADCAST_ADDRESS,
    196                               callback,
    197                               NETWORK_ADDRESS_REQUEST);
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x462A             MOV      R2,R5
   \   00000024   0xF64F 0x71FC      MOVW     R1,#+65532
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       setupDiscoveryData
    198          
    199            return status;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindNodeId_1: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    200          }
    201          

   \                                 In section .text, align 2, keep-with-next
    202          static void setupDiscoveryData(State *state,
    203                                         EmberNodeId messageDest,
    204                                         EmberAfServiceDiscoveryCallback *callback,
    205                                         int16u zdoClusterRequest)
    206          {
   \                     setupDiscoveryData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    207            state->active = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
   \   00000004   0x7004             STRB     R4,[R0, #+0]
    208            state->requestData = zdoClusterRequest;
    209            if (messageDest < EMBER_BROADCAST_ADDRESS) {
    210              setUnicastQuery(state);
    211            }
    212            state->callback = callback;
   \   00000006   0x6042             STR      R2,[R0, #+4]
   \   00000008   0xF64F 0x74FC      MOVW     R4,#+65532
   \   0000000C   0x42A1             CMP      R1,R4
   \   0000000E   0xBFB8             IT       LT 
   \   00000010   0xF443 0x4300      ORRLT    R3,R3,#0x8000
   \   00000014   0x8103             STRH     R3,[R0, #+8]
    213            emberAfServiceDiscoveryPrintln("%pWaiting %d sec for discovery to complete",
    214                                           PREFIX,
    215                                           EMBER_AF_DISCOVERY_TIMEOUT_QS >> 2);
    216            emberAfNetworkEventControlSetDelayQS(emAfServiceDiscoveryEventControls,
    217                                                 EMBER_AF_DISCOVERY_TIMEOUT_QS);
   \   00000016   0x2108             MOVS     R1,#+8
   \   00000018   0x....             LDR.N    R0,??DataTable4
   \   0000001A   0x.... 0x....      BL       emberAfNetworkEventControlSetDelayQS
    218          
    219            // keep sleepy end devices out of hibernation until
    220            // service discovery is complete
    221            emberAfAddToCurrentAppTasks(EMBER_AF_WAITING_FOR_SERVICE_DISCOVERY);
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      B.W      emberAfAddToCurrentAppTasksCallback
    222          }
    223          

   \                                 In section .text, align 2, keep-with-next
    224          static void serviceDiscoveryComplete(int8u networkIndex)
    225          {
   \                     serviceDiscoveryComplete: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    226            State *state = &states[networkIndex];
   \   00000002   0x....             LDR.N    R4,??DataTable4
   \   00000004   0x210C             MOVS     R1,#+12
   \   00000006   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   0000000A   0xF101 0x0508      ADD      R5,R1,#+8
    227          
    228            emberAfPushNetworkIndex(networkIndex);
   \   0000000E   0x.... 0x....      BL       emberAfPushNetworkIndex
    229          
    230            state->active = FALSE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    231            emberAfServiceDiscoveryPrintln("%pcomplete.", PREFIX);
    232            emberAfNetworkEventControlSetInactive(emAfServiceDiscoveryEventControls);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       emberAfNetworkEventControlSetInactive
    233          
    234            // allow sleepy end devices to go into hibernation now.
    235            emberAfRemoveFromCurrentAppTasks(EMBER_AF_WAITING_FOR_SERVICE_DISCOVERY);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       emberAfRemoveFromCurrentAppTasksCallback
    236          
    237            if (state->callback != NULL) {
   \   00000022   0x6869             LDR      R1,[R5, #+4]
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xD010             BEQ.N    ??serviceDiscoveryComplete_0
    238              EmberAfServiceDiscoveryResult result;
    239              result.status = (isUnicastQuery(state)
    240                               ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_TIMEOUT
    241                               : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE);
   \   00000028   0x8928             LDRH     R0,[R5, #+8]
   \   0000002A   0x0402             LSLS     R2,R0,#+16
   \   0000002C   0xBF4C             ITE      MI 
   \   0000002E   0x2202             MOVMI    R2,#+2
   \   00000030   0x2200             MOVPL    R2,#+0
    242              result.zdoRequestClusterId = getRequestCluster(state);
   \   00000032   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000036   0xF88D 0x2000      STRB     R2,[SP, #+0]
    243              result.matchAddress = EMBER_NULL_NODE_ID;
   \   0000003A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000003E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    244              result.responseData = NULL;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9002             STR      R0,[SP, #+8]
    245              (*state->callback)(&result);
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x4788             BLX      R1
    246            }
    247          
    248            emberAfPopNetworkIndex();
   \                     ??serviceDiscoveryComplete_0: (+1)
   \   0000004A   0x.... 0x....      BL       emberAfPopNetworkIndex
    249          }
   \   0000004E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xA900             ADD      R1,SP,#+0
   \   00000002   0x8920             LDRH     R0,[R4, #+8]
   \                     ??Subroutine2_0: (+1)
   \   00000004   0x0440             LSLS     R0,R0,#+17
   \   00000006   0x0C40             LSRS     R0,R0,#+17
   \   00000008   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   0000000C   0x4770             BX       LR
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void emAfServiceDiscoveryComplete0(void)
    252          {
    253            serviceDiscoveryComplete(0);
   \                     emAfServiceDiscoveryComplete0: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    254          }
    255          

   \                                 In section .text, align 2, keep-with-next
    256          void emAfServiceDiscoveryComplete1(void)
    257          {
    258            serviceDiscoveryComplete(1);
   \                     emAfServiceDiscoveryComplete1: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    259          }
    260          

   \                                 In section .text, align 2, keep-with-next
    261          void emAfServiceDiscoveryComplete2(void)
    262          {
    263            serviceDiscoveryComplete(2);
   \                     emAfServiceDiscoveryComplete2: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    264          }
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void emAfServiceDiscoveryComplete3(void)
    267          {
    268            serviceDiscoveryComplete(3);
   \                     emAfServiceDiscoveryComplete3: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    269          }
    270          

   \                                 In section .text, align 2, keep-with-next
    271          static void executeCallback(State *state,
    272                                      const EmberAfServiceDiscoveryResult *result)
    273          {
   \                     executeCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    274            (*state->callback)(result);
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x4788             BLX      R1
    275            if (isUnicastQuery(state)) {
   \   0000000A   0x8920             LDRH     R0,[R4, #+8]
   \   0000000C   0x0400             LSLS     R0,R0,#+16
   \   0000000E   0xD506             BPL.N    ??executeCallback_0
    276              // If the request was unicast and we received a response then we are done.
    277              // No need to wait for the timer to expire.
    278          
    279              // We NULL the callback as a way of indicating we already fired it.
    280              // For timeouts, the callback will not be NULL and still fire.
    281              state->callback = NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6060             STR      R0,[R4, #+4]
    282              serviceDiscoveryComplete(emberGetCurrentNetwork());
   \   00000014   0x.... 0x....      BL       emberGetCurrentNetwork
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x....             B.N      serviceDiscoveryComplete
    283            }
    284          }
   \                     ??executeCallback_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    285          
    286          static boolean processMatchDescriptorResponse(State *state,
    287                                                        const int8u *message,
    288                                                        int16u length)
    289          {
    290            EmberNodeId matchId;
    291            int8u listLength;
    292          
    293            if (length < MINIMUM_MATCH_DESCRIPTOR_SUCCESS_LENGTH) {
    294              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    295              return TRUE;
    296            }
    297          
    298            // This will now be used as the length of the match list.
    299            length -= MATCH_DESCRIPTOR_OVERHEAD;
    300          
    301            // If the parent of a sleepy device supports caching its descriptor
    302            // information then the sender of the response may not be the device
    303            // that actually matches the request.  The device id that matches
    304            // is included in the message.
    305            matchId = message[2] + (message[3] << 8);
    306            listLength = message[4];
    307          
    308            if (listLength != length) {
    309              emberAfServiceDiscoveryPrintln("%pMessage too short for num. endpoints",
    310                                             PREFIX);
    311              return TRUE;
    312            }
    313          
    314            emberAfServiceDiscoveryPrintln("%pMatch%p found from 0x%2x.",
    315                                           PREFIX,
    316                                           (listLength > 0
    317                                            ? ""
    318                                            : " NOT"),
    319                                           matchId);
    320          
    321            // If we got an active response with an empty list then ignore it.
    322            if (listLength != 0) {
    323              EmberAfServiceDiscoveryResult result;
    324              EmberAfEndpointList endpointList;
    325              endpointList.count = length;
    326              endpointList.list = &(message[MATCH_DESCRIPTOR_OVERHEAD]);
    327              result.status = (isUnicastQuery(state)
    328                               ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    329                               : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    330              result.zdoRequestClusterId = getRequestCluster(state);
    331              result.matchAddress = matchId;
    332              result.responseData = &endpointList;
    333              executeCallback(state, &result);
    334            }
    335            return TRUE;
    336          }
    337          
    338          static boolean processSimpleDescriptorResponse(State *state,
    339                                                         const int8u *message,
    340                                                         int16u length) {
    341           EmberAfServiceDiscoveryResult result;
    342           EmberAfClusterList clusterList;
    343           EmberNodeId matchId = message[2] + (message[3] << 8);
    344           int8u inClusterCount = message[11];
    345           int8u outClusterCount = message[12+(inClusterCount*2)];
    346           
    347           clusterList.inClusterCount = inClusterCount;
    348           clusterList.outClusterCount = outClusterCount;
    349           clusterList.inClusterList = (int16u*)&message[12];
    350           clusterList.outClusterList = (int16u*)&message[13+(inClusterCount*2)];
    351           
    352           result.status = (isUnicastQuery(state)
    353                            ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    354                            : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    355           result.matchAddress = matchId;
    356           result.zdoRequestClusterId = getRequestCluster(state);
    357           result.responseData = &clusterList;
    358          
    359           executeCallback(state, &result);
    360           return TRUE;
    361          }
    362          
    363          // Both NWK and IEEE responses have the same exact format.
    364          static boolean processAddressResponse(State *state,
    365                                                const int8u *message,
    366                                                int16u length)
    367          {
    368            EmberAfServiceDiscoveryResult result;
    369            EmberEUI64 eui64LittleEndian;
    370          
    371            if (length < MINIMUM_ADDRESS_REQEUST_SUCCESS) {
    372              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    373              return TRUE;
    374            }
    375            MEMCOPY(eui64LittleEndian, message + ZDO_OVERHEAD, EUI64_SIZE);
    376            result.status = (isUnicastQuery(state)
    377                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    378                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    379            result.matchAddress = (message[ADDRESS_RESPONSE_NODE_ID_OFFSET]
    380                                   + (message[ADDRESS_RESPONSE_NODE_ID_OFFSET+1] << 8));
    381            result.zdoRequestClusterId = getRequestCluster(state);
    382            result.responseData = eui64LittleEndian;
    383          
    384            executeCallback(state, &result);
    385            return TRUE;
    386          }
    387          

   \                                 In section .text, align 2, keep-with-next
    388          boolean emAfServiceDiscoveryIncoming(EmberNodeId sender,
    389                                               EmberApsFrame *apsFrame,
    390                                               const int8u *message,
    391                                               int16u length)
    392          {
   \                     emAfServiceDiscoveryIncoming: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461F             MOV      R7,R3
    393            State *state = &states[emberGetCurrentNetwork()];
   \   0000000E   0x.... 0x....      BL       emberGetCurrentNetwork
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0x....             LDR.N    R2,??DataTable4
   \   00000016   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000001A   0xF100 0x0408      ADD      R4,R0,#+8
    394            if (!(serviceDiscoveryInProgress(state)
    395                  && (apsFrame->profileId == EMBER_ZDO_PROFILE_ID
    396                      // ZDO Responses set the high bit on the request cluster ID
    397                      && (apsFrame->clusterId == (CLUSTER_ID_RESPONSE_MINIMUM
    398                                                  | getRequestCluster(state)))))) {
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD077             BEQ.N    ??emAfServiceDiscoveryIncoming_0
   \   00000024   0x8830             LDRH     R0,[R6, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xBF01             ITTTT    EQ 
   \   0000002A   0x8870             LDRHEQ   R0,[R6, #+2]
   \   0000002C   0x8921             LDRHEQ   R1,[R4, #+8]
   \   0000002E   0xF441 0x4100      ORREQ    R1,R1,#0x8000
   \   00000032   0x4288             CMPEQ    R0,R1
   \   00000034   0xD16E             BNE.N    ??emAfServiceDiscoveryIncoming_0
    399              return FALSE;
    400            }
    401          
    402            // If we hear our own request and respond we ignore it.
    403            if (sender == emberAfGetNodeId()) {
   \   00000036   0x.... 0x....      BL       emberAfGetNodeId
   \   0000003A   0x4580             CMP      R8,R0
   \   0000003C   0xD068             BEQ.N    ??emAfServiceDiscoveryIncoming_1
    404              return TRUE;
    405            }
    406          
    407            // The second byte is the status code
    408            if (message[1] != EMBER_ZDP_SUCCESS) {
   \   0000003E   0x7868             LDRB     R0,[R5, #+1]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD165             BNE.N    ??emAfServiceDiscoveryIncoming_1
    409              return TRUE;
    410            }
    411          
    412            switch (apsFrame->clusterId) {
   \   00000044   0x8871             LDRH     R1,[R6, #+2]
   \   00000046   0xF44F 0x4200      MOV      R2,#+32768
   \   0000004A   0x1A89             SUBS     R1,R1,R2
   \   0000004C   0x2901             CMP      R1,#+1
   \   0000004E   0xD944             BLS.N    ??emAfServiceDiscoveryIncoming_2
   \   00000050   0x1F09             SUBS     R1,R1,#+4
   \   00000052   0xD002             BEQ.N    ??emAfServiceDiscoveryIncoming_3
   \   00000054   0x1E89             SUBS     R1,R1,#+2
   \   00000056   0xD01F             BEQ.N    ??emAfServiceDiscoveryIncoming_4
   \   00000058   0xE05C             B.N      ??emAfServiceDiscoveryIncoming_0
    413            case SIMPLE_DESCRIPTOR_RESPONSE:
    414              return processSimpleDescriptorResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_3: (+1)
   \   0000005A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005C   0x78E9             LDRB     R1,[R5, #+3]
   \   0000005E   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   00000062   0x7AE9             LDRB     R1,[R5, #+11]
   \   00000064   0xEB05 0x0241      ADD      R2,R5,R1, LSL #+1
   \   00000068   0x7B13             LDRB     R3,[R2, #+12]
   \   0000006A   0xF88D 0x1014      STRB     R1,[SP, #+20]
   \   0000006E   0xF88D 0x301C      STRB     R3,[SP, #+28]
   \   00000072   0xF105 0x010C      ADD      R1,R5,#+12
   \   00000076   0x9106             STR      R1,[SP, #+24]
   \   00000078   0xF102 0x010D      ADD      R1,R2,#+13
   \   0000007C   0x9108             STR      R1,[SP, #+32]
   \   0000007E   0x8921             LDRH     R1,[R4, #+8]
   \   00000080   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000084   0x0409             LSLS     R1,R1,#+16
   \   00000086   0xBF4C             ITE      MI 
   \   00000088   0x2103             MOVMI    R1,#+3
   \   0000008A   0x2101             MOVPL    R1,#+1
   \   0000008C   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   00000090   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000094   0xA805             ADD      R0,SP,#+20
   \   00000096   0xE037             B.N      ??emAfServiceDiscoveryIncoming_5
    415            case MATCH_DESCRIPTORS_RESPONSE:
    416              return processMatchDescriptorResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_4: (+1)
   \   00000098   0x2F05             CMP      R7,#+5
   \   0000009A   0xDB39             BLT.N    ??emAfServiceDiscoveryIncoming_1
   \   0000009C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000009E   0x78EA             LDRB     R2,[R5, #+3]
   \   000000A0   0xEB00 0x2002      ADD      R0,R0,R2, LSL #+8
   \   000000A4   0x1F79             SUBS     R1,R7,#+5
   \   000000A6   0x792A             LDRB     R2,[R5, #+4]
   \   000000A8   0xB289             UXTH     R1,R1
   \   000000AA   0x428A             CMP      R2,R1
   \   000000AC   0xD130             BNE.N    ??emAfServiceDiscoveryIncoming_1
   \   000000AE   0xB37A             CBZ.N    R2,??emAfServiceDiscoveryIncoming_1
   \   000000B0   0xF88D 0x100C      STRB     R1,[SP, #+12]
   \   000000B4   0x1D69             ADDS     R1,R5,#+5
   \   000000B6   0x9104             STR      R1,[SP, #+16]
   \   000000B8   0x8921             LDRH     R1,[R4, #+8]
   \   000000BA   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   000000BE   0x040A             LSLS     R2,R1,#+16
   \   000000C0   0xA803             ADD      R0,SP,#+12
   \   000000C2   0xBF4C             ITE      MI 
   \   000000C4   0x2203             MOVMI    R2,#+3
   \   000000C6   0x2201             MOVPL    R2,#+1
   \   000000C8   0x0449             LSLS     R1,R1,#+17
   \   000000CA   0x0C49             LSRS     R1,R1,#+17
   \   000000CC   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   \   000000D0   0x9002             STR      R0,[SP, #+8]
   \   000000D2   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   000000D6   0xA900             ADD      R1,SP,#+0
   \   000000D8   0xE017             B.N      ??emAfServiceDiscoveryIncoming_6
    417          
    418            case NETWORK_ADDRESS_RESPONSE:
    419            case IEEE_ADDRESS_RESPONSE:
    420              return processAddressResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_2: (+1)
   \   000000DA   0x2F0C             CMP      R7,#+12
   \   000000DC   0xDB18             BLT.N    ??emAfServiceDiscoveryIncoming_1
   \   000000DE   0x2208             MOVS     R2,#+8
   \   000000E0   0x1CA9             ADDS     R1,R5,#+2
   \   000000E2   0xA803             ADD      R0,SP,#+12
   \   000000E4   0x.... 0x....      BL       halCommonMemCopy
   \   000000E8   0x8920             LDRH     R0,[R4, #+8]
   \   000000EA   0x0400             LSLS     R0,R0,#+16
   \   000000EC   0xBF4C             ITE      MI 
   \   000000EE   0x2003             MOVMI    R0,#+3
   \   000000F0   0x2001             MOVPL    R0,#+1
   \   000000F2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000F6   0x7AE9             LDRB     R1,[R5, #+11]
   \   000000F8   0x7AA8             LDRB     R0,[R5, #+10]
   \   000000FA   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   000000FE   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000102   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000106   0xA803             ADD      R0,SP,#+12
   \                     ??emAfServiceDiscoveryIncoming_5: (+1)
   \   00000108   0x9002             STR      R0,[SP, #+8]
   \                     ??emAfServiceDiscoveryIncoming_6: (+1)
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       executeCallback
   \                     ??emAfServiceDiscoveryIncoming_1: (+1)
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xE000             B.N      ??emAfServiceDiscoveryIncoming_7
    421          
    422            default:
    423              // Some ZDO request we don't care about.
    424              break;
    425            }
    426          
    427            return FALSE;
   \                     ??emAfServiceDiscoveryIncoming_0: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??emAfServiceDiscoveryIncoming_7: (+1)
   \   00000116   0xB00A             ADD      SP,SP,#+40
   \   00000118   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    428          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     emAfServiceDiscoveryEventControls

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emAfServiceDiscoveryComplete0
         0   -> serviceDiscoveryComplete
       0   emAfServiceDiscoveryComplete1
         0   -> serviceDiscoveryComplete
       0   emAfServiceDiscoveryComplete2
         0   -> serviceDiscoveryComplete
       0   emAfServiceDiscoveryComplete3
         0   -> serviceDiscoveryComplete
      64   emAfServiceDiscoveryIncoming
        64   -> emberAfGetNodeId
        64   -> emberGetCurrentNetwork
        64   -> executeCallback
        64   -> halCommonMemCopy
      24   emberAfFindClustersByDeviceAndEndpoint
        24   -> emberGetCurrentNetwork
        24   -> emberSimpleDescriptorRequest
        24   -> setupDiscoveryData
      24   emberAfFindDevicesByProfileAndCluster
        24   -> emAfSendMatchDescriptor
        24   -> emberGetCurrentNetwork
        24   -> setupDiscoveryData
      16   emberAfFindIeeeAddress
        16   -> emberGetCurrentNetwork
        16   -> emberIeeeAddressRequest
        16   -> setupDiscoveryData
      16   emberAfFindNodeId
        16   -> emberGetCurrentNetwork
        16   -> emberNetworkAddressRequest
        16   -> setupDiscoveryData
       8   executeCallback
         8   -- Indirect call
         8   -> emberGetCurrentNetwork
      24   serviceDiscoveryComplete
        24   -- Indirect call
        24   -> emberAfNetworkEventControlSetInactive
        24   -> emberAfPopNetworkIndex
        24   -> emberAfPushNetworkIndex
        24   -> emberAfRemoveFromCurrentAppTasksCallback
       8   setupDiscoveryData
         0   -> emberAfAddToCurrentAppTasksCallback
         8   -> emberAfNetworkEventControlSetDelayQS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
      16  ?Subroutine0
      16  ?Subroutine1
      14  ?Subroutine2
       4  emAfServiceDiscoveryComplete0
       4  emAfServiceDiscoveryComplete1
       4  emAfServiceDiscoveryComplete2
       4  emAfServiceDiscoveryComplete3
      20  emAfServiceDiscoveryEventControls
          states
     284  emAfServiceDiscoveryIncoming
      52  emberAfFindClustersByDeviceAndEndpoint
      76  emberAfFindDevicesByProfileAndCluster
      50  emberAfFindIeeeAddress
      50  emberAfFindNodeId
      32  executeCallback
      80  serviceDiscoveryComplete
      40  setupDiscoveryData

 
  20 bytes in section .bss
 730 bytes in section .text
 
 730 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
