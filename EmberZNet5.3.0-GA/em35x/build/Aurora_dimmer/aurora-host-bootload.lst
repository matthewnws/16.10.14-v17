###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:33:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-host-protocol\aurora-host-bootload.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-host-protocol\aurora-host-bootload.c"
#        -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"aurora-host-bootload.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-host-protocol\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\aurora-host-bootload.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\aurora-host-bootload.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-host-protocol\aurora-host-bootload.c
      1          // aurora-host-bootload.c & aurora-host-bootload.c
      2          //
      3          // This plugin allows for bootloading of SMT32 microcontrollers
      4          // over UART. The procedure is very simple and can be referenced
      5          // from the UART booloading app note AN3155 found at:
      6          //
      7          // www.st.com/web/en/resource/technical/document/.../CD00264342.pdf
      8          // (google that..)
      9          //
     10          // Created: 09/03/2015 | Rajesh Nakarja
     11          //
     12          // (C) Telegesis UK Ltd 2015 - All rights reserved
     13          
     14          
     15          // ----------------
     16          // -- Includes
     17          // ----------------
     18          #include "app/framework/include/af.h"
     19          #include "aurora-host-hal.h"
     20          #include "aurora-host-bootload.h"
     21          
     22          // Option to enable or disable debug printing. See .h file
     23          #ifdef STM32_BOOTLOAD_DEBUG_PRINT_EN
     24              #define STMBLDebugPrint(...) emberAfPrint(EMBER_AF_PRINT_DEBUG, __VA_ARGS__)
     25          #else
     26              #define STMBLDebugPrint(...)
     27          #endif
     28          
     29          // ----------------
     30          // -- Variables
     31          // ----------------

   \                                 In section .bss, align 4
     32          int8u flashBuffer[STM_DEFAULT_PAGE]; // Flash buffer and send buffer are what they say they are.
     33          int8u sendBuffer[STM_DEFAULT_PAGE + 5] = {0x00}; // give a bit of room for a few more checksum and option bytes
   \                     sendBuffer:
   \   00000000                      DS8 72
     34          int8u checksum = 0x00; // checksum variable we use once in a while
   \                     checksum:
   \   00000048                      DS8 1
   \   00000049                      DS8 3
   \                     flashBuffer:
   \   0000004C                      DS8 64
     35          
     36          // ----------------
     37          // -- Local prototypes
     38          // ----------------
     39          void BootloadStateHandler(void);
     40          boolean waitForAck(int32u timeout);
     41          void delay(int32u time);
     42          
     43          
     44          // ----------------
     45          // -- Main function
     46          // ----------------
     47          
     48          // Main bootload routine. This is a completly linear operation
     49          // and should be completed in order as a routine. If an error
     50          // occurs, FALSE will be returned. Otherwise TRUE and the
     51          // bootload should be successful.
     52          //
     53          // If you need to debug this code, read and follow it very carefully
     54          // according to the STM32 appnote "AN3155".

   \                                 In section .text, align 2, keep-with-next
     55          boolean emberAfPluginAuroraBootloadUpgrade(int32u offset, int32u endOffset)
     56          {
   \                     emberAfPluginAuroraBootloadUpgrade: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
     57          
     58          // --------------------------------------------------------
     59          // -- Init ------------------------------------------------
     60          // --------------------------------------------------------
     61          
     62              STMBLDebugPrint("\r\nOffset: %4X, End: %4X", offset, endOffset);
   \   00000008   0x463B             MOV      R3,R7
   \   0000000A   0x4622             MOV      R2,R4
   \   0000000C   0x.... 0x....      ADR.W    R1,?_0
   \   00000010   0x....             LDR.N    R5,??DataTable14
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       emberAfPrint
     63              // Init serial port
     64              emberAfPluginAuroraHostHalSerialInitHostBootload();
   \   00000018   0x.... 0x....      BL       emberAfPluginAuroraHostHalSerialInitHostBootload
     65          
     66              // First we bring BOOT0 high and reset the STM32
     67              emberAfPluginAuroraHostHalResetPin(FALSE);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       emberAfPluginAuroraHostHalResetPin
     68              emberAfPluginAuroraHostHalBootloadPin(TRUE);
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       emberAfPluginAuroraHostHalBootloadPin
     69          
     70              // Give a bit of time for the chip to sit in reset
     71              delay(10);
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0x.... 0x....      BL       delay
     72          
     73              // Bring chip out of reset and into. We should now be in bl mode.
     74              emberAfPluginAuroraHostHalResetPin(TRUE);
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       emberAfPluginAuroraHostHalResetPin
     75              
     76              // Let's send an init command to the STM32
     77              sendBuffer[0] = 0x7F;
   \   00000034   0x207F             MOVS     R0,#+127
   \   00000036   0x7028             STRB     R0,[R5, #+0]
     78              emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 1);
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x.... 0x....      BL       ??Subroutine1_0
     79          
     80              // We should receive an ack
     81              if (!waitForAck(ACK_TIMEOUT)) return FALSE;
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000003E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD01C             BEQ.N    ??emberAfPluginAuroraBootloadUpgrade_0
     82          
     83          // --------------------------------------------------------
     84          // -- Get ------------------------------------------------
     85          // --------------------------------------------------------
     86          
     87              // We don't need to bother with the GET command because
     88              // we know exactly what processor we're using anyway
     89          
     90          // --------------------------------------------------------
     91          // -- Erase ------------------------------------------------
     92          // --------------------------------------------------------
     93          
     94              // Time to erase chip, lets send the erase command
     95              STMBLDebugPrint("\r\nErasing");
   \   00000046   0x.... 0x....      ADR.W    R1,?_1
   \   0000004A   0x.... 0x....      BL       ?Subroutine0
     96              sendBuffer[0] = 0x44;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000004E   0x2044             MOVS     R0,#+68
   \   00000050   0x7028             STRB     R0,[R5, #+0]
     97              sendBuffer[1] = 0xBB; // Checksum
     98              emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 2);
   \   00000052   0x2102             MOVS     R1,#+2
   \   00000054   0x20BB             MOVS     R0,#+187
   \   00000056   0x.... 0x....      BL       ?Subroutine1
     99              
    100              // We should receive an ack
    101              if (!waitForAck(ACK_TIMEOUT)) return FALSE;
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000005A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_16: (+1)
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD00E             BEQ.N    ??emberAfPluginAuroraBootloadUpgrade_0
    102          
    103              // Now to send global erase cmd to erase entire chip
    104              STMBLDebugPrint("\r\nGlobal erase");
   \   00000062   0x.... 0x....      ADR.W    R1,?_2
   \   00000066   0x.... 0x....      BL       ?Subroutine0
    105              sendBuffer[0] = 0xFF;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000006A   0x20FF             MOVS     R0,#+255
   \   0000006C   0x7028             STRB     R0,[R5, #+0]
    106              sendBuffer[1] = 0xFF;
   \   0000006E   0x7068             STRB     R0,[R5, #+1]
    107              sendBuffer[2] = 0x00; // Checksum
    108              emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 3);
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x70A8             STRB     R0,[R5, #+2]
   \   00000076   0x.... 0x....      BL       ??Subroutine1_0
    109          
    110              // We should receive an ack
    111              if (!waitForAck(ACK_TIMEOUT)) return FALSE;
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000007A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000007E   0x2800             CMP      R0,#+0
   \                     ??emberAfPluginAuroraBootloadUpgrade_0: (+1)
   \   00000080   0xD071             BEQ.N    ??emberAfPluginAuroraBootloadUpgrade_1
    112              STMBLDebugPrint("\r\nErased!");
   \   00000082   0x.... 0x....      ADR.W    R1,?_3
   \   00000086   0x.... 0x....      ADR.W    R8,?_6
   \   0000008A   0x.... 0x....      ADR.W    R9,?_5
   \   0000008E   0x.... 0x....      ADR.W    R10,?_4
   \   00000092   0x.... 0x....      BL       ?Subroutine0
    113          
    114          // --------------------------------------------------------
    115          // -- Write ------------------------------------------------
    116          // --------------------------------------------------------
    117          
    118              int32u currentAddress = 0;
    119              int32u endAddress = endOffset - offset;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000096   0x1B38             SUBS     R0,R7,R4
   \   00000098   0x2600             MOVS     R6,#+0
   \   0000009A   0x9002             STR      R0,[SP, #+8]
    120              int8u pageSize = STM_DEFAULT_PAGE;
   \   0000009C   0xF105 0x0741      ADD      R7,R5,#+65
   \   000000A0   0xE005             B.N      ??CrossCallReturnLabel_21
    121          
    122              // Loop to write data. NOTE: this loop will overun the last page by pagesize
    123              // this is because endOffset isn't actually the end of data. It's 64 bytes short
    124              // so we can't use that. This is actually okay as long as the external Flash has
    125              // 0xFFFF in all those overrun locations (it should because its erased before a
    126              // write.
    127              while(currentAddress < endAddress + pageSize)
    128              {
    129          
    130          // -------------------- Write cmd
    131          
    132                  // Begin writing to chip, first we send write command
    133                  sendBuffer[0] = 0x31;
    134                  sendBuffer[1] = 0xCE;
    135                  emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 2);
    136          
    137                  // We should receive an ack
    138                  if (!waitForAck(ACK_TIMEOUT)) return FALSE;
    139          
    140          // -------------------- Address 
    141          
    142                  // Now we send the start address of the program code and checksum
    143                  sendBuffer[0] = (int8u) ((currentAddress + STM_FLASH_OFFSET) >> 24) & 0xFF; // MSB
    144                  sendBuffer[1] = (int8u) ((currentAddress + STM_FLASH_OFFSET) >> 16) & 0xFF;
    145                  sendBuffer[2] = (int8u) ((currentAddress + STM_FLASH_OFFSET) >> 8)  & 0xFF;
    146                  sendBuffer[3] = (int8u) ((currentAddress + STM_FLASH_OFFSET))  & 0xFF; // LSB
    147                  sendBuffer[4] = sendBuffer[0] ^ sendBuffer[1] ^ sendBuffer[2] ^ sendBuffer[3]; // Checksum
    148                  emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 5);
    149                  STMBLDebugPrint("\r\nAddress: %X %X %X %X", sendBuffer[0], sendBuffer[1], sendBuffer[2], sendBuffer[3]);
    150                  
    151                  // We should receive an ack
    152                  if (!waitForAck(ACK_TIMEOUT)) return FALSE;
    153          
    154          // -------------------- Amount of data
    155          
    156                  // Now we need to tell the STM32 how many bytes we'll send
    157                  sendBuffer[0] = pageSize - 1; // We send N-1 , not N, according to the appnote
    158                  checksum = sendBuffer[0]; // Xor to checksum
    159          
    160          // -------------------- Send data 
    161          
    162                  // Read a page from flash, print offset and page size.
    163                  STMBLDebugPrint("\r\nReading flash at offset: %4X, length %d", currentAddress + offset, pageSize);
    164                  if (!emberAfOtaStorageDriverReadCallback(currentAddress + offset, pageSize, flashBuffer)) return FALSE;
    165          
    166                  // Copy data from Flash read buffer to sending buffer
    167                  for (int i = 0; i < pageSize; i++)
    168                  {
    169                      sendBuffer[i+1] = flashBuffer[i]; // +1 because we have the number byte at the start
    170                      checksum ^= sendBuffer[i+1]; // Xor this to checksum
    171                  }
    172                  sendBuffer[pageSize + 1] = checksum; // +1 because we have num of bytes in [0] and data up to [pagesize + 1] (we overwrite the + 1)
    173                 
    174                  // Send num of bytes, data and checksum
    175                  STMBLDebugPrint("\r\nWriting %d bytes. Checksum is: %X", pageSize, checksum);
    176                  emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, pageSize + 2); // +2 because we have num of pages + pagesize-1 + checksum
    177          
    178                  // We should receive an ack
    179                  if (!waitForAck(ACK_TIMEOUT)) return FALSE;
    180          
    181          // -------------------- Increment pagesize for next data 
    182          
    183                  // Increment out currentAddress
    184                  currentAddress += pageSize;
   \                     ??emberAfPluginAuroraBootloadUpgrade_2: (+1)
   \   000000A2   0x3640             ADDS     R6,R6,#+64
    185                  STMBLDebugPrint("\r\nNext write address will be: %4X", currentAddress);
   \   000000A4   0x4632             MOV      R2,R6
   \   000000A6   0x.... 0x....      ADR.W    R1,?_7
   \   000000AA   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_21: (+1)
   \   000000AE   0x9802             LDR      R0,[SP, #+8]
   \   000000B0   0x3040             ADDS     R0,R0,#+64
   \   000000B2   0x4286             CMP      R6,R0
   \   000000B4   0xD259             BCS.N    ??emberAfPluginAuroraBootloadUpgrade_3
   \   000000B6   0x2031             MOVS     R0,#+49
   \   000000B8   0x7028             STRB     R0,[R5, #+0]
   \   000000BA   0x2102             MOVS     R1,#+2
   \   000000BC   0x20CE             MOVS     R0,#+206
   \   000000BE   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_10: (+1)
   \   000000C2   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_14: (+1)
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD04D             BEQ.N    ??emberAfPluginAuroraBootloadUpgrade_1
   \   000000CA   0xF106 0x6000      ADD      R0,R6,#+134217728
   \   000000CE   0x0E00             LSRS     R0,R0,#+24
   \   000000D0   0x7028             STRB     R0,[R5, #+0]
   \   000000D2   0x70EE             STRB     R6,[R5, #+3]
   \   000000D4   0x0C30             LSRS     R0,R6,#+16
   \   000000D6   0x7068             STRB     R0,[R5, #+1]
   \   000000D8   0x0A30             LSRS     R0,R6,#+8
   \   000000DA   0x70A8             STRB     R0,[R5, #+2]
   \   000000DC   0x7869             LDRB     R1,[R5, #+1]
   \   000000DE   0x7828             LDRB     R0,[R5, #+0]
   \   000000E0   0x4048             EORS     R0,R1,R0
   \   000000E2   0x78A9             LDRB     R1,[R5, #+2]
   \   000000E4   0x4048             EORS     R0,R1,R0
   \   000000E6   0x78E9             LDRB     R1,[R5, #+3]
   \   000000E8   0x4048             EORS     R0,R1,R0
   \   000000EA   0x7128             STRB     R0,[R5, #+4]
   \   000000EC   0x2105             MOVS     R1,#+5
   \   000000EE   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \   000000F2   0x78E8             LDRB     R0,[R5, #+3]
   \   000000F4   0x786B             LDRB     R3,[R5, #+1]
   \   000000F6   0x782A             LDRB     R2,[R5, #+0]
   \   000000F8   0x9001             STR      R0,[SP, #+4]
   \   000000FA   0x4651             MOV      R1,R10
   \   000000FC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000FE   0x9000             STR      R0,[SP, #+0]
   \   00000100   0x2002             MOVS     R0,#+2
   \   00000102   0x.... 0x....      BL       emberAfPrint
   \   00000106   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000010A   0xB360             CBZ.N    R0,??emberAfPluginAuroraBootloadUpgrade_1
   \   0000010C   0x203F             MOVS     R0,#+63
   \   0000010E   0x7028             STRB     R0,[R5, #+0]
   \   00000110   0x71F8             STRB     R0,[R7, #+7]
   \   00000112   0xEB04 0x0B06      ADD      R11,R4,R6
   \   00000116   0x2340             MOVS     R3,#+64
   \   00000118   0x465A             MOV      R2,R11
   \   0000011A   0x4649             MOV      R1,R9
   \   0000011C   0x2002             MOVS     R0,#+2
   \   0000011E   0x.... 0x....      BL       emberAfPrint
   \   00000122   0xF105 0x024C      ADD      R2,R5,#+76
   \   00000126   0x2140             MOVS     R1,#+64
   \   00000128   0x4658             MOV      R0,R11
   \   0000012A   0x.... 0x....      BL       emberAfOtaStorageDriverReadCallback
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD019             BEQ.N    ??emberAfPluginAuroraBootloadUpgrade_1
   \   00000132   0x2000             MOVS     R0,#+0
   \                     ??emberAfPluginAuroraBootloadUpgrade_4: (+1)
   \   00000134   0x1941             ADDS     R1,R0,R5
   \   00000136   0x1942             ADDS     R2,R0,R5
   \   00000138   0xF891 0x104C      LDRB     R1,[R1, #+76]
   \   0000013C   0x7051             STRB     R1,[R2, #+1]
   \   0000013E   0x1C40             ADDS     R0,R0,#+1
   \   00000140   0x79FA             LDRB     R2,[R7, #+7]
   \   00000142   0xEA81 0x0302      EOR      R3,R1,R2
   \   00000146   0x2840             CMP      R0,#+64
   \   00000148   0x71FB             STRB     R3,[R7, #+7]
   \   0000014A   0xDBF3             BLT.N    ??emberAfPluginAuroraBootloadUpgrade_4
   \   0000014C   0x703B             STRB     R3,[R7, #+0]
   \   0000014E   0x2240             MOVS     R2,#+64
   \   00000150   0x4641             MOV      R1,R8
   \   00000152   0x2002             MOVS     R0,#+2
   \   00000154   0x.... 0x....      BL       emberAfPrint
   \   00000158   0x2142             MOVS     R1,#+66
   \   0000015A   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000015E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD19D             BNE.N    ??emberAfPluginAuroraBootloadUpgrade_2
   \                     ??emberAfPluginAuroraBootloadUpgrade_1: (+1)
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xE003             B.N      ??emberAfPluginAuroraBootloadUpgrade_5
    186              }
    187          
    188          
    189          // --------------------------------------------------------
    190          // -- Set BOOT0 pin low -----------------------------------
    191          // --------------------------------------------------------
    192          
    193              emberAfPluginAuroraHostHalBootloadPin(FALSE);
   \                     ??emberAfPluginAuroraBootloadUpgrade_3: (+1)
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x.... 0x....      BL       emberAfPluginAuroraHostHalBootloadPin
    194          
    195          // --------------------------------------------------------
    196          // -- Go ---- !!!! UNUSED !!!! ----------------------------
    197          // --------------------------------------------------------
    198          /*
    199              // Send Go command
    200              STMBLDebugPrint("\r\nJumping to application start location!");
    201              sendBuffer[0] = 0x21;
    202              sendBuffer[1] = 0xDE; // Checksum
    203              emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 2);
    204          
    205              // We should receive an ack
    206              if (!waitForAck(ACK_TIMEOUT)) return FALSE;
    207          
    208              // Now we send the start address of the program code and checksum
    209              sendBuffer[0] = (int8u) (STM_FLASH_OFFSET >> 24) & 0xFF; // MSB
    210              sendBuffer[1] = (int8u) (STM_FLASH_OFFSET >> 16) & 0xFF;
    211              sendBuffer[2] = (int8u) (STM_FLASH_OFFSET >> 8)  & 0xFF;
    212              sendBuffer[3] = (int8u) (STM_FLASH_OFFSET >> 0)  & 0xFF; // LSB
    213              sendBuffer[4] = sendBuffer[0] ^ sendBuffer[1] ^ sendBuffer[2] ^ sendBuffer[3]; // Checksum
    214              emberAfPluginAuroraHostHalPlcSendCommand(sendBuffer, 5);
    215          
    216              // We should receive an ack
    217              if (!waitForAck(ACK_TIMEOUT)) return FALSE;
    218              STMBLDebugPrint("\r\nComplete!");
    219          */
    220              return TRUE;
   \   00000170   0x2001             MOVS     R0,#+1
   \                     ??emberAfPluginAuroraBootloadUpgrade_5: (+1)
   \   00000172   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    221          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2064             MOVS     R0,#+100
   \   00000002   0x....             B.N      waitForAck

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x7068             STRB     R0,[R5, #+1]
   \                     ??Subroutine1_0: (+1)
   \   00000002   0x4628             MOV      R0,R5
   \   00000004   0x.... 0x....      B.W      emberAfPluginAuroraHostHalPlcSendCommand

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x.... 0x....      B.W      emberAfPrint

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x.... 0x....      B.W      emberAfPrint
    222          
    223          
    224          // This function waits for an ACK byte to be received. If the timeout is
    225          // reached, it will return FALSE.
    226          //
    227          // Timeout is a number in mS

   \                                 In section .text, align 2, keep-with-next
    228          boolean waitForAck(int32u timeout)
    229          {
   \                     waitForAck: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    230              int8u ack; // Variable that we'll store the incomming data in
    231              int16u length = 1; // Only care about reading 1 byte at a time here
    232          
    233              STMBLDebugPrint("\r\nWaiting for ACK. Timeout in: %dms", timeout);
   \   00000006   0x4622             MOV      R2,R4
   \   00000008   0x.... 0x....      ADR.W    R1,?_8
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    234              
    235              int32u startTime = halCommonGetInt32uMillisecondTick(); 
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000010   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000014   0x2501             MOVS     R5,#+1
   \   00000016   0x4606             MOV      R6,R0
   \   00000018   0xE001             B.N      ??waitForAck_0
    236              while(halCommonGetInt32uMillisecondTick() - startTime < timeout)
    237              {
    238                  if (emberAfPluginAuroraHostHalPlcReadBytes() == EMBER_SUCCESS)
    239                  {
    240                      // Read the bytes
    241                      length = receiveReadBuffer(&ack, length);
    242                      if(length == 1) 
    243                      {  
    244                          if (ack == ACK) 
    245                          {
    246                              STMBLDebugPrint(": ACK");    
    247                              return TRUE;
    248                          } 
    249                          else if (ack == NACK) 
    250                          {
    251                              STMBLDebugPrint(": NACK");    
    252                              return FALSE;
    253                          }
    254                      }
    255          
    256                  }
    257                  
    258                  // We have to reset the wd timer because this can take a while
    259                  halResetWatchdog(); 
   \                     ??waitForAck_1: (+1)
   \   0000001A   0x.... 0x....      BL       halInternalResetWatchDog
   \                     ??waitForAck_0: (+1)
   \   0000001E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000022   0x1B80             SUBS     R0,R0,R6
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD21B             BCS.N    ??waitForAck_2
   \   00000028   0x.... 0x....      BL       emberAfPluginAuroraHostHalPlcReadBytes
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD1F4             BNE.N    ??waitForAck_1
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       receiveReadBuffer
   \   00000038   0x4605             MOV      R5,R0
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD1ED             BNE.N    ??waitForAck_1
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2879             CMP      R0,#+121
   \   00000044   0xD105             BNE.N    ??waitForAck_3
   \   00000046   0x.... 0x....      ADR.W    R1,?_9
   \   0000004A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??waitForAck_3: (+1)
   \   00000052   0x281F             CMP      R0,#+31
   \   00000054   0xD1E1             BNE.N    ??waitForAck_1
   \   00000056   0x.... 0x....      ADR.W    R1,?_10
   \   0000005A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000005E   0xE004             B.N      ??CrossCallReturnLabel_19
    260              }
    261          
    262              STMBLDebugPrint("\r\nNo ACK, timed out", timeout);
   \                     ??waitForAck_2: (+1)
   \   00000060   0x4622             MOV      R2,R4
   \   00000062   0x.... 0x....      ADR.W    R1,?_11
   \   00000066   0x.... 0x....      BL       ?Subroutine3
    263              return FALSE;
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    264          }
    265          
    266          // Resets all devices on the reset line of the STM32

   \                                 In section .text, align 2, keep-with-next
    267          void STM32ToggleReset()
    268          {
   \                     STM32ToggleReset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    269              STMBLDebugPrint("\r\nPerforming hard reset to all devices..\r\n");
   \   00000002   0x.... 0x....      ADR.W    R1,?_12
   \   00000006   0x.... 0x....      BL       ?Subroutine0
    270              
    271              // Drop the bootload pin low
    272              emberAfPluginAuroraHostHalBootloadPin(FALSE);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       emberAfPluginAuroraHostHalBootloadPin
    273          
    274              // Reset device
    275              emberAfPluginAuroraHostHalResetPin(FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       emberAfPluginAuroraHostHalResetPin
    276              delay(3);
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x.... 0x....      BL       delay
    277              emberAfPluginAuroraHostHalResetPin(TRUE);
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      B.W      emberAfPluginAuroraHostHalResetPin
    278          }
    279          
    280          // A simple function to create blocking delays.
    281          //
    282          // Time is a number in mS

   \                                 In section .text, align 2, keep-with-next
    283          void delay(int32u time)
    284          {
   \                     delay: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    285              STMBLDebugPrint("\r\nDelaying: %dms", time);
   \   00000004   0x4622             MOV      R2,R4
   \   00000006   0x.... 0x....      ADR.W    R1,?_13
   \   0000000A   0x.... 0x....      BL       ?Subroutine3
    286              int32u startTime = halCommonGetInt32uMillisecondTick(); 
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000000E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xE001             B.N      ??delay_0
    287              while(halCommonGetInt32uMillisecondTick() - startTime < time)
    288              {
    289                  halResetWatchdog(); 
   \                     ??delay_1: (+1)
   \   00000016   0x.... 0x....      BL       halInternalResetWatchDog
    290              }
   \                     ??delay_0: (+1)
   \   0000001A   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   0000001E   0x1B40             SUBS     R0,R0,R5
   \   00000020   0x42A0             CMP      R0,R4
   \   00000022   0xD3F8             BCC.N    ??delay_1
    291          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     sendBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012Offset: %4X, End: %4X"
   \              0x4F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x3A 0x20    
   \              0x25 0x34    
   \              0x58 0x2C    
   \              0x20 0x45    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x34    
   \              0x58 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x0D 0x0A          DC8 "\015\012Erasing"
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x69 0x6E    
   \              0x67 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0D 0x0A          DC8 "\015\012Global erase"
   \              0x47 0x6C    
   \              0x6F 0x62    
   \              0x61 0x6C    
   \              0x20 0x65    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x0D 0x0A          DC8 "\015\012Erased!"
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x64    
   \              0x21 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0D 0x0A          DC8 "\015\012Address: %X %X %X %X"
   \              0x41 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x3A    
   \              0x20 0x25    
   \              0x58 0x20    
   \              0x25 0x58    
   \              0x20 0x25    
   \              0x58 0x20    
   \              0x25 0x58    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x0D 0x0A          DC8 "\015\012Reading flash at offset: %4X, length %d"
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x20    
   \              0x61 0x74    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x73 0x65    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x34 0x58    
   \              0x2C 0x20    
   \              0x6C 0x65    
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x25    
   \              0x64 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x0D 0x0A          DC8 "\015\012Writing %d bytes. Checksum is: %X"
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x25 0x64    
   \              0x20 0x62    
   \              0x79 0x74    
   \              0x65 0x73    
   \              0x2E 0x20    
   \              0x43 0x68    
   \              0x65 0x63    
   \              0x6B 0x73    
   \              0x75 0x6D    
   \              0x20 0x69    
   \              0x73 0x3A    
   \              0x20 0x25    
   \              0x58 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x0D 0x0A          DC8 "\015\012Next write address will be: %4X"
   \              0x4E 0x65    
   \              0x78 0x74    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x20 0x77    
   \              0x69 0x6C    
   \              0x6C 0x20    
   \              0x62 0x65    
   \              0x3A 0x20    
   \              0x25 0x34    
   \              0x58 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x0D 0x0A          DC8 "\015\012Waiting for ACK. Timeout in: %dms"
   \              0x57 0x61    
   \              0x69 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x41 0x43    
   \              0x4B 0x2E    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x69    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x64 0x6D    
   \              0x73 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x3A 0x20          DC8 ": ACK"
   \              0x41 0x43    
   \              0x4B 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x3A 0x20          DC8 ": NACK"
   \              0x4E 0x41    
   \              0x43 0x4B    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x0D 0x0A          DC8 "\015\012No ACK, timed out"
   \              0x4E 0x6F    
   \              0x20 0x41    
   \              0x43 0x4B    
   \              0x2C 0x20    
   \              0x74 0x69    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x6F 0x75    
   \              0x74 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x0D 0x0A          DC8 "\015\012Performing hard reset to all devices..\015\012"
   \              0x50 0x65    
   \              0x72 0x66    
   \              0x6F 0x72    
   \              0x6D 0x69    
   \              0x6E 0x67    
   \              0x20 0x68    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x74 0x6F    
   \              0x20 0x61    
   \              0x6C 0x6C    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x73    
   \              0x2E 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x0D 0x0A          DC8 "\015\012Delaying: %dms"
   \              0x44 0x65    
   \              0x6C 0x61    
   \              0x79 0x69    
   \              0x6E 0x67    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x6D 0x73    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   STM32ToggleReset
         8   -> delay
         8   -> emberAfPluginAuroraHostHalBootloadPin
         0   -> emberAfPluginAuroraHostHalResetPin
         8   -> emberAfPluginAuroraHostHalResetPin
         8   -> emberAfPrint
      16   delay
        16   -> emberAfPrint
        16   -> halCommonGetInt32uMillisecondTick
        16   -> halInternalResetWatchDog
      48   emberAfPluginAuroraBootloadUpgrade
        48   -> delay
        48   -> emberAfOtaStorageDriverReadCallback
        48   -> emberAfPluginAuroraHostHalBootloadPin
        48   -> emberAfPluginAuroraHostHalPlcSendCommand
        48   -> emberAfPluginAuroraHostHalResetPin
        48   -> emberAfPluginAuroraHostHalSerialInitHostBootload
        48   -> emberAfPrint
        48   -> waitForAck
      24   waitForAck
        24   -> emberAfPluginAuroraHostHalPlcReadBytes
        24   -> emberAfPrint
        24   -> halCommonGetInt32uMillisecondTick
        24   -> halInternalResetWatchDog
        24   -> receiveReadBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       6  ?Subroutine0
       8  ?Subroutine1
       4  ?Subroutine2
       6  ?Subroutine3
      24  ?_0
      12  ?_1
       8  ?_10
      20  ?_11
      44  ?_12
      20  ?_13
      16  ?_2
      12  ?_3
      24  ?_4
      44  ?_5
      36  ?_6
      36  ?_7
      36  ?_8
       8  ?_9
      38  STM32ToggleReset
      38  delay
     374  emberAfPluginAuroraBootloadUpgrade
     140  sendBuffer
          checksum
          flashBuffer
     110  waitForAck

 
 140 bytes in section .bss
 928 bytes in section .text
 
 928 bytes of CODE memory
 140 bytes of DATA memory

Errors: none
Warnings: none
