###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:33:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\util\attribute-storage.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\util\attribute-storage.c" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"attribute-storage.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\util\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\attribute-storage.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\attribute-storage.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\util\attribute-storage.c
      1          // *******************************************************************
      2          // * attribute-storage.c
      3          // *
      4          // * Contains the per-endpoint configuration of attribute tables.
      5          // *
      6          // * Copyright 2013 Silicon Laboratories, Inc.                              *80*
      7          // *******************************************************************
      8          
      9          #include "app/framework/include/af.h"
     10          #include "attribute-storage.h"
     11          #include "common.h"
     12          
     13          //------------------------------------------------------------------------------
     14          // Globals
     15          // This is not declared CONST in order to handle dynamic endpoint information
     16          // retrieved from tokens.

   \                                 In section .bss, align 4
     17          EmberAfDefinedEndpoint emAfEndpoints[MAX_ENDPOINT_COUNT];
   \                     emAfEndpoints:
   \   00000000                      DS8 48
     18          
     19          #if ( ATTRIBUTE_MAX_SIZE == 0 )
     20          #define ACTUAL_ATTRIBUTE_SIZE 1
     21          #else
     22          #define ACTUAL_ATTRIBUTE_SIZE ATTRIBUTE_MAX_SIZE
     23          #endif
     24          

   \                                 In section .bss, align 4
     25          int8u attributeData[ACTUAL_ATTRIBUTE_SIZE];
     26          
     27          #if (!defined(ATTRIBUTE_SINGLETONS_SIZE)) \
     28            || (ATTRIBUTE_SINGLETONS_SIZE == 0)
     29          #define ACTUAL_SINGLETONS_SIZE 1
     30          #else
     31          #define ACTUAL_SINGLETONS_SIZE ATTRIBUTE_SINGLETONS_SIZE
     32          #endif
     33          int8u singletonAttributeData[ACTUAL_SINGLETONS_SIZE];
     34          
     35          int8u emberEndpointCount = 0;
   \                     emberEndpointCount:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     attributeData:
   \   00000004                      DS8 300
   \                     singletonAttributeData:
   \   00000130                      DS8 72
     36          
     37          // If we have attributes that are more than 2 bytes, then
     38          // we need this data block for the defaults
     39          #ifdef GENERATED_DEFAULTS

   \                                 In section .rodata, align 4, keep-with-next
     40          const int8u generatedDefaults[]               = GENERATED_DEFAULTS;
   \                     generatedDefaults:
   \   00000000   0x06 0x41          DC8 6, 65, 117, 114, 111, 114, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x75 0x72    
   \              0x6F 0x72    
   \              0x61 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000013   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 68, 105, 109, 109, 101
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x06 0x44    
   \              0x69 0x6D    
   \              0x6D 0x65    
   \   00000027   0x72 0x00          DC8 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000003D   0x00 0x00          DC8 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
   \              0x00 0x00    
   \              0x00 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF         
   \   0000004C   0xFF 0xFF          DC8 255, 255, 0, 0
   \              0x00 0x00    
     41          #endif // GENERATED_DEFAULTS
     42          
     43          #ifdef GENERATED_MIN_MAX_DEFAULTS
     44          const EmberAfAttributeMinMaxValue minMaxDefaults[]          = GENERATED_MIN_MAX_DEFAULTS;
     45          #endif //GENERATED_MIN_MAX_DEFAULTS
     46          
     47          #ifdef GENERATED_FUNCTION_ARRAYS

   \                                 In section .rodata, align 4, keep-with-next
     48          GENERATED_FUNCTION_ARRAYS
   \                     emberAfFuncArrayIdentifyClusterServer:
   \   00000000   0x........         DC32 emberAfIdentifyClusterServerInitCallback
   \   00000004   0x........         DC32 emberAfIdentifyClusterServerAttributeChangedCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayGroupsClusterServer[1])(void)
   \                     emberAfFuncArrayGroupsClusterServer:
   \   00000000   0x........         DC32 emberAfGroupsClusterServerInitCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayScenesClusterServer[1])(void)
   \                     emberAfFuncArrayScenesClusterServer:
   \   00000000   0x........         DC32 emberAfScenesClusterServerInitCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayLevelControlClusterServer[1])(void)
   \                     emberAfFuncArrayLevelControlClusterServer:
   \   00000000   0x........         DC32 emberAfLevelControlClusterServerInitCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayTunnelingClusterServer[2])(void)
   \                     emberAfFuncArrayTunnelingClusterServer:
   \   00000000   0x........         DC32 emberAfTunnelingClusterServerInitCallback
   \   00000004   0x........         DC32 emberAfTunnelingClusterServerAttributeChangedCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayOtaBootloadClusterClient[2])(void)
   \                     emberAfFuncArrayOtaBootloadClusterClient:
   \   00000000   0x........         DC32 emberAfOtaBootloadClusterClientInitCallback
   \   00000004   0x........         DC32 emberAfOtaBootloadClusterClientDefaultResponseCallback
     49          #endif
     50          
     51          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY

   \                                 In section .text, align 4, keep-with-next
     52          const EmberAfCommandMetadata generatedCommands[] = GENERATED_COMMANDS;
   \                     generatedCommands:
   \   00000000   0x0003             DC16 3
   \   00000002   0x00 0x09          DC8 0, 9
   \   00000004   0x0003             DC16 3
   \   00000006   0x00 0x06          DC8 0, 6
   \   00000008   0x0003             DC16 3
   \   0000000A   0x01 0x09          DC8 1, 9
   \   0000000C   0x0004             DC16 4
   \   0000000E   0x00 0x02          DC8 0, 2
   \   00000010   0x0004             DC16 4
   \   00000012   0x00 0x08          DC8 0, 8
   \   00000014   0x0004             DC16 4
   \   00000016   0x01 0x02          DC8 1, 2
   \   00000018   0x0004             DC16 4
   \   0000001A   0x01 0x08          DC8 1, 8
   \   0000001C   0x0004             DC16 4
   \   0000001E   0x02 0x02          DC8 2, 2
   \   00000020   0x0004             DC16 4
   \   00000022   0x02 0x08          DC8 2, 8
   \   00000024   0x0004             DC16 4
   \   00000026   0x03 0x02          DC8 3, 2
   \   00000028   0x0004             DC16 4
   \   0000002A   0x03 0x08          DC8 3, 8
   \   0000002C   0x0004             DC16 4
   \   0000002E   0x04 0x08          DC8 4, 8
   \   00000030   0x0004             DC16 4
   \   00000032   0x05 0x08          DC8 5, 8
   \   00000034   0x0005             DC16 5
   \   00000036   0x00 0x02          DC8 0, 2
   \   00000038   0x0005             DC16 5
   \   0000003A   0x00 0x08          DC8 0, 8
   \   0000003C   0x0005             DC16 5
   \   0000003E   0x01 0x02          DC8 1, 2
   \   00000040   0x0005             DC16 5
   \   00000042   0x01 0x08          DC8 1, 8
   \   00000044   0x0005             DC16 5
   \   00000046   0x02 0x02          DC8 2, 2
   \   00000048   0x0005             DC16 5
   \   0000004A   0x02 0x08          DC8 2, 8
   \   0000004C   0x0005             DC16 5
   \   0000004E   0x03 0x02          DC8 3, 2
   \   00000050   0x0005             DC16 5
   \   00000052   0x03 0x08          DC8 3, 8
   \   00000054   0x0005             DC16 5
   \   00000056   0x04 0x02          DC8 4, 2
   \   00000058   0x0005             DC16 5
   \   0000005A   0x04 0x08          DC8 4, 8
   \   0000005C   0x0005             DC16 5
   \   0000005E   0x05 0x08          DC8 5, 8
   \   00000060   0x0005             DC16 5
   \   00000062   0x06 0x02          DC8 6, 2
   \   00000064   0x0005             DC16 5
   \   00000066   0x06 0x08          DC8 6, 8
   \   00000068   0x0006             DC16 6
   \   0000006A   0x00 0x08          DC8 0, 8
   \   0000006C   0x0006             DC16 6
   \   0000006E   0x01 0x08          DC8 1, 8
   \   00000070   0x0006             DC16 6
   \   00000072   0x02 0x08          DC8 2, 8
   \   00000074   0x0008             DC16 8
   \   00000076   0x00 0x08          DC8 0, 8
   \   00000078   0x0008             DC16 8
   \   0000007A   0x01 0x08          DC8 1, 8
   \   0000007C   0x0008             DC16 8
   \   0000007E   0x02 0x08          DC8 2, 8
   \   00000080   0x0008             DC16 8
   \   00000082   0x03 0x08          DC8 3, 8
   \   00000084   0x0008             DC16 8
   \   00000086   0x04 0x08          DC8 4, 8
   \   00000088   0x0008             DC16 8
   \   0000008A   0x05 0x08          DC8 5, 8
   \   0000008C   0x0008             DC16 8
   \   0000008E   0x06 0x08          DC8 6, 8
   \   00000090   0x0008             DC16 8
   \   00000092   0x07 0x08          DC8 7, 8
   \   00000094   0x0019             DC16 25
   \   00000096   0x00 0x04          DC8 0, 4
   \   00000098   0x0019             DC16 25
   \   0000009A   0x01 0x01          DC8 1, 1
   \   0000009C   0x0019             DC16 25
   \   0000009E   0x02 0x04          DC8 2, 4
   \   000000A0   0x0019             DC16 25
   \   000000A2   0x03 0x01          DC8 3, 1
   \   000000A4   0x0019             DC16 25
   \   000000A6   0x04 0x01          DC8 4, 1
   \   000000A8   0x0019             DC16 25
   \   000000AA   0x05 0x04          DC8 5, 4
   \   000000AC   0x0019             DC16 25
   \   000000AE   0x06 0x01          DC8 6, 1
   \   000000B0   0x0019             DC16 25
   \   000000B2   0x07 0x04          DC8 7, 4
   \   000000B4   0x0019             DC16 25
   \   000000B6   0x08 0x01          DC8 8, 1
   \   000000B8   0x0300             DC16 768
   \   000000BA   0x07 0x08          DC8 7, 8
   \   000000BC   0x0300             DC16 768
   \   000000BE   0x08 0x08          DC8 8, 8
   \   000000C0   0x0300             DC16 768
   \   000000C2   0x09 0x08          DC8 9, 8
   \   000000C4   0x0300             DC16 768
   \   000000C6   0x0A 0x08          DC8 10, 8
   \   000000C8   0x0600             DC16 1536
   \   000000CA   0x00 0x02          DC8 0, 2
   \   000000CC   0x0600             DC16 1536
   \   000000CE   0x00 0x08          DC8 0, 8
   \   000000D0   0x0600             DC16 1536
   \   000000D2   0x01 0x02          DC8 1, 2
   \   000000D4   0x0704             DC16 1796
   \   000000D6   0x00 0x02          DC8 0, 2
   \   000000D8   0x0704             DC16 1796
   \   000000DA   0x00 0x08          DC8 0, 8
   \   000000DC   0x0704             DC16 1796
   \   000000DE   0x01 0x02          DC8 1, 2
   \   000000E0   0x0704             DC16 1796
   \   000000E2   0x01 0x08          DC8 1, 8
   \   000000E4   0x0704             DC16 1796
   \   000000E6   0x02 0x02          DC8 2, 2
   \   000000E8   0x0704             DC16 1796
   \   000000EA   0x02 0x08          DC8 2, 8
   \   000000EC   0x0704             DC16 1796
   \   000000EE   0x03 0x08          DC8 3, 8
     53          #endif
     54          

   \                                 In section .text, align 4, keep-with-next
     55          const EmberAfAttributeMetadata generatedAttributes[] = GENERATED_ATTRIBUTES;
   \                     generatedAttributes:
   \   00000000   0x0000             DC16 0
   \   00000002   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000008   0x00000001         DC32 1H
   \   0000000C   0x0001             DC16 1
   \   0000000E   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000014   0x0000000E         DC32 0EH
   \   00000018   0x0004             DC16 4
   \   0000001A   0x42 0x21          DC8 66, 33, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000020   0x........         DC32 generatedDefaults
   \   00000024   0x0005             DC16 5
   \   00000026   0x42 0x21          DC8 66, 33, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   0000002C   0x........         DC32 generatedDefaults + 21H
   \   00000030   0x0007             DC16 7
   \   00000032   0x30 0x01          DC8 48, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000038   0x00000000         DC32 0H
   \   0000003C   0x0000             DC16 0
   \   0000003E   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000044   0x00000000         DC32 0H
   \   00000048   0x0000             DC16 0
   \   0000004A   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000050   0x00000000         DC32 0H
   \   00000054   0x0000             DC16 0
   \   00000056   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000005C   0x00000000         DC32 0H
   \   00000060   0x0001             DC16 1
   \   00000062   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00000000         DC32 0H
   \   0000006C   0x0002             DC16 2
   \   0000006E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000074   0x00000000         DC32 0H
   \   00000078   0x0003             DC16 3
   \   0000007A   0x10 0x01          DC8 16, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000080   0x00000000         DC32 0H
   \   00000084   0x0004             DC16 4
   \   00000086   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000008C   0x00000000         DC32 0H
   \   00000090   0x0000             DC16 0
   \   00000092   0x10 0x01          DC8 16, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000098   0x00000000         DC32 0H
   \   0000009C   0x0000             DC16 0
   \   0000009E   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A4   0x000000FF         DC32 0FFH
   \   000000A8   0x0010             DC16 16
   \   000000AA   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   000000B0   0x00000000         DC32 0H
   \   000000B4   0x0000             DC16 0
   \   000000B6   0xF0 0x08          DC8 240, 8, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \   000000BC   0x........         DC32 generatedDefaults + 42H
   \   000000C0   0x0001             DC16 1
   \   000000C2   0x23 0x04          DC8 35, 4, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \   000000C8   0x........         DC32 generatedDefaults + 4AH
   \   000000CC   0x0006             DC16 6
   \   000000CE   0x30 0x01          DC8 48, 1, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \   000000D4   0x00000000         DC32 0H
   \   000000D8   0x0000             DC16 0
   \   000000DA   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000E0   0x00000000         DC32 0H
   \   000000E4   0x0001             DC16 1
   \   000000E6   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000EC   0x00000000         DC32 0H
   \   000000F0   0x0003             DC16 3
   \   000000F2   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000F8   0x0000616B         DC32 616BH
   \   000000FC   0x0004             DC16 4
   \   000000FE   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000104   0x0000607D         DC32 607DH
   \   00000108   0x0007             DC16 7
   \   0000010A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000110   0x000000FA         DC32 0FAH
   \   00000114   0x0001             DC16 1
   \   00000116   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000011C   0x00000000         DC32 0H
   \   00000120   0x0002             DC16 2
   \   00000122   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000128   0x00000000         DC32 0H
   \   0000012C   0x0003             DC16 3
   \   0000012E   0x41 0xFF          DC8 65, 255, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000134   0x00000000         DC32 0H
   \   00000138   0x0000             DC16 0
   \   0000013A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000140   0x0000FFFF         DC32 0FFFFH

   \                                 In section .text, align 4, keep-with-next
     56          const EmberAfCluster generatedClusters[]          = GENERATED_CLUSTERS;
   \                     generatedClusters:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 generatedAttributes
   \   00000008   0x0005 0x0000      DC16 5, 0
   \   0000000C   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x00000000         DC32 0H
   \   00000014   0x0003             DC16 3
   \   00000016   0x00 0x00          DC8 0, 0
   \   00000018   0x........         DC32 generatedAttributes + 3CH
   \   0000001C   0x0000 0x0000      DC16 0, 0
   \   00000020   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00000000         DC32 0H
   \   00000028   0x0003             DC16 3
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 generatedAttributes + 3CH
   \   00000030   0x0001 0x0002      DC16 1, 2
   \   00000034   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000038   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   0000003C   0x0004             DC16 4
   \   0000003E   0x00 0x00          DC8 0, 0
   \   00000040   0x........         DC32 generatedAttributes + 48H
   \   00000044   0x0001 0x0001      DC16 1, 1
   \   00000048   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \   0000004C   0x........         DC32 emberAfFuncArrayGroupsClusterServer
   \   00000050   0x0005             DC16 5
   \   00000052   0x00 0x00          DC8 0, 0
   \   00000054   0x........         DC32 generatedAttributes + 54H
   \   00000058   0x0005 0x0006      DC16 5, 6
   \   0000005C   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \   00000060   0x........         DC32 emberAfFuncArrayScenesClusterServer
   \   00000064   0x0006             DC16 6
   \   00000066   0x00 0x00          DC8 0, 0
   \   00000068   0x........         DC32 generatedAttributes + 90H
   \   0000006C   0x0001 0x0001      DC16 1, 1
   \   00000070   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000074   0x00000000         DC32 0H
   \   00000078   0x0008             DC16 8
   \   0000007A   0x00 0x00          DC8 0, 0
   \   0000007C   0x........         DC32 generatedAttributes + 9CH
   \   00000080   0x0002 0x0003      DC16 2, 3
   \   00000084   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \   00000088   0x........         DC32 emberAfFuncArrayLevelControlClusterServer
   \   0000008C   0x0300             DC16 768
   \   0000008E   0x00 0x00          DC8 0, 0
   \   00000090   0x........         DC32 generatedAttributes + 0D8H
   \   00000094   0x0005 0x0008      DC16 5, 8
   \   00000098   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   0000009C   0x00000000         DC32 0H
   \   000000A0   0x0000             DC16 0
   \   000000A2   0x00 0x00          DC8 0, 0
   \   000000A4   0x........         DC32 generatedAttributes
   \   000000A8   0x0005 0x0000      DC16 5, 0
   \   000000AC   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   000000B0   0x00000000         DC32 0H
   \   000000B4   0x0003             DC16 3
   \   000000B6   0x00 0x00          DC8 0, 0
   \   000000B8   0x........         DC32 generatedAttributes + 3CH
   \   000000BC   0x0000 0x0000      DC16 0, 0
   \   000000C0   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   000000C4   0x00000000         DC32 0H
   \   000000C8   0x0003             DC16 3
   \   000000CA   0x00 0x00          DC8 0, 0
   \   000000CC   0x........         DC32 generatedAttributes + 3CH
   \   000000D0   0x0001 0x0002      DC16 1, 2
   \   000000D4   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   000000D8   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   000000DC   0x0600             DC16 1536
   \   000000DE   0x00 0x00          DC8 0, 0
   \   000000E0   0x........         DC32 generatedAttributes + 114H
   \   000000E4   0x0003 0x0103      DC16 3, 259
   \   000000E8   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   000000EC   0x00000000         DC32 0H
   \   000000F0   0x0704             DC16 1796
   \   000000F2   0x00 0x00          DC8 0, 0
   \   000000F4   0x........         DC32 generatedAttributes + 138H
   \   000000F8   0x0001 0x0002      DC16 1, 2
   \   000000FC   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000100   0x........         DC32 emberAfFuncArrayTunnelingClusterServer
   \   00000104   0x0000             DC16 0
   \   00000106   0x00 0x00          DC8 0, 0
   \   00000108   0x........         DC32 generatedAttributes
   \   0000010C   0x0005 0x0000      DC16 5, 0
   \   00000110   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000114   0x00000000         DC32 0H
   \   00000118   0x0003             DC16 3
   \   0000011A   0x00 0x00          DC8 0, 0
   \   0000011C   0x........         DC32 generatedAttributes + 3CH
   \   00000120   0x0000 0x0000      DC16 0, 0
   \   00000124   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   00000128   0x00000000         DC32 0H
   \   0000012C   0x0003             DC16 3
   \   0000012E   0x00 0x00          DC8 0, 0
   \   00000130   0x........         DC32 generatedAttributes + 3CH
   \   00000134   0x0001 0x0002      DC16 1, 2
   \   00000138   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   0000013C   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   00000140   0x0019             DC16 25
   \   00000142   0x00 0x00          DC8 0, 0
   \   00000144   0x........         DC32 generatedAttributes + 0B4H
   \   00000148   0x0003 0x000D      DC16 3, 13
   \   0000014C   0x85 0x00          DC8 133, 0, 0, 0
   \              0x00 0x00    
   \   00000150   0x........         DC32 emberAfFuncArrayOtaBootloadClusterClient

   \                                 In section .text, align 4, keep-with-next
     57          const EmberAfEndpointType generatedEmberAfEndpointTypes[]   = GENERATED_ENDPOINT_TYPES;
   \                     generatedEmberAfEndpointTypes:
   \   00000000   0x........         DC32 generatedClusters
   \   00000004   0x08 0x00          DC8 8, 0
   \   00000006   0x0015             DC16 21
   \   00000008   0x........         DC32 generatedClusters + 0A0H
   \   0000000C   0x05 0x00          DC8 5, 0
   \   0000000E   0x0107             DC16 263
   \   00000010   0x........         DC32 generatedClusters + 104H
   \   00000014   0x04 0x00          DC8 4, 0
   \   00000016   0x000F             DC16 15

   \                                 In section .rodata, align 4, keep-with-next
     58          const EmAfNetwork emAfNetworks[] = EMBER_AF_GENERATED_NETWORKS;
   \                     emAfNetworks:
   \   00000000   0x00 0x01          DC8 0, 1, 1, 0
   \              0x01 0x00    
     59          

   \                                 In section .text, align 4, keep-with-next
     60          const EmberAfManufacturerCodeEntry clusterManufacturerCodes[] = GENERATED_CLUSTER_MANUFACTURER_CODES;
   \                     clusterManufacturerCodes:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2, keep-with-next
     61          const int16u clusterManufacturerCodeCount = GENERATED_CLUSTER_MANUFACTURER_CODE_COUNT;
   \                     clusterManufacturerCodeCount:
   \   00000000   0x0000             DC16 0

   \                                 In section .text, align 4, keep-with-next
     62          const EmberAfManufacturerCodeEntry attributeManufacturerCodes[] = GENERATED_ATTRIBUTE_MANUFACTURER_CODES;
   \                     attributeManufacturerCodes:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2, keep-with-next
     63          const int16u attributeManufacturerCodeCount = GENERATED_ATTRIBUTE_MANUFACTURER_CODE_COUNT;
   \                     attributeManufacturerCodeCount:
   \   00000000   0x0000             DC16 0
     64          
     65          //------------------------------------------------------------------------------
     66          // Forward declarations
     67          
     68          // Returns endpoint index within a given cluster
     69          static int8u findClusterEndpointIndex(int8u endpoint, EmberAfClusterId clusterId, int8u mask);
     70          
     71          //------------------------------------------------------------------------------
     72          
     73          // Initial configuration

   \                                 In section .text, align 2, keep-with-next
     74          void emberAfEndpointConfigure(void) {
     75            int8u ep;
     76          #ifdef FIXED_ENDPOINT_COUNT
     77            int8u fixedEndpoints[] = FIXED_ENDPOINT_ARRAY;
   \                     emberAfEndpointConfigure: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,?_0
   \   00000004   0x680A             LDR      R2,[R1, #0]
     78            int16u fixedProfileIds[] = FIXED_PROFILE_IDS;
   \   00000006   0x.... 0x....      ADR.W    R1,?_1
   \   0000000A   0xB088             SUB      SP,SP,#+32
   \   0000000C   0xA803             ADD      R0,SP,#+12
   \   0000000E   0x6002             STR      R2,[R0, #+0]
   \   00000010   0xA806             ADD      R0,SP,#+24
   \   00000012   0xC90C             LDM      R1!,{R2,R3}
   \   00000014   0xC00C             STM      R0!,{R2,R3}
     79            int16u fixedDeviceIds[] = FIXED_DEVICE_IDS;
   \   00000016   0x.... 0x....      ADR.W    R1,?_2
   \   0000001A   0xC90C             LDM      R1!,{R2,R3}
   \   0000001C   0xA804             ADD      R0,SP,#+16
     80            int8u fixedDeviceVersions[] = FIXED_DEVICE_VERSIONS;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xC00C             STM      R0!,{R2,R3}
   \   00000022   0xA802             ADD      R0,SP,#+8
   \   00000024   0x6001             STR      R1,[R0, #+0]
     81            int8u fixedEmberAfEndpointTypes[] = FIXED_ENDPOINT_TYPES;
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      ADR.W    R1,?_4
   \   0000002C   0x680A             LDR      R2,[R1, #0]
   \   0000002E   0x6002             STR      R2,[R0, #+0]
     82            int8u fixedNetworks[] = FIXED_NETWORKS;
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6001             STR      R1,[R0, #+0]
     83            emberEndpointCount = FIXED_ENDPOINT_COUNT;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable35
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
     84            for ( ep = 0; ep < FIXED_ENDPOINT_COUNT; ep++ ) {
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      ADR.W    R1,generatedEmberAfEndpointTypes
     85              emAfEndpoints[ep].endpoint      = fixedEndpoints[ep];
   \                     ??emberAfEndpointConfigure_0: (+1)
   \   00000044   0xAB03             ADD      R3,SP,#+12
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable35_1
   \   0000004A   0x5CC3             LDRB     R3,[R0, R3]
   \   0000004C   0xEB02 0x1200      ADD      R2,R2,R0, LSL #+4
   \   00000050   0x7013             STRB     R3,[R2, #+0]
     86              emAfEndpoints[ep].profileId     = fixedProfileIds[ep];
   \   00000052   0xAB06             ADD      R3,SP,#+24
   \   00000054   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   00000058   0x8053             STRH     R3,[R2, #+2]
     87              emAfEndpoints[ep].deviceId      = fixedDeviceIds[ep];
   \   0000005A   0xAB04             ADD      R3,SP,#+16
   \   0000005C   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   00000060   0x8093             STRH     R3,[R2, #+4]
     88              emAfEndpoints[ep].deviceVersion = fixedDeviceVersions[ep];
   \   00000062   0xAB02             ADD      R3,SP,#+8
   \   00000064   0x5CC3             LDRB     R3,[R0, R3]
   \   00000066   0x7193             STRB     R3,[R2, #+6]
     89              emAfEndpoints[ep].endpointType
     90                = (EmberAfEndpointType*)&(generatedEmberAfEndpointTypes[fixedEmberAfEndpointTypes[ep]]);
   \   00000068   0xAB01             ADD      R3,SP,#+4
   \   0000006A   0x5CC3             LDRB     R3,[R0, R3]
   \   0000006C   0xEB01 0x03C3      ADD      R3,R1,R3, LSL #+3
   \   00000070   0x6093             STR      R3,[R2, #+8]
     91              emAfEndpoints[ep].networkIndex  = fixedNetworks[ep];
   \   00000072   0xAB00             ADD      R3,SP,#+0
   \   00000074   0x5CC3             LDRB     R3,[R0, R3]
   \   00000076   0x7313             STRB     R3,[R2, #+12]
     92              emAfEndpoints[ep].bitmask = EMBER_AF_ENDPOINT_ENABLED;
     93            }
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x2301             MOVS     R3,#+1
   \   0000007C   0x2803             CMP      R0,#+3
   \   0000007E   0x7353             STRB     R3,[R2, #+13]
   \   00000080   0xDBE0             BLT.N    ??emberAfEndpointConfigure_0
     94          #else
     95            for ( ep = 0; ep < MAX_ENDPOINT_COUNT; ep++ ) {
     96              emAfEndpoints[ep].endpoint      = endpointNumber(ep);
     97              emAfEndpoints[ep].profileId     = endpointProfileId(ep);
     98              emAfEndpoints[ep].deviceId      = endpointDeviceId(ep);
     99              emAfEndpoints[ep].deviceVersion = endpointDeviceVersion(ep);
    100              emAfEndpoints[ep].endpointType  = endpointType(ep);
    101              emAfEndpoints[ep].networkIndex  = endpointNetworkIndex(ep);
    102              emAfEndpoints[ep].bitmask       = EMBER_AF_ENDPOINT_ENABLED;
    103              if ( emAfEndpoints[ep].endpoint != 0xFF ) {
    104                emberEndpointCount++;
    105              } else {
    106                break;
    107              }
    108            }
    109          #endif // FIXED_ENDPOINT_COUNT
    110          }
   \   00000082   0xB008             ADD      SP,SP,#+32
   \   00000084   0x4770             BX       LR               ;; return
    111          

   \                                 In section .text, align 2, keep-with-next
    112          int8u emberAfEndpointCount()
    113          {
    114            return emberEndpointCount;
   \                     emberAfEndpointCount: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable35
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          boolean emberAfEndpointIndexIsEnabled(int8u index)
    118          {
    119            return (emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED);
   \                     emberAfEndpointIndexIsEnabled: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000004   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000008   0x7B40             LDRB     R0,[R0, #+13]
   \   0000000A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000E   0x4770             BX       LR               ;; return
    120          }
    121          
    122          // some data types (like strings) are sent OTA in human readable order
    123          // (how they are read) instead of little endian as the data types are.

   \                                 In section .text, align 2, keep-with-next
    124          boolean emberAfIsThisDataTypeAStringType(EmberAfAttributeType dataType)
    125          {
    126            return (dataType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    127                    || dataType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE
    128                    || dataType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    129                    || dataType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsThisDataTypeAStringType: (+1)
   \   00000000   0x2841             CMP      R0,#+65
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2842             CMPNE    R0,#+66
   \   00000006   0xD003             BEQ.N    ??emberAfIsThisDataTypeAStringType_0
   \   00000008   0x2843             CMP      R0,#+67
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2844             CMPNE    R0,#+68
   \   0000000E   0xD101             BNE.N    ??emberAfIsThisDataTypeAStringType_1
   \                     ??emberAfIsThisDataTypeAStringType_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   \                     ??emberAfIsThisDataTypeAStringType_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          boolean emberAfIsStringAttributeType(EmberAfAttributeType attributeType)
    133          {
    134            return (attributeType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    135                    || attributeType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsStringAttributeType: (+1)
   \   00000000   0x2841             CMP      R0,#+65
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2842             CMPNE    R0,#+66
   \   00000006   0xD101             BNE.N    ??emberAfIsStringAttributeType_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??emberAfIsStringAttributeType_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          boolean emberAfIsLongStringAttributeType(EmberAfAttributeType attributeType)
    139          {
    140            return (attributeType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    141                    || attributeType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsLongStringAttributeType: (+1)
   \   00000000   0x2843             CMP      R0,#+67
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2844             CMPNE    R0,#+68
   \   00000006   0xD101             BNE.N    ??emberAfIsLongStringAttributeType_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??emberAfIsLongStringAttributeType_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    142          }
    143          
    144          // This function is used to call the per-cluster default response callback

   \                                 In section .text, align 2, keep-with-next
    145          void emberAfClusterDefaultResponseCallback(int8u endpoint,
    146                                                     EmberAfClusterId clusterId,
    147                                                     int8u commandId,
    148                                                     EmberAfStatus status,
    149                                                     int8u clientServerMask)
    150          {
   \                     emberAfClusterDefaultResponseCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
    151            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    152                                                         clusterId,
    153                                                         clientServerMask);
   \   00000004   0x9A06             LDR      R2,[SP, #+24]
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x.... 0x....      BL       emberAfFindCluster
    154            if (cluster != NULL) {
   \   0000000E   0xB160             CBZ.N    R0,??emberAfClusterDefaultResponseCallback_0
    155              EmberAfGenericClusterFunction f =
    156                emberAfFindClusterFunction(cluster,
    157                                           CLUSTER_MASK_DEFAULT_RESPONSE_FUNCTION);
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000016   0x0007             MOVS     R7,R0
    158              if (f != NULL) {
   \   00000018   0xD007             BEQ.N    ??emberAfClusterDefaultResponseCallback_0
    159                emberAfPushEndpointNetworkIndex(endpoint);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    160                ((EmberAfDefaultResponseFunction)f)(endpoint, commandId, status);
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x47B8             BLX      R7
    161                emberAfPopNetworkIndex();
   \   00000028   0x....             B.N      ?Subroutine0
    162              }
    163            }
    164          }
   \                     ??emberAfClusterDefaultResponseCallback_0: (+1)
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000004   0x.... 0x....      B.W      emberAfPopNetworkIndex
    165          
    166          // This function is used to call the per-cluster message sent callback

   \                                 In section .text, align 2, keep-with-next
    167          void emberAfClusterMessageSentCallback(EmberOutgoingMessageType type,
    168                                                 int16u indexOrDestination,
    169                                                 EmberApsFrame *apsFrame,
    170                                                 int16u msgLen,
    171                                                 int8u *message,
    172                                                 EmberStatus status)
    173          {
   \                     emberAfClusterMessageSentCallback: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0016             MOVS     R6,R2
    174            if (apsFrame != NULL && message != NULL && msgLen != 0) {
   \   00000008   0xBF1C             ITT      NE 
   \   0000000A   0x9D0A             LDRNE    R5,[SP, #+40]
   \   0000000C   0x2D00             CMPNE    R5,#+0
   \   0000000E   0x4604             MOV      R4,R0
   \   00000010   0x4688             MOV      R8,R1
   \   00000012   0x461F             MOV      R7,R3
   \   00000014   0xD01E             BEQ.N    ??emberAfClusterMessageSentCallback_0
   \   00000016   0xB1EF             CBZ.N    R7,??emberAfClusterMessageSentCallback_0
    175              EmberAfCluster *cluster = emberAfFindCluster(apsFrame->sourceEndpoint,
    176                                                           apsFrame->clusterId,
    177                                                           (((message[0]
    178                                                              & ZCL_FRAME_CONTROL_DIRECTION_MASK)
    179                                                             == ZCL_FRAME_CONTROL_SERVER_TO_CLIENT)
    180                                                            ? CLUSTER_MASK_SERVER
    181                                                            : CLUSTER_MASK_CLIENT));
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0x8871             LDRH     R1,[R6, #+2]
   \   0000001C   0x0700             LSLS     R0,R0,#+28
   \   0000001E   0x7930             LDRB     R0,[R6, #+4]
   \   00000020   0xBF4C             ITE      MI 
   \   00000022   0x2240             MOVMI    R2,#+64
   \   00000024   0x2280             MOVPL    R2,#+128
   \   00000026   0x.... 0x....      BL       emberAfFindCluster
    182              if (cluster != NULL) {
   \   0000002A   0xB198             CBZ.N    R0,??emberAfClusterMessageSentCallback_0
    183                EmberAfGenericClusterFunction f =
    184                  emberAfFindClusterFunction(cluster,
    185                                             CLUSTER_MASK_MESSAGE_SENT_FUNCTION);
   \   0000002C   0x2108             MOVS     R1,#+8
   \   0000002E   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000032   0x4681             MOV      R9,R0
    186                if (f != NULL) {
   \   00000034   0xB170             CBZ.N    R0,??emberAfClusterMessageSentCallback_0
    187                  emberAfPushEndpointNetworkIndex(apsFrame->sourceEndpoint);
   \   00000036   0x7930             LDRB     R0,[R6, #+4]
   \   00000038   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    188                  ((EmberAfMessageSentFunction)f)(type,
    189                                                  indexOrDestination,
    190                                                  apsFrame,
    191                                                  msgLen,
    192                                                  message,
    193                                                  status);
   \   0000003C   0x980B             LDR      R0,[SP, #+44]
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x9500             STR      R5,[SP, #+0]
   \   00000042   0x463B             MOV      R3,R7
   \   00000044   0x4632             MOV      R2,R6
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x47C8             BLX      R9
    194                  emberAfPopNetworkIndex();
   \   0000004C   0xE8BD 0x43F7      POP      {R0-R2,R4-R9,LR}
   \   00000050   0x.... 0x....      B.W      emberAfPopNetworkIndex
    195                }
    196              }
    197            }
    198          }
   \                     ??emberAfClusterMessageSentCallback_0: (+1)
   \   00000054   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    199          
    200          // This function is used to call the per-cluster attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    201          void emAfClusterAttributeChangedCallback(int8u endpoint,
    202                                                   EmberAfClusterId clusterId,
    203                                                   EmberAfAttributeId attributeId,
    204                                                   int8u clientServerMask,
    205                                                   int16u manufacturerCode)
    206          {
   \                     emAfClusterAttributeChangedCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4616             MOV      R6,R2
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x461A             MOV      R2,R3
    207            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    208                                                         clusterId,
    209                                                         clientServerMask);
   \   00000008   0x.... 0x....      BL       emberAfFindCluster
    210            if (cluster != NULL) {
   \   0000000C   0xB1D0             CBZ.N    R0,??emAfClusterAttributeChangedCallback_0
   \   0000000E   0x9C06             LDR      R4,[SP, #+24]
    211              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   00000010   0xB95C             CBNZ.N   R4,??emAfClusterAttributeChangedCallback_1
    212                EmberAfGenericClusterFunction f =
    213                  emberAfFindClusterFunction(cluster,
    214                                             CLUSTER_MASK_ATTRIBUTE_CHANGED_FUNCTION);
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000018   0x0004             MOVS     R4,R0
    215                if (f != NULL) {
   \   0000001A   0xD013             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    216                  emberAfPushEndpointNetworkIndex(endpoint);
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    217                  ((EmberAfClusterAttributeChangedCallback)f)(endpoint, attributeId);
   \   00000022   0x4631             MOV      R1,R6
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x47A0             BLX      R4
    218                  emberAfPopNetworkIndex();
   \   00000028   0xE00B             B.N      ??emAfClusterAttributeChangedCallback_2
    219                }
    220              } else {
    221                EmberAfGenericClusterFunction f =
    222                  emberAfFindClusterFunction(cluster,
    223                                             CLUSTER_MASK_MANUFACTURER_SPECIFIC_ATTRIBUTE_CHANGED_FUNCTION);
   \                     ??emAfClusterAttributeChangedCallback_1: (+1)
   \   0000002A   0x2110             MOVS     R1,#+16
   \   0000002C   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000030   0x0007             MOVS     R7,R0
    224                if (f != NULL) {
   \   00000032   0xD007             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    225                  emberAfPushEndpointNetworkIndex(endpoint);
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    226                  ((EmberAfManufacturerSpecificClusterAttributeChangedCallback)f)(endpoint,
    227                                                                                  attributeId,
    228                                                                                  manufacturerCode);
   \   0000003A   0x4622             MOV      R2,R4
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x47B8             BLX      R7
    229                  emberAfPopNetworkIndex();
    230                }
    231              }
    232            }
   \                     ??emAfClusterAttributeChangedCallback_2: (+1)
   \   00000042   0x....             B.N      ?Subroutine0
    233          }
   \                     ??emAfClusterAttributeChangedCallback_0: (+1)
   \   00000044   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    234          
    235          // This function is used to call the per-cluster pre-attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    236          EmberAfStatus emAfClusterPreAttributeChangedCallback(int8u endpoint,
    237                                                               EmberAfClusterId clusterId,
    238                                                               EmberAfAttributeId attributeId,
    239                                                               int8u clientServerMask,
    240                                                               int16u manufacturerCode,
    241                                                               EmberAfAttributeType attributeType,
    242                                                               int8u size,
    243                                                               int8u* value)
    244          {
   \                     emAfClusterPreAttributeChangedCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461A             MOV      R2,R3
    245            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    246                                                         clusterId,
    247                                                         clientServerMask);
   \   00000008   0x.... 0x....      BL       emberAfFindCluster
    248            if (cluster == NULL) {
   \   0000000C   0xB908             CBNZ.N   R0,??emAfClusterPreAttributeChangedCallback_0
    249              return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   0000000E   0x2086             MOVS     R0,#+134
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}
    250            } else {
    251              EmberAfStatus status = EMBER_ZCL_STATUS_SUCCESS;
    252              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \                     ??emAfClusterPreAttributeChangedCallback_0: (+1)
   \   00000012   0x9906             LDR      R1,[SP, #+24]
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0xB989             CBNZ.N   R1,??emAfClusterPreAttributeChangedCallback_1
    253                EmberAfGenericClusterFunction f =
    254                  emberAfFindClusterFunction(cluster,
    255                                             CLUSTER_MASK_PRE_ATTRIBUTE_CHANGED_FUNCTION);
   \   00000018   0x2120             MOVS     R1,#+32
   \   0000001A   0x.... 0x....      BL       emberAfFindClusterFunction
   \   0000001E   0x0007             MOVS     R7,R0
    256                if (f != NULL) {
   \   00000020   0xD00C             BEQ.N    ??emAfClusterPreAttributeChangedCallback_1
    257                  emberAfPushEndpointNetworkIndex(endpoint);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    258                  status = ((EmberAfClusterPreAttributeChangedCallback)f)(endpoint,
    259                                                                          attributeId,
    260                                                                          attributeType,
    261                                                                          size,
    262                                                                          value);
   \   00000028   0x9809             LDR      R0,[SP, #+36]
   \   0000002A   0x9B08             LDR      R3,[SP, #+32]
   \   0000002C   0x9A07             LDR      R2,[SP, #+28]
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x47B8             BLX      R7
   \   00000036   0x4606             MOV      R6,R0
    263                  emberAfPopNetworkIndex();
   \   00000038   0x.... 0x....      BL       emberAfPopNetworkIndex
    264                }
    265              }
    266              return status;
   \                     ??emAfClusterPreAttributeChangedCallback_1: (+1)
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    267            }
    268          }
    269          

   \                                 In section .text, align 2, keep-with-next
    270          static void initializeEndpoint(EmberAfDefinedEndpoint* definedEndpoint)
    271          {
   \                     initializeEndpoint: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    272            int8u clusterIndex;
    273            EmberAfEndpointType* epType = definedEndpoint->endpointType;
   \   00000004   0x68A5             LDR      R5,[R4, #+8]
    274            emberAfPushEndpointNetworkIndex(definedEndpoint->endpoint);
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    275            for ( clusterIndex = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE010             B.N      ??initializeEndpoint_0
    276                  clusterIndex < epType->clusterCount;
    277                  clusterIndex ++ ) {
    278              EmberAfCluster *cluster = &(epType->cluster[clusterIndex]);
   \                     ??initializeEndpoint_1: (+1)
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x2114             MOVS     R1,#+20
   \   00000014   0xFB01 0x0706      MLA      R7,R1,R6,R0
    279              EmberAfGenericClusterFunction f;
    280              emberAfClusterInitCallback(definedEndpoint->endpoint, cluster->clusterId);
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x8839             LDRH     R1,[R7, #+0]
   \   0000001C   0x.... 0x....      BL       emberAfClusterInitCallback
    281              f = emberAfFindClusterFunction(cluster, CLUSTER_MASK_INIT_FUNCTION);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000028   0x0001             MOVS     R1,R0
    282              if ( f != NULL ) {
   \   0000002A   0xBF1C             ITT      NE 
    283                ((EmberAfInitFunction)f)(definedEndpoint->endpoint);
   \   0000002C   0x7820             LDRBNE   R0,[R4, #+0]
   \   0000002E   0x4788             BLXNE    R1
    284              }
    285            }
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   \                     ??initializeEndpoint_0: (+1)
   \   00000032   0x7928             LDRB     R0,[R5, #+4]
   \   00000034   0xB2F6             UXTB     R6,R6
   \   00000036   0x4286             CMP      R6,R0
   \   00000038   0xD3EA             BCC.N    ??initializeEndpoint_1
    286            emberAfPopNetworkIndex();
   \   0000003A                      REQUIRE ?Subroutine0
   \   0000003A                      ;; // Fall through to label ?Subroutine0
    287          }
    288          
    289          // Calls the init functions.

   \                                 In section .text, align 2, keep-with-next
    290          void emAfCallInits(void)
    291          {
   \                     emAfCallInits: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    292            int8u index;
    293            for ( index = 0; index < emberAfEndpointCount(); index++ ) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable35_1
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable35
   \   0000000C   0xE008             B.N      ??emAfCallInits_0
    294              if (emberAfEndpointIndexIsEnabled(index)) {
   \                     ??emAfCallInits_1: (+1)
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   00000014   0xB118             CBZ.N    R0,??emAfCallInits_2
    295                initializeEndpoint(&(emAfEndpoints[index]));
   \   00000016   0xEB05 0x1004      ADD      R0,R5,R4, LSL #+4
   \   0000001A   0x.... 0x....      BL       initializeEndpoint
    296              }
    297            }
   \                     ??emAfCallInits_2: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??emAfCallInits_0: (+1)
   \   00000020   0x7830             LDRB     R0,[R6, #+0]
   \   00000022   0xB2E4             UXTB     R4,R4
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD3F2             BCC.N    ??emAfCallInits_1
    298          }
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    299          
    300          // Returns the pointer to metadata, or null if it is not found

   \                                 In section .text, align 2, keep-with-next
    301          EmberAfAttributeMetadata* emberAfLocateAttributeMetadata(int8u endpoint,
    302                                                                   EmberAfClusterId clusterId,
    303                                                                   EmberAfAttributeId attributeId,
    304                                                                   int8u mask,
    305                                                                   int16u manufacturerCode)
    306          {
   \                     emberAfLocateAttributeMetadata: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    307            EmberAfAttributeMetadata *metadata = NULL;
   \   00000004   0x2400             MOVS     R4,#+0
    308            EmberAfAttributeSearchRecord record;
    309            record.endpoint = endpoint;
   \   00000006   0xF88D 0x0008      STRB     R0,[SP, #+8]
    310            record.clusterId = clusterId;
   \   0000000A   0xF8AD 0x100A      STRH     R1,[SP, #+10]
    311            record.clusterMask = mask;
   \   0000000E   0xF88D 0x300C      STRB     R3,[SP, #+12]
    312            record.attributeId = attributeId;
   \   00000012   0xF8AD 0x200E      STRH     R2,[SP, #+14]
   \   00000016   0x9401             STR      R4,[SP, #+4]
    313            record.manufacturerCode = manufacturerCode;
    314            emAfReadOrWriteAttribute(&record,
    315                                     &metadata,
    316                                     NULL,   // buffer
    317                                     0,      // buffer size
    318                                     FALSE); // write?
   \   00000018   0x9400             STR      R4,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x9808             LDR      R0,[SP, #+32]
   \   0000001E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \   00000022   0x4622             MOV      R2,R4
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       emAfReadOrWriteAttribute
    319            return metadata;
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0xB006             ADD      SP,SP,#+24
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    320          }
    321          
    322          static int8u* singletonAttributeLocation(EmberAfAttributeMetadata *am)
    323          {
    324            EmberAfAttributeMetadata *m = (EmberAfAttributeMetadata *)&(generatedAttributes[0]);
    325            int16u index = 0;
    326            while ( m < am ) {
    327              if ( m->mask & ATTRIBUTE_MASK_SINGLETON ) {
    328                index += m->size;
    329              }
    330              m++;
    331            }
    332            return (int8u *)(singletonAttributeData + index);
    333          }
    334          
    335          
    336          // This function does mem copy, but smartly, which means that if the type is a
    337          // string, it will copy as much as it can.
    338          // If src == NULL, then this method will set memory to zeroes
    339          static EmberAfStatus typeSensitiveMemCopy(int8u* dest,
    340                                                    int8u* src,
    341                                                    EmberAfAttributeMetadata * am,
    342                                                    boolean write,
    343                                                    int16u readLength)
    344          {
    345            EmberAfAttributeType attributeType = am->attributeType;
    346            int16u size = (readLength == 0) ? am->size : readLength;
    347          
    348            if (emberAfIsStringAttributeType(attributeType)) {
    349              emberAfCopyString(dest, src, size - 1);
    350            } else if (emberAfIsLongStringAttributeType(attributeType)) {
    351              emberAfCopyLongString(dest, src, size - 2);
    352            } else {
    353              if (!write && readLength != 0 && readLength < am->size) {
    354                  return EMBER_ZCL_STATUS_INSUFFICIENT_SPACE;
    355              }
    356              if ( src == NULL ) {
    357                MEMSET(dest, 0, size);
    358              } else {
    359                MEMCOPY(dest, src, size);
    360              }
    361            }
    362            return EMBER_ZCL_STATUS_SUCCESS;
    363          }
    364          
    365          // Returns the manufacturer code or ::EMBER_AF_NULL_MANUFACTURER_CODE if none
    366          // could be found.

   \                                 In section .text, align 2, keep-with-next
    367          static int16u getManufacturerCode(EmberAfManufacturerCodeEntry *codes,
    368                                            int16u codeTableSize,
    369                                            int16u tableIndex)
    370          {
   \                     getManufacturerCode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    371            int16u i;
    372            for (i = 0; i < codeTableSize; i++, codes++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE001             B.N      ??getManufacturerCode_0
   \                     ??getManufacturerCode_1: (+1)
   \   00000006   0x1C5B             ADDS     R3,R3,#+1
   \   00000008   0x1D00             ADDS     R0,R0,#+4
   \                     ??getManufacturerCode_0: (+1)
   \   0000000A   0xB29B             UXTH     R3,R3
   \   0000000C   0x428B             CMP      R3,R1
   \   0000000E   0xD204             BCS.N    ??getManufacturerCode_2
    373              if (codes->index == tableIndex) {
   \   00000010   0x8804             LDRH     R4,[R0, #+0]
   \   00000012   0x4294             CMP      R4,R2
   \   00000014   0xD1F7             BNE.N    ??getManufacturerCode_1
    374                return codes->manufacturerCode;
   \   00000016   0x8840             LDRH     R0,[R0, #+2]
   \   00000018   0xBD10             POP      {R4,PC}
    375              }
    376            }
    377            return EMBER_AF_NULL_MANUFACTURER_CODE;
   \                     ??getManufacturerCode_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    378          }
    379          

   \                                 In section .text, align 2, keep-with-next
    380          int16u emAfGetManufacturerCodeForAttribute(EmberAfCluster *cluster,
    381                                                     EmberAfAttributeMetadata *attMetaData)
    382          {
    383            return (emberAfClusterIsManufacturerSpecific(cluster)
    384                    ? emAfGetManufacturerCodeForCluster(cluster)
    385                    : getManufacturerCode((EmberAfManufacturerCodeEntry *)attributeManufacturerCodes,
    386                                          attributeManufacturerCodeCount,
    387                                          (attMetaData - generatedAttributes)));
   \                     emAfGetManufacturerCodeForAttribute: (+1)
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF5B2 0x4F7C      CMP      R2,#+64512
   \   00000006   0xBFA8             IT       GE 
   \   00000008   0x.... 0x....      BGE.W    emAfGetManufacturerCodeForCluster
   \   0000000C   0x.... 0x....      ADR.W    R0,generatedAttributes
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000018   0xB292             UXTH     R2,R2
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x.... 0x....      ADR.W    R0,attributeManufacturerCodes
   \   00000020   0x....             B.N      getManufacturerCode
    388          }
    389          

   \                                 In section .text, align 2, keep-with-next
    390          int16u emAfGetManufacturerCodeForCluster(EmberAfCluster *cluster)
    391          {
    392            return getManufacturerCode((EmberAfManufacturerCodeEntry *)clusterManufacturerCodes,
    393                                       clusterManufacturerCodeCount,
    394                                       (cluster - generatedClusters));
   \                     emAfGetManufacturerCodeForCluster: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,generatedClusters
   \   00000004   0x1A40             SUBS     R0,R0,R1
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000000C   0xB292             UXTH     R2,R2
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      ADR.W    R0,clusterManufacturerCodes
   \   00000014   0x....             B.N      getManufacturerCode
    395          }
    396          
    397          /**
    398           * @brief Matches a cluster based on cluster id, direction and manufacturer code.
    399           *   This function assumes that the passed cluster's endpoint already
    400           *   matches the endpoint of the EmberAfAttributeSearchRecord.
    401           *
    402           * Cluster's match if:
    403           *   1. Cluster ids match AND
    404           *   2. Cluster directions match as defined by cluster->mask
    405           *        and attRecord->clusterMask AND
    406           *   3. If the clusters are mf specific, their mf codes match.
    407           */

   \                                 In section .text, align 2, keep-with-next
    408          boolean emAfMatchCluster(EmberAfCluster *cluster,
    409                                   EmberAfAttributeSearchRecord *attRecord)
    410          {
   \                     emAfMatchCluster: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    411            return (cluster->clusterId == attRecord->clusterId
    412                    && cluster->mask & attRecord->clusterMask
    413                    && (!emberAfClusterIsManufacturerSpecific(cluster)
    414                        || (emAfGetManufacturerCodeForCluster(cluster)
    415                            == attRecord->manufacturerCode)));
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0x8862             LDRH     R2,[R4, #+2]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD10D             BNE.N    ??emAfMatchCluster_0
   \   0000000C   0x7B02             LDRB     R2,[R0, #+12]
   \   0000000E   0x7923             LDRB     R3,[R4, #+4]
   \   00000010   0x421A             TST      R2,R3
   \   00000012   0xD009             BEQ.N    ??emAfMatchCluster_0
   \   00000014   0xF5B1 0x4F7C      CMP      R1,#+64512
   \   00000018   0xDB04             BLT.N    ??emAfMatchCluster_1
   \   0000001A   0x.... 0x....      BL       emAfGetManufacturerCodeForCluster
   \   0000001E   0x8921             LDRH     R1,[R4, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??emAfMatchCluster_0
   \                     ??emAfMatchCluster_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchCluster_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    416          }
    417          
    418          /**
    419           * @brief Matches an attribute based on attribute id and manufacturer code.
    420           *   This function assumes that the passed cluster already matches the
    421           *   clusterId, direction and mf specificity of the passed
    422           *   EmberAfAttributeSearchRecord.
    423           *
    424           * Note: If both the attribute and cluster are manufacturer specific,
    425           *   the cluster's mf code gets precedence.
    426           *
    427           * Attributes match if:
    428           *   1. Att ids match AND
    429           *      a. cluster IS mf specific OR
    430           *      b. both stored and saught attributes are NOT mf specific OR
    431           *      c. stored att IS mf specific AND mfg codes match.
    432           */

   \                                 In section .text, align 2, keep-with-next
    433          boolean emAfMatchAttribute(EmberAfCluster *cluster,
    434                                     EmberAfAttributeMetadata *am,
    435                                     EmberAfAttributeSearchRecord *attRecord)
    436          {
   \                     emAfMatchAttribute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    437            return (am->attributeId == attRecord->attributeId
    438                    && (emberAfClusterIsManufacturerSpecific(cluster)
    439                        || (emAfGetManufacturerCodeForAttribute(cluster, am)
    440                            == attRecord->manufacturerCode)));
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
   \   00000006   0x88E3             LDRH     R3,[R4, #+6]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD10A             BNE.N    ??emAfMatchAttribute_0
   \   0000000C   0x8802             LDRH     R2,[R0, #+0]
   \   0000000E   0xF5B2 0x4F7C      CMP      R2,#+64512
   \   00000012   0xDA04             BGE.N    ??emAfMatchAttribute_1
   \   00000014   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   00000018   0x8921             LDRH     R1,[R4, #+8]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??emAfMatchAttribute_0
   \                     ??emAfMatchAttribute_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchAttribute_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    441          }
    442          
    443          // The callbacks to read and write externals have the same signature, so it is
    444          // easy to use function pointers to call the right one.  This typedef covers
    445          // both and makes the code a bit easier to read.
    446          typedef EmberAfStatus (*ExternalReadWriteCallback)(int8u, EmberAfClusterId, EmberAfAttributeMetadata *, int16u, int8u *);
    447          
    448          // When reading non-string attributes, this function returns an error when destination
    449          // buffer isn't large enough to accommodate the attribute type.  For strings, the
    450          // function will copy at most readLength bytes.  This means the resulting string
    451          // may be truncated.  The length byte(s) in the resulting string will reflect
    452          // any truncation.  If readLength is zero, we are working with backwards-
    453          // compatibility wrapper functions and we just cross our fingers and hope for
    454          // the best.
    455          //
    456          // When writing attributes, readLength is ignored.  For non-string attributes,
    457          // this function assumes the source buffer is the same size as the attribute
    458          // type.  For strings, the function will copy as many bytes as will fit in the
    459          // attribute.  This means the resulting string may be truncated.  The length
    460          // byte(s) in the resulting string will reflect any truncated.

   \                                 In section .text, align 2, keep-with-next
    461          EmberAfStatus emAfReadOrWriteAttribute(EmberAfAttributeSearchRecord *attRecord,
    462                                                 EmberAfAttributeMetadata **metadata,
    463                                                 int8u *buffer,
    464                                                 int16u readLength,
    465                                                 boolean write)
    466          {
   \                     emAfReadOrWriteAttribute: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
    467            int8u i;
    468            int16u attributeOffsetIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x4604             MOV      R4,R0
    469          
    470            for (i = 0; i < emberAfEndpointCount(); i++) {
   \   0000000A   0x46AA             MOV      R10,R5
   \   0000000C   0x.... 0x....      LDR.W    R11,??DataTable35
   \   00000010   0xE004             B.N      ??emAfReadOrWriteAttribute_0
    471              if (emAfEndpoints[i].endpoint == attRecord->endpoint) {
    472                EmberAfEndpointType *endpointType = emAfEndpoints[i].endpointType;
    473                int8u clusterIndex;
    474                if (!emberAfEndpointIndexIsEnabled(i)) {
    475                  continue;
    476                }
    477                for (clusterIndex = 0;
    478                     clusterIndex < endpointType->clusterCount;
    479                     clusterIndex++) {
    480                  EmberAfCluster *cluster = &(endpointType->cluster[clusterIndex]);
    481                  if (emAfMatchCluster(cluster, attRecord)) { // Got the cluster
    482                    int16u attrIndex;
    483                    for (attrIndex = 0;
    484                         attrIndex < cluster->attributeCount;
    485                         attrIndex++) {
    486                      EmberAfAttributeMetadata *am = &(cluster->attributes[attrIndex]);
    487                      if (emAfMatchAttribute(cluster,
    488                                             am,
    489                                             attRecord)) { // Got the attribute
    490          
    491                        // If passed metadata location is not null, populate
    492                        if (metadata != NULL) {
    493                          *metadata = am;
    494                        }
    495          
    496                        {
    497                          int8u *attributeLocation = (am->mask & ATTRIBUTE_MASK_SINGLETON
    498                                                      ? singletonAttributeLocation(am)
    499                                                      : attributeData + attributeOffsetIndex);
    500                          int8u *src, *dst;
    501                          ExternalReadWriteCallback callback;
    502                          if (write) {
    503                            src = buffer;
    504                            dst = attributeLocation;
    505                            callback = &emberAfExternalAttributeWriteCallback;
    506                          } else {
    507                            if (buffer == NULL) {
    508                              return EMBER_ZCL_STATUS_SUCCESS;
    509                            }
    510          
    511                            src = attributeLocation;
    512                            dst = buffer;
    513                            callback = &emberAfExternalAttributeReadCallback;
    514                          }
    515          
    516                          return (am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE
    517                                  ? (*callback)(attRecord->endpoint,
    518                                                attRecord->clusterId,
    519                                                am,
    520                                                emAfGetManufacturerCodeForAttribute(cluster, am),
    521                                                buffer)
    522                                  : typeSensitiveMemCopy(dst,
    523                                                         src,
    524                                                         am,
    525                                                         write,
    526                                                         readLength));
    527                        }
    528                      } else { // Not the attribute we are looking for
    529                        // Increase the index if attribute is not externally stored
    530                        if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)
    531                             && !(am->mask & ATTRIBUTE_MASK_SINGLETON) ) {
    532                          attributeOffsetIndex += emberAfAttributeSize(am);
    533                        }
    534                      }
    535                    }
    536                  } else { // Not the cluster we are looking for
    537                    attributeOffsetIndex += cluster->clusterSize;
    538                  }
    539                }
    540              } else { // Not the endpoint we are looking for
    541                attributeOffsetIndex += emAfEndpoints[i].endpointType->endpointSize;
   \                     ??emAfReadOrWriteAttribute_1: (+1)
   \   00000012   0x88C0             LDRH     R0,[R0, #+6]
   \   00000014   0x1945             ADDS     R5,R0,R5
   \   00000016   0xB2AD             UXTH     R5,R5
    542              }
   \                     ??emAfReadOrWriteAttribute_2: (+1)
   \   00000018   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??emAfReadOrWriteAttribute_0: (+1)
   \   0000001C   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   00000020   0xFA5F 0xFA8A      UXTB     R10,R10
   \   00000024   0x4582             CMP      R10,R0
   \   00000026   0xF080 0x80B0      BCS.W    ??emAfReadOrWriteAttribute_3
   \   0000002A   0xEA4F 0x110A      LSL      R1,R10,#+4
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable35_1
   \   00000036   0x1808             ADDS     R0,R1,R0
   \   00000038   0x5C89             LDRB     R1,[R1, R2]
   \   0000003A   0x7822             LDRB     R2,[R4, #+0]
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xD1E7             BNE.N    ??emAfReadOrWriteAttribute_1
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD0E4             BEQ.N    ??emAfReadOrWriteAttribute_2
   \   0000004E   0x2700             MOVS     R7,#+0
   \   00000050   0xE004             B.N      ??emAfReadOrWriteAttribute_4
   \                     ??emAfReadOrWriteAttribute_5: (+1)
   \   00000052   0xF8B8 0x000A      LDRH     R0,[R8, #+10]
   \   00000056   0x1945             ADDS     R5,R0,R5
   \   00000058   0xB2AD             UXTH     R5,R5
   \                     ??emAfReadOrWriteAttribute_6: (+1)
   \   0000005A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emAfReadOrWriteAttribute_4: (+1)
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x7900             LDRB     R0,[R0, #+4]
   \   00000060   0xB2FF             UXTB     R7,R7
   \   00000062   0x4287             CMP      R7,R0
   \   00000064   0xD2D8             BCS.N    ??emAfReadOrWriteAttribute_2
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x2114             MOVS     R1,#+20
   \   0000006C   0xFB01 0x0807      MLA      R8,R1,R7,R0
   \   00000070   0x4621             MOV      R1,R4
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x.... 0x....      BL       emAfMatchCluster
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD0EA             BEQ.N    ??emAfReadOrWriteAttribute_5
   \   0000007C   0xF04F 0x0900      MOV      R9,#+0
   \   00000080   0xE008             B.N      ??emAfReadOrWriteAttribute_7
   \                     ??emAfReadOrWriteAttribute_8: (+1)
   \   00000082   0x7930             LDRB     R0,[R6, #+4]
   \   00000084   0x2130             MOVS     R1,#+48
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD102             BNE.N    ??emAfReadOrWriteAttribute_9
   \   0000008A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000008C   0x1945             ADDS     R5,R0,R5
   \   0000008E   0xB2AD             UXTH     R5,R5
   \                     ??emAfReadOrWriteAttribute_9: (+1)
   \   00000090   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??emAfReadOrWriteAttribute_7: (+1)
   \   00000094   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000098   0xD2DF             BCS.N    ??emAfReadOrWriteAttribute_6
   \   0000009A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000009E   0x210C             MOVS     R1,#+12
   \   000000A0   0xFB01 0x0609      MLA      R6,R1,R9,R0
   \   000000A4   0x4622             MOV      R2,R4
   \   000000A6   0x4631             MOV      R1,R6
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0x.... 0x....      BL       emAfMatchAttribute
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0E7             BEQ.N    ??emAfReadOrWriteAttribute_8
   \   000000B2   0x9802             LDR      R0,[SP, #+8]
   \   000000B4   0xB100             CBZ.N    R0,??emAfReadOrWriteAttribute_10
   \   000000B6   0x6006             STR      R6,[R0, #+0]
   \                     ??emAfReadOrWriteAttribute_10: (+1)
   \   000000B8   0x7930             LDRB     R0,[R6, #+4]
   \   000000BA   0x0681             LSLS     R1,R0,#+26
   \   000000BC   0xD511             BPL.N    ??emAfReadOrWriteAttribute_11
   \   000000BE   0x.... 0x....      ADR.W    R1,generatedAttributes
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0xE006             B.N      ??emAfReadOrWriteAttribute_12
   \                     ??emAfReadOrWriteAttribute_13: (+1)
   \   000000C6   0x790B             LDRB     R3,[R1, #+4]
   \   000000C8   0x069B             LSLS     R3,R3,#+26
   \   000000CA   0xD502             BPL.N    ??emAfReadOrWriteAttribute_14
   \   000000CC   0x78CB             LDRB     R3,[R1, #+3]
   \   000000CE   0x189A             ADDS     R2,R3,R2
   \   000000D0   0xB292             UXTH     R2,R2
   \                     ??emAfReadOrWriteAttribute_14: (+1)
   \   000000D2   0x310C             ADDS     R1,R1,#+12
   \                     ??emAfReadOrWriteAttribute_12: (+1)
   \   000000D4   0x42B1             CMP      R1,R6
   \   000000D6   0xD3F6             BCC.N    ??emAfReadOrWriteAttribute_13
   \   000000D8   0xEB02 0x010B      ADD      R1,R2,R11
   \   000000DC   0xF501 0x7A98      ADD      R10,R1,#+304
   \   000000E0   0xE003             B.N      ??emAfReadOrWriteAttribute_15
   \                     ??emAfReadOrWriteAttribute_11: (+1)
   \   000000E2   0xEB05 0x010B      ADD      R1,R5,R11
   \   000000E6   0xF101 0x0A04      ADD      R10,R1,#+4
   \                     ??emAfReadOrWriteAttribute_15: (+1)
   \   000000EA   0x9D0E             LDR      R5,[SP, #+56]
   \   000000EC   0xB11D             CBZ.N    R5,??emAfReadOrWriteAttribute_16
   \   000000EE   0x9F03             LDR      R7,[SP, #+12]
   \   000000F0   0x.... 0x....      LDR.W    R9,??DataTable35_2
   \   000000F4   0xE006             B.N      ??emAfReadOrWriteAttribute_17
   \                     ??emAfReadOrWriteAttribute_16: (+1)
   \   000000F6   0x9903             LDR      R1,[SP, #+12]
   \   000000F8   0x2900             CMP      R1,#+0
   \   000000FA   0xD044             BEQ.N    ??emAfReadOrWriteAttribute_18
   \   000000FC   0x4657             MOV      R7,R10
   \   000000FE   0x468A             MOV      R10,R1
   \   00000100   0x.... 0x....      LDR.W    R9,??DataTable35_3
   \                     ??emAfReadOrWriteAttribute_17: (+1)
   \   00000104   0x06C0             LSLS     R0,R0,#+27
   \   00000106   0xD50B             BPL.N    ??emAfReadOrWriteAttribute_19
   \   00000108   0x4631             MOV      R1,R6
   \   0000010A   0x4640             MOV      R0,R8
   \   0000010C   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   00000110   0x4603             MOV      R3,R0
   \   00000112   0x9803             LDR      R0,[SP, #+12]
   \   00000114   0x9000             STR      R0,[SP, #+0]
   \   00000116   0x4632             MOV      R2,R6
   \   00000118   0x8861             LDRH     R1,[R4, #+2]
   \   0000011A   0x7820             LDRB     R0,[R4, #+0]
   \   0000011C   0x47C8             BLX      R9
   \   0000011E   0xE035             B.N      ??emAfReadOrWriteAttribute_20
   \                     ??emAfReadOrWriteAttribute_19: (+1)
   \   00000120   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   00000124   0xF896 0x8002      LDRB     R8,[R6, #+2]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xBF0C             ITE      EQ 
   \   0000012C   0x78F4             LDRBEQ   R4,[R6, #+3]
   \   0000012E   0x4604             MOVNE    R4,R0
   \   00000130   0x4640             MOV      R0,R8
   \   00000132   0x.... 0x....      BL       emberAfIsStringAttributeType
   \   00000136   0xB130             CBZ.N    R0,??emAfReadOrWriteAttribute_21
   \   00000138   0x1E62             SUBS     R2,R4,#+1
   \   0000013A   0xB2D2             UXTB     R2,R2
   \   0000013C   0x4639             MOV      R1,R7
   \   0000013E   0x4650             MOV      R0,R10
   \   00000140   0x.... 0x....      BL       emberAfCopyString
   \   00000144   0xE01F             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_21: (+1)
   \   00000146   0x4640             MOV      R0,R8
   \   00000148   0x.... 0x....      BL       emberAfIsLongStringAttributeType
   \   0000014C   0xB130             CBZ.N    R0,??emAfReadOrWriteAttribute_22
   \   0000014E   0x1EA2             SUBS     R2,R4,#+2
   \   00000150   0xB292             UXTH     R2,R2
   \   00000152   0x4639             MOV      R1,R7
   \   00000154   0x4650             MOV      R0,R10
   \   00000156   0x.... 0x....      BL       emberAfCopyLongString
   \   0000015A   0xE014             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_22: (+1)
   \   0000015C   0xB93D             CBNZ.N   R5,??emAfReadOrWriteAttribute_23
   \   0000015E   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   00000162   0xB120             CBZ.N    R0,??emAfReadOrWriteAttribute_23
   \   00000164   0x78F1             LDRB     R1,[R6, #+3]
   \   00000166   0x4288             CMP      R0,R1
   \   00000168   0xBF38             IT       CC 
   \   0000016A   0x2089             MOVCC    R0,#+137
   \   0000016C   0xD30E             BCC.N    ??emAfReadOrWriteAttribute_20
   \                     ??emAfReadOrWriteAttribute_23: (+1)
   \   0000016E   0x2F00             CMP      R7,#+0
   \   00000170   0x4622             MOV      R2,R4
   \   00000172   0xD104             BNE.N    ??emAfReadOrWriteAttribute_24
   \   00000174   0x2100             MOVS     R1,#+0
   \   00000176   0x4650             MOV      R0,R10
   \   00000178   0x.... 0x....      BL       halCommonMemSet
   \   0000017C   0xE003             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_24: (+1)
   \   0000017E   0x4639             MOV      R1,R7
   \   00000180   0x4650             MOV      R0,R10
   \   00000182   0x.... 0x....      BL       halCommonMemCopy
   \                     ??emAfReadOrWriteAttribute_18: (+1)
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0xE000             B.N      ??emAfReadOrWriteAttribute_20
    543            }
    544            return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // Sorry, attribute was not found.
   \                     ??emAfReadOrWriteAttribute_3: (+1)
   \   0000018A   0x2086             MOVS     R0,#+134
   \                     ??emAfReadOrWriteAttribute_20: (+1)
   \   0000018C   0xB005             ADD      SP,SP,#+20
   \   0000018E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    545          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   00000004   0xFA1F 0xF989      UXTH     R9,R9
   \   00000008   0x4581             CMP      R9,R0
   \   0000000A   0x4770             BX       LR
    546          
    547          // mask = 0 -> find either client or server
    548          // mask = CLUSTER_MASK_CLIENT -> find client
    549          // mask = CLUSTER_MASK_SERVER -> find server

   \                                 In section .text, align 2, keep-with-next
    550          static EmberAfCluster *emberAfFindClusterInType(EmberAfEndpointType *endpointType,
    551                                                          EmberAfClusterId clusterId,
    552                                                          int8u mask)
    553          {
   \                     emberAfFindClusterInType: (+1)
   \   00000000   0xB550             PUSH     {R4,R6,LR}
   \   00000002   0x4603             MOV      R3,R0
    554            int8u i;
    555            for (i = 0; i < endpointType->clusterCount; i++) {
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE003             B.N      ??emberAfFindClusterInType_0
    556              EmberAfCluster *cluster = &(endpointType->cluster[i]);
    557              if (cluster->clusterId == clusterId
    558                  && (mask == 0
    559                      || (mask == CLUSTER_MASK_CLIENT && emberAfClusterIsClient(cluster))
    560                      || (mask == CLUSTER_MASK_SERVER && emberAfClusterIsServer(cluster)))) {
   \                     ??emberAfFindClusterInType_1: (+1)
   \   00000008   0x7B06             LDRB     R6,[R0, #+12]
   \   0000000A   0x0636             LSLS     R6,R6,#+24
   \   0000000C   0xD415             BMI.N    ??emberAfFindClusterInType_2
   \                     ??emberAfFindClusterInType_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??emberAfFindClusterInType_0: (+1)
   \   00000010   0x7918             LDRB     R0,[R3, #+4]
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD20F             BCS.N    ??emberAfFindClusterInType_4
   \   00000018   0x6818             LDR      R0,[R3, #+0]
   \   0000001A   0x2614             MOVS     R6,#+20
   \   0000001C   0xFB06 0x0004      MLA      R0,R6,R4,R0
   \   00000020   0x8806             LDRH     R6,[R0, #+0]
   \   00000022   0x428E             CMP      R6,R1
   \   00000024   0xD1F3             BNE.N    ??emberAfFindClusterInType_3
   \   00000026   0xB142             CBZ.N    R2,??emberAfFindClusterInType_2
   \   00000028   0x2A80             CMP      R2,#+128
   \   0000002A   0xD0ED             BEQ.N    ??emberAfFindClusterInType_1
   \   0000002C   0x2A40             CMP      R2,#+64
   \   0000002E   0xD1EE             BNE.N    ??emberAfFindClusterInType_3
   \   00000030   0x7B06             LDRB     R6,[R0, #+12]
   \   00000032   0x0676             LSLS     R6,R6,#+25
   \   00000034   0xD5EB             BPL.N    ??emberAfFindClusterInType_3
    561                return cluster;
   \   00000036   0xBD50             POP      {R4,R6,PC}
    562              }
    563            }
    564            return NULL;
   \                     ??emberAfFindClusterInType_4: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindClusterInType_2: (+1)
   \   0000003A   0xBD50             POP      {R4,R6,PC}       ;; return
    565          }
    566          

   \                                 In section .text, align 2, keep-with-next
    567          int8u emberAfClusterIndex(int8u endpoint,
    568                                    EmberAfClusterId clusterId,
    569                                    int8u mask)
    570          {
   \                     emberAfClusterIndex: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4693             MOV      R11,R2
    571            int8u ep;
    572            int8u index = 0xFF;
   \   0000000A   0x27FF             MOVS     R7,#+255
    573            for ( ep=0; ep < emberAfEndpointCount(); ep++ ) {
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable35_1
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable35
   \   00000016   0xE000             B.N      ??emberAfClusterIndex_0
   \                     ??emberAfClusterIndex_1: (+1)
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emberAfClusterIndex_0: (+1)
   \   0000001A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD20E             BCS.N    ??emberAfClusterIndex_2
    574              EmberAfEndpointType *endpointType = emAfEndpoints[ep].endpointType;
    575              if ( emberAfFindClusterInType(endpointType, clusterId, mask) != NULL ) {
   \   00000024   0x012E             LSLS     R6,R5,#+4
   \   00000026   0x1930             ADDS     R0,R6,R4
   \   00000028   0x465A             MOV      R2,R11
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x4651             MOV      R1,R10
   \   0000002E   0x.... 0x....      BL       emberAfFindClusterInType
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F0             BEQ.N    ??emberAfClusterIndex_1
    576                index++;
    577                if ( emAfEndpoints[ep].endpoint == endpoint )
   \   00000036   0x5D30             LDRB     R0,[R6, R4]
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \   0000003A   0x4540             CMP      R0,R8
   \   0000003C   0xD1EC             BNE.N    ??emberAfClusterIndex_1
    578                  return index;
   \   0000003E   0xB2F8             UXTB     R0,R7
   \   00000040   0xE000             B.N      ??emberAfClusterIndex_3
    579              }
    580            }
    581            return 0xFF;
   \                     ??emberAfClusterIndex_2: (+1)
   \   00000042   0x20FF             MOVS     R0,#+255
   \                     ??emberAfClusterIndex_3: (+1)
   \   00000044   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    582          }
    583          
    584          // Returns TRUE If endpoint contains passed cluster

   \                                 In section .text, align 2, keep-with-next
    585          boolean emberAfContainsCluster(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsCluster: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    586            return ( emberAfFindCluster(endpoint, clusterId, 0) != NULL );
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             B.N      ?Subroutine1
    587          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       emberAfFindCluster
   \   00000004   0xB100             CBZ.N    R0,??Subroutine1_0
   \   00000006   0x2001             MOVS     R0,#+1
   \                     ??Subroutine1_0: (+1)
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    588          

   \                                 In section .text, align 2, keep-with-next
    589          boolean emberAfContainsServer(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsServer: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    590            return ( emberAfFindCluster(endpoint, clusterId, CLUSTER_MASK_SERVER) != NULL );
   \   00000002   0x2240             MOVS     R2,#+64
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
    591          }
    592          

   \                                 In section .text, align 2, keep-with-next
    593          boolean emberAfContainsClient(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsClient: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    594            return ( emberAfFindCluster(endpoint, clusterId, CLUSTER_MASK_CLIENT) != NULL );
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x....             B.N      ?Subroutine1
    595          }
    596          

   \                                 In section .text, align 2, keep-with-next
    597          EmberAfCluster *emberAfFindCluster(int8u endpoint,
    598                                             EmberAfClusterId clusterId,
    599                                             int8u mask) {
   \                     emberAfFindCluster: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    600            int8u ep = emberAfIndexFromEndpoint(endpoint);
   \   00000006   0x.... 0x....      BL       emberAfIndexFromEndpoint
    601            if ( ep == 0xFF )
   \   0000000A   0x28FF             CMP      R0,#+255
   \   0000000C   0xD101             BNE.N    ??emberAfFindCluster_0
    602              return NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
    603            else
    604              return emberAfFindClusterInType(emAfEndpoints[ep].endpointType, clusterId, mask);
   \                     ??emberAfFindCluster_0: (+1)
   \   00000012   0x462A             MOV      R2,R5
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x....             LDR.N    R3,??DataTable35_1
   \   00000018   0xEB03 0x1000      ADD      R0,R3,R0, LSL #+4
   \   0000001C   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x....             B.N      emberAfFindClusterInType
    605          }
    606          
    607          // Server wrapper for findClusterEndpointIndex

   \                                 In section .text, align 2, keep-with-next
    608          int8u emberAfFindClusterServerEndpointIndex(int8u endpoint, EmberAfClusterId clusterId)
    609          {
    610            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_SERVER);
   \                     emberAfFindClusterServerEndpointIndex: (+1)
   \   00000000   0x2240             MOVS     R2,#+64
   \   00000002   0x....             B.N      findClusterEndpointIndex
    611          }
    612          
    613          // Client wrapper for findClusterEndpointIndex

   \                                 In section .text, align 2, keep-with-next
    614          int8u emberAfFindClusterClientEndpointIndex(int8u endpoint, EmberAfClusterId clusterId)
    615          {
    616            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_CLIENT);
   \                     emberAfFindClusterClientEndpointIndex: (+1)
   \   00000000   0x2280             MOVS     R2,#+128
   \   00000002                      REQUIRE findClusterEndpointIndex
   \   00000002                      ;; // Fall through to label findClusterEndpointIndex
    617          }
    618          
    619          // Returns the endpoint index within a given cluster

   \                                 In section .text, align 2, keep-with-next
    620          static int8u findClusterEndpointIndex(int8u endpoint, EmberAfClusterId clusterId, int8u mask)
    621          {
   \                     findClusterEndpointIndex: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
    622            int8u i, epi = 0;
    623          
    624            if (emberAfFindCluster(endpoint, clusterId, mask) == NULL) {
   \   0000000A   0x.... 0x....      BL       emberAfFindCluster
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xB908             CBNZ.N   R0,??findClusterEndpointIndex_0
    625              return 0xFF;
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0xE016             B.N      ??findClusterEndpointIndex_1
    626            }
    627          
    628            for (i = 0; i < emberAfEndpointCount(); i++) {
   \                     ??findClusterEndpointIndex_0: (+1)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x....             LDR.N    R7,??DataTable35_1
   \   0000001A   0x....             LDR.N    R4,??DataTable35
   \   0000001C   0xE000             B.N      ??findClusterEndpointIndex_2
   \                     ??findClusterEndpointIndex_3: (+1)
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
   \                     ??findClusterEndpointIndex_2: (+1)
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xD20C             BCS.N    ??findClusterEndpointIndex_4
   \   00000028   0x0130             LSLS     R0,R6,#+4
   \   0000002A   0x5DC0             LDRB     R0,[R0, R7]
   \   0000002C   0x4540             CMP      R0,R8
   \   0000002E   0xD008             BEQ.N    ??findClusterEndpointIndex_4
    629              if (emAfEndpoints[i].endpoint == endpoint) {
    630                break;
    631              }
    632              epi += (emberAfFindCluster(emAfEndpoints[i].endpoint, clusterId, mask) != NULL) ? 1 : 0;
   \   00000030   0x4652             MOV      R2,R10
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       emberAfFindCluster
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD0F0             BEQ.N    ??findClusterEndpointIndex_3
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0xB2ED             UXTB     R5,R5
   \   00000040   0xE7ED             B.N      ??findClusterEndpointIndex_3
    633            }
    634          
    635            return epi;
   \                     ??findClusterEndpointIndex_4: (+1)
   \   00000042   0x4628             MOV      R0,R5
   \                     ??findClusterEndpointIndex_1: (+1)
   \   00000044   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    636          }
    637          

   \                                 In section .text, align 2, keep-with-next
    638          static int8u findIndexFromEndpoint(int8u endpoint, boolean ignoreDisabledEndpoints)
    639          {
   \                     findIndexFromEndpoint: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    640            int8u epi;
    641            for (epi = 0; epi < emberAfEndpointCount(); epi++) {
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             LDR.N    R3,??DataTable35_1
   \   00000006   0xE000             B.N      ??findIndexFromEndpoint_0
   \                     ??findIndexFromEndpoint_1: (+1)
   \   00000008   0x1C52             ADDS     R2,R2,#+1
   \                     ??findIndexFromEndpoint_0: (+1)
   \   0000000A   0x....             LDR.N    R4,??DataTable35
   \   0000000C   0x7824             LDRB     R4,[R4, #+0]
   \   0000000E   0xB2D2             UXTB     R2,R2
   \   00000010   0x42A2             CMP      R2,R4
   \   00000012   0xD20A             BCS.N    ??findIndexFromEndpoint_2
    642              if (emAfEndpoints[epi].endpoint == endpoint
    643                  && (!ignoreDisabledEndpoints
    644                      || emAfEndpoints[epi].bitmask & EMBER_AF_ENDPOINT_ENABLED)) {
   \   00000014   0x0114             LSLS     R4,R2,#+4
   \   00000016   0x5CE5             LDRB     R5,[R4, R3]
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD1F5             BNE.N    ??findIndexFromEndpoint_1
   \   0000001C   0xB119             CBZ.N    R1,??findIndexFromEndpoint_3
   \   0000001E   0x18E4             ADDS     R4,R4,R3
   \   00000020   0x7B64             LDRB     R4,[R4, #+13]
   \   00000022   0x07E4             LSLS     R4,R4,#+31
   \   00000024   0xD5F0             BPL.N    ??findIndexFromEndpoint_1
    645                return epi;
   \                     ??findIndexFromEndpoint_3: (+1)
   \   00000026   0x4610             MOV      R0,R2
   \   00000028   0xBD30             POP      {R4,R5,PC}
    646              }
    647            }
    648            return 0xFF;
   \                     ??findIndexFromEndpoint_2: (+1)
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return
    649          }
    650          

   \                                 In section .text, align 2, keep-with-next
    651          boolean emberAfEndpointIsEnabled(int8u endpoint)
    652          {
   \                     emberAfEndpointIsEnabled: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    653            int8u index = findIndexFromEndpoint(endpoint,
    654                                                FALSE);    // ignore disabled endpoints?
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       findIndexFromEndpoint
    655          
    656            EMBER_TEST_ASSERT(0xFF != index);
    657          
    658            if (0xFF == index) {
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xBF1C             ITT      NE 
    659              return FALSE;
    660            }
    661          
    662            return emberAfEndpointIndexIsEnabled(index);
   \   0000000C   0xE8BD 0x4002      POPNE    {R1,LR}
   \   00000010   0x.... 0x....      BNE.W    emberAfEndpointIndexIsEnabled
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}
    663          }
    664          

   \                                 In section .text, align 2, keep-with-next
    665          boolean emberAfEndpointEnableDisable(int8u endpoint, boolean enable)
    666          {
   \                     emberAfEndpointEnableDisable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460E             MOV      R6,R1
   \   00000004   0x4604             MOV      R4,R0
    667            int8u index = findIndexFromEndpoint(endpoint,
    668                                                FALSE);    // ignore disabled endpoints?
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       findIndexFromEndpoint
    669            boolean currentlyEnabled;
    670          
    671            if (0xFF == index) {
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD101             BNE.N    ??emberAfEndpointEnableDisable_0
    672              return FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD70             POP      {R4-R6,PC}
    673            }
    674          
    675            currentlyEnabled = emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED;
   \                     ??emberAfEndpointEnableDisable_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable35_1
   \   00000016   0xEB01 0x1500      ADD      R5,R1,R0, LSL #+4
    676          
    677            if (enable) {
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0x7B68             LDRB     R0,[R5, #+13]
   \   0000001E   0xF000 0x0101      AND      R1,R0,#0x1
   \   00000022   0xBF14             ITE      NE 
   \   00000024   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \   00000028   0x2000             MOVEQ    R0,#+0
    678              emAfEndpoints[index].bitmask |= EMBER_AF_ENDPOINT_ENABLED;
    679            } else {
    680              emAfEndpoints[index].bitmask &= EMBER_AF_ENDPOINT_DISABLED;
    681            }
    682          
    683          #if defined(EZSP_HOST)
    684            ezspSetEndpointFlags(endpoint,
    685                                 (enable
    686                                  ? EZSP_ENDPOINT_ENABLED
    687                                  : EZSP_ENDPOINT_DISABLED));
    688          #endif
    689          
    690            if (currentlyEnabled ^ enable) {
   \   0000002A   0xEA96 0x0F01      TEQ      R6,R1
   \   0000002E   0x7368             STRB     R0,[R5, #+13]
   \   00000030   0xD014             BEQ.N    ??emberAfEndpointEnableDisable_1
    691              if (enable) {
   \   00000032   0xB176             CBZ.N    R6,??emberAfEndpointEnableDisable_2
    692                initializeEndpoint(&(emAfEndpoints[index]));
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       initializeEndpoint
   \   0000003A   0xE00F             B.N      ??emberAfEndpointEnableDisable_1
    693              } else {
    694                int8u i;
    695                for (i = 0; i < emAfEndpoints[index].endpointType->clusterCount; i++) {
    696                  EmberAfCluster* cluster = &((emAfEndpoints[index].endpointType->cluster)[i]);
   \                     ??emberAfEndpointEnableDisable_3: (+1)
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2114             MOVS     R1,#+20
   \   00000040   0xFB01 0x0006      MLA      R0,R1,R6,R0
    697          //        emberAfCorePrintln("Disabling cluster tick for ep:%d, cluster:0x%2X, %p",
    698          //                           endpoint,
    699          //                           cluster->clusterId,
    700          //                           ((cluster->mask & CLUSTER_MASK_CLIENT)
    701          //                            ? "client"
    702          //                            : "server"));
    703          //        emberAfCoreFlush();
    704                  emberAfDeactivateClusterTick(endpoint,
    705                                               cluster->clusterId,
    706                                               (cluster->mask & CLUSTER_MASK_CLIENT
    707                                                ? EMBER_AF_CLIENT_CLUSTER_TICK
    708                                                : EMBER_AF_SERVER_CLUSTER_TICK));
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \   00000046   0x7B01             LDRB     R1,[R0, #+12]
   \   00000048   0x09CA             LSRS     R2,R1,#+7
   \   0000004A   0x8801             LDRH     R1,[R0, #+0]
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       emberAfDeactivateClusterTick
    709                }
   \                     ??emberAfEndpointEnableDisable_2: (+1)
   \   00000052   0x68A8             LDR      R0,[R5, #+8]
   \   00000054   0x7901             LDRB     R1,[R0, #+4]
   \   00000056   0xB2F6             UXTB     R6,R6
   \   00000058   0x428E             CMP      R6,R1
   \   0000005A   0xD3EF             BCC.N    ??emberAfEndpointEnableDisable_3
    710              }
    711            }
    712          
    713            return TRUE;
   \                     ??emberAfEndpointEnableDisable_1: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
    714          }
    715          
    716          // Returns the index of a given endpoint.  Does not consider disabled endpoints.

   \                                 In section .text, align 2, keep-with-next
    717          int8u emberAfIndexFromEndpoint(int8u endpoint)
    718          {
    719            return findIndexFromEndpoint(endpoint,
    720                                         TRUE);    // ignore disabled endpoints?
   \                     emberAfIndexFromEndpoint: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             B.N      findIndexFromEndpoint
    721          }
    722          

   \                                 In section .text, align 2, keep-with-next
    723          int8u emberAfEndpointFromIndex(int8u index)
    724          {
    725            return emAfEndpoints[index].endpoint;
   \                     emberAfEndpointFromIndex: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable35_1
   \   00000002   0x0100             LSLS     R0,R0,#+4
   \   00000004   0x5C40             LDRB     R0,[R0, R1]
   \   00000006   0x4770             BX       LR               ;; return
    726          }
    727          
    728          // If server == true, returns the number of server clusters,
    729          // otherwise number of client clusters on this endpoint

   \                                 In section .text, align 2, keep-with-next
    730          int8u emberAfClusterCount(int8u endpoint, boolean server)
    731          {
   \                     emberAfClusterCount: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    732            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000004   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000008   0x4601             MOV      R1,R0
    733            int8u i, c=0;
   \   0000000A   0x2000             MOVS     R0,#+0
    734            EmberAfDefinedEndpoint *de;
    735            EmberAfCluster *cluster;
    736          
    737            if ( index == 0xFF ) {
   \   0000000C   0x29FF             CMP      R1,#+255
   \   0000000E   0xBF1F             ITTTT    NE 
   \   00000010   0x....             LDRNE.N  R2,??DataTable35_1
   \   00000012   0xEB02 0x1101      ADDNE    R1,R2,R1, LSL #+4
   \   00000016   0x6889             LDRNE    R1,[R1, #+8]
   \   00000018   0x2900             CMPNE    R1,#+0
    738              return 0;
    739            }
    740            de = &(emAfEndpoints[index]);
    741            if ( de->endpointType == NULL) {
   \   0000001A   0xD014             BEQ.N    ??emberAfClusterCount_0
    742              return 0;
    743            }
    744            for ( i=0; i<de->endpointType->clusterCount; i++ ) {
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xE003             B.N      ??emberAfClusterCount_1
    745              cluster = &(de->endpointType->cluster[i]);
    746              if ( server && emberAfClusterIsServer(cluster) )
   \                     ??emberAfClusterCount_2: (+1)
   \   00000020   0x061B             LSLS     R3,R3,#+24
   \                     ??emberAfClusterCount_3: (+1)
   \   00000022   0xBF48             IT       MI 
   \   00000024   0x4628             MOVMI    R0,R5
    747                c++;
    748              if ( (!server) && emberAfClusterIsClient(cluster) )
    749                c++;
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \                     ??emberAfClusterCount_1: (+1)
   \   00000028   0x790B             LDRB     R3,[R1, #+4]
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x429A             CMP      R2,R3
   \   0000002E   0xD209             BCS.N    ??emberAfClusterCount_4
   \   00000030   0x680B             LDR      R3,[R1, #+0]
   \   00000032   0x2514             MOVS     R5,#+20
   \   00000034   0xFB05 0x3302      MLA      R3,R5,R2,R3
   \   00000038   0x1C45             ADDS     R5,R0,#+1
   \   0000003A   0x7B1B             LDRB     R3,[R3, #+12]
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD0EF             BEQ.N    ??emberAfClusterCount_2
   \   00000040   0x065B             LSLS     R3,R3,#+25
   \   00000042   0xE7EE             B.N      ??emberAfClusterCount_3
    750            }
    751            return c;
   \                     ??emberAfClusterCount_4: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0
   \                     ??emberAfClusterCount_0: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    752          }
    753          
    754          // Returns the clusterId of Nth server or client cluster,
    755          // depending on server toggle.

   \                                 In section .text, align 2, keep-with-next
    756          EmberAfCluster *emberAfGetNthCluster(int8u endpoint, int8u n, boolean server)
    757          {
   \                     emberAfGetNthCluster: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    758            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000006   0x.... 0x....      BL       emberAfIndexFromEndpoint
    759            EmberAfDefinedEndpoint *de;
    760            int8u i,c=0;
   \   0000000A   0x2100             MOVS     R1,#+0
    761            EmberAfCluster *cluster;
    762          
    763            if ( index == 0xFF ) return NULL;
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD01A             BEQ.N    ??emberAfGetNthCluster_0
    764            de = &(emAfEndpoints[index]);
   \   00000010   0x....             LDR.N    R2,??DataTable35_1
   \   00000012   0xEB02 0x1200      ADD      R2,R2,R0, LSL #+4
    765          
    766            for ( i = 0; i < de->endpointType->clusterCount; i++ ) {
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xE001             B.N      ??emberAfGetNthCluster_1
    767              cluster = &(de->endpointType->cluster[i]);
    768          
    769              if ( ( server && emberAfClusterIsServer(cluster) )
    770                   || ( (!server) &&  emberAfClusterIsClient(cluster) ) ) {
    771                if ( c == n ) return cluster;
    772                c++;
   \                     ??emberAfGetNthCluster_2: (+1)
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \                     ??emberAfGetNthCluster_3: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??emberAfGetNthCluster_1: (+1)
   \   0000001E   0x6890             LDR      R0,[R2, #+8]
   \   00000020   0x7906             LDRB     R6,[R0, #+4]
   \   00000022   0xB2DB             UXTB     R3,R3
   \   00000024   0x42B3             CMP      R3,R6
   \   00000026   0xD20E             BCS.N    ??emberAfGetNthCluster_0
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x2614             MOVS     R6,#+20
   \   0000002C   0xFB06 0x0003      MLA      R0,R6,R3,R0
   \   00000030   0x7B06             LDRB     R6,[R0, #+12]
   \   00000032   0xB115             CBZ.N    R5,??emberAfGetNthCluster_4
   \   00000034   0x0676             LSLS     R6,R6,#+25
   \   00000036   0xD402             BMI.N    ??emberAfGetNthCluster_5
   \   00000038   0xE7F0             B.N      ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_4: (+1)
   \   0000003A   0x0636             LSLS     R6,R6,#+24
   \   0000003C   0xD5EE             BPL.N    ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_5: (+1)
   \   0000003E   0xB2C9             UXTB     R1,R1
   \   00000040   0x42A1             CMP      R1,R4
   \   00000042   0xD1EA             BNE.N    ??emberAfGetNthCluster_2
   \   00000044   0xBD70             POP      {R4-R6,PC}
    773              }
    774          
    775            }
    776            return NULL;
   \                     ??emberAfGetNthCluster_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    777          }
    778          
    779          // Returns number of clusters put into the passed cluster list
    780          // for the given endpoint and client/server polarity

   \                                 In section .text, align 2, keep-with-next
    781          int8u emberAfGetClustersFromEndpoint(int8u endpoint, int16u *clusterList, int8u listLen, boolean server) {
   \                     emberAfGetClustersFromEndpoint: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x461F             MOV      R7,R3
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x4616             MOV      R6,R2
    782            int8u clusterCount = emberAfClusterCount(endpoint, server);
   \   0000000C   0x4639             MOV      R1,R7
   \   0000000E   0x.... 0x....      BL       emberAfClusterCount
   \   00000012   0x4680             MOV      R8,R0
    783            int8u i;
    784            EmberAfCluster *cluster;
    785            if (clusterCount > listLen) {
   \   00000014   0x4546             CMP      R6,R8
   \   00000016   0xBFB8             IT       LT 
   \   00000018   0x46B0             MOVLT    R8,R6
    786              clusterCount = listLen;
    787            }
    788            for (i = 0; i < clusterCount; i++) {
   \   0000001A   0x2600             MOVS     R6,#+0
   \   0000001C   0xE002             B.N      ??emberAfGetClustersFromEndpoint_0
    789              cluster = emberAfGetNthCluster(endpoint, i, server);
    790              clusterList[i] = (cluster == NULL ? 0xFFFF : cluster->clusterId);
   \                     ??emberAfGetClustersFromEndpoint_1: (+1)
   \   0000001E   0xF825 0x0019      STRH     R0,[R5, R9, LSL #+1]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfGetClustersFromEndpoint_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6
   \   00000026   0x46B1             MOV      R9,R6
   \   00000028   0x45C1             CMP      R9,R8
   \   0000002A   0xDA0A             BGE.N    ??emberAfGetClustersFromEndpoint_2
   \   0000002C   0x463A             MOV      R2,R7
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       emberAfGetNthCluster
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF0C             ITE      EQ 
   \   0000003A   0xF64F 0x70FF      MOVWEQ   R0,#+65535
   \   0000003E   0x8800             LDRHNE   R0,[R0, #+0]
   \   00000040   0xE7ED             B.N      ??emberAfGetClustersFromEndpoint_1
    791            }
    792            return clusterCount;
   \                     ??emberAfGetClustersFromEndpoint_2: (+1)
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    793          }
    794          

   \                                 In section .text, align 2, keep-with-next
    795          void emberAfInitializeAttributes(int8u endpoint)
    796          {
    797            emAfLoadAttributeDefaults(endpoint, FALSE);
   \                     emberAfInitializeAttributes: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emAfLoadAttributeDefaults
    798          }
    799          

   \                                 In section .text, align 2, keep-with-next
    800          void emberAfResetAttributes(int8u endpoint)
    801          {
    802            emAfLoadAttributeDefaults(endpoint, TRUE);
   \                     emberAfResetAttributes: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002                      REQUIRE emAfLoadAttributeDefaults
   \   00000002                      ;; // Fall through to label emAfLoadAttributeDefaults
    803          }
    804          

   \                                 In section .text, align 2, keep-with-next
    805          void emAfLoadAttributeDefaults(int8u endpoint, boolean writeTokens)
    806          {
   \                     emAfLoadAttributeDefaults: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x468A             MOV      R10,R1
    807            int8u ep, clusterI, curNetwork = emberGetCurrentNetwork();
   \   00000008   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000C   0x9005             STR      R0,[SP, #+20]
    808            int16u attr;
    809            int8u *ptr;
    810            for ( ep = 0; ep < emberAfEndpointCount(); ep++ ) {
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0xE000             B.N      ??emAfLoadAttributeDefaults_0
   \                     ??emAfLoadAttributeDefaults_1: (+1)
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emAfLoadAttributeDefaults_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable35
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD26D             BCS.N    ??emAfLoadAttributeDefaults_2
    811              EmberAfDefinedEndpoint *de;
    812              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \   00000024   0x9801             LDR      R0,[SP, #+4]
   \   00000026   0x28FF             CMP      R0,#+255
   \   00000028   0xD006             BEQ.N    ??emAfLoadAttributeDefaults_3
    813                ep = emberAfIndexFromEndpoint(endpoint);
   \   0000002A   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000002E   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000032   0x4605             MOV      R5,R0
    814                if (ep == 0xFF) {
   \   00000034   0x2DFF             CMP      R5,#+255
   \   00000036   0xD063             BEQ.N    ??emAfLoadAttributeDefaults_2
    815                  return;
    816                }
    817              }
    818              de = &(emAfEndpoints[ep]);
   \                     ??emAfLoadAttributeDefaults_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable35_1
   \   0000003A   0xEB00 0x1605      ADD      R6,R0,R5, LSL #+4
    819          
    820              // Ensure that the endpoint is on the current network
    821              if (endpoint == EMBER_BROADCAST_ENDPOINT
    822                  && de->networkIndex != curNetwork) {
   \   0000003E   0x9801             LDR      R0,[SP, #+4]
   \   00000040   0x28FF             CMP      R0,#+255
   \   00000042   0xD103             BNE.N    ??emAfLoadAttributeDefaults_4
   \   00000044   0x7B30             LDRB     R0,[R6, #+12]
   \   00000046   0x9905             LDR      R1,[SP, #+20]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD1E5             BNE.N    ??emAfLoadAttributeDefaults_1
    823                continue;
    824              }
    825              for ( clusterI = 0; clusterI < de->endpointType->clusterCount; clusterI++) {
   \                     ??emAfLoadAttributeDefaults_4: (+1)
   \   0000004C   0x2700             MOVS     R7,#+0
   \   0000004E   0xE000             B.N      ??emAfLoadAttributeDefaults_5
   \                     ??emAfLoadAttributeDefaults_6: (+1)
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emAfLoadAttributeDefaults_5: (+1)
   \   00000052   0x68B0             LDR      R0,[R6, #+8]
   \   00000054   0x7901             LDRB     R1,[R0, #+4]
   \   00000056   0xB2FF             UXTB     R7,R7
   \   00000058   0x428F             CMP      R7,R1
   \   0000005A   0xD24E             BCS.N    ??emAfLoadAttributeDefaults_7
    826                EmberAfCluster *cluster = &(de->endpointType->cluster[clusterI]);
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x2114             MOVS     R1,#+20
   \   00000060   0xFB01 0x0807      MLA      R8,R1,R7,R0
    827                for ( attr = 0; attr < cluster->attributeCount; attr++) {
   \   00000064   0xF04F 0x0900      MOV      R9,#+0
   \   00000068   0xE013             B.N      ??emAfLoadAttributeDefaults_8
    828                  EmberAfAttributeMetadata *am = &(cluster->attributes[attr]);
    829                  if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)) {
    830                    EmberAfAttributeSearchRecord record;
    831                    record.endpoint = de->endpoint;
    832                    record.clusterId = cluster->clusterId;
    833                    record.clusterMask = (emberAfAttributeIsClient(am)
    834                                          ? CLUSTER_MASK_CLIENT
    835                                          : CLUSTER_MASK_SERVER);
    836                    record.attributeId = am->attributeId;
    837                    record.manufacturerCode = emAfGetManufacturerCodeForAttribute(cluster,
    838                                                                                  am);
    839                    if (am->mask & ATTRIBUTE_MASK_MIN_MAX) {
    840                      if ( emberAfAttributeSize(am) <= 2 ) {
    841                        ptr = (int8u*)&(am->defaultValue.ptrToMinMaxValue->defaultValue.defaultValue);
    842                      } else {
    843                        ptr = (int8u*)am->defaultValue.ptrToMinMaxValue->defaultValue.ptrToDefaultValue;
    844                      }
    845                    } else {
    846                      if ( emberAfAttributeSize(am) <= 2 ) {
    847                        ptr = (int8u*)&(am->defaultValue.defaultValue);
    848                      } else {
    849                        ptr = (int8u*)am->defaultValue.ptrToDefaultValue;
    850                      }
    851                    }
    852                    // At this point, ptr either points to a default value, or is NULL, in which case
    853                    // it should be treated as if it is pointing to an array of all zeroes.
    854          
    855          #if (BIGENDIAN_CPU)
    856                    // The default value for one- and two-byte attributes is stored in an
    857                    // int16u.  On big-endian platforms, a pointer to the default value of
    858                    // a one-byte attribute will point to the wrong byte.  So, for those
    859                    // cases, nudge the pointer forward so it points to the correct byte.
    860                    if (emberAfAttributeSize(am) == 1 && ptr != NULL) {
    861                      *ptr++;
    862                    }
    863          #endif //BIGENDIAN
    864                    emAfReadOrWriteAttribute(&record,
    865                                             NULL,  // metadata - unused
    866                                             ptr,
    867                                             0,     // buffer size - unused
    868                                             TRUE); // write?
   \                     ??emAfLoadAttributeDefaults_9: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0x2300             MOVS     R3,#+0
   \   00000070   0x465A             MOV      R2,R11
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xA802             ADD      R0,SP,#+8
   \   00000076   0x.... 0x....      BL       emAfReadOrWriteAttribute
    869                    if (writeTokens) {
   \   0000007A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000007E   0xD006             BEQ.N    ??emAfLoadAttributeDefaults_10
    870                      emAfSaveAttributeToToken(ptr, de->endpoint, record.clusterId, am);
   \   00000080   0xF8BD 0x200A      LDRH     R2,[SP, #+10]
   \   00000084   0x7831             LDRB     R1,[R6, #+0]
   \   00000086   0x4623             MOV      R3,R4
   \   00000088   0x4658             MOV      R0,R11
   \   0000008A   0x.... 0x....      BL       emAfSaveAttributeToToken
    871                    }
   \                     ??emAfLoadAttributeDefaults_10: (+1)
   \   0000008E   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??emAfLoadAttributeDefaults_8: (+1)
   \   00000092   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000096   0xD2DB             BCS.N    ??emAfLoadAttributeDefaults_6
   \   00000098   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000009C   0x210C             MOVS     R1,#+12
   \   0000009E   0xFB01 0x0409      MLA      R4,R1,R9,R0
   \   000000A2   0x7920             LDRB     R0,[R4, #+4]
   \   000000A4   0x06C0             LSLS     R0,R0,#+27
   \   000000A6   0xD4F2             BMI.N    ??emAfLoadAttributeDefaults_10
   \   000000A8   0x7830             LDRB     R0,[R6, #+0]
   \   000000AA   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000000AE   0x4621             MOV      R1,R4
   \   000000B0   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000000B4   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \   000000B8   0x7920             LDRB     R0,[R4, #+4]
   \   000000BA   0x0640             LSLS     R0,R0,#+25
   \   000000BC   0xBF4C             ITE      MI 
   \   000000BE   0x2080             MOVMI    R0,#+128
   \   000000C0   0x2040             MOVPL    R0,#+64
   \   000000C2   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \   000000C6   0x8820             LDRH     R0,[R4, #+0]
   \   000000C8   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   \   000000CC   0x4640             MOV      R0,R8
   \   000000CE   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   000000D2   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \   000000D6   0x7921             LDRB     R1,[R4, #+4]
   \   000000D8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000DA   0x0749             LSLS     R1,R1,#+29
   \   000000DC   0xD506             BPL.N    ??emAfLoadAttributeDefaults_11
   \   000000DE   0xF8D4 0xB008      LDR      R11,[R4, #+8]
   \   000000E2   0x2803             CMP      R0,#+3
   \   000000E4   0xDBC1             BLT.N    ??emAfLoadAttributeDefaults_9
   \   000000E6   0xF8DB 0xB000      LDR      R11,[R11, #+0]
   \   000000EA   0xE7BE             B.N      ??emAfLoadAttributeDefaults_9
   \                     ??emAfLoadAttributeDefaults_11: (+1)
   \   000000EC   0x2803             CMP      R0,#+3
   \   000000EE   0xBFB4             ITE      LT 
   \   000000F0   0xF104 0x0B08      ADDLT    R11,R4,#+8
   \   000000F4   0xF8D4 0xB008      LDRGE    R11,[R4, #+8]
   \   000000F8   0xE7B7             B.N      ??emAfLoadAttributeDefaults_9
    872                  }
    873                }
    874              }
    875              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \                     ??emAfLoadAttributeDefaults_7: (+1)
   \   000000FA   0x9801             LDR      R0,[SP, #+4]
   \   000000FC   0x28FF             CMP      R0,#+255
   \   000000FE   0xD08B             BEQ.N    ??emAfLoadAttributeDefaults_1
    876                break;
    877              }
    878            }
    879          
    880            if (!writeTokens) {
    881              emAfLoadAttributesFromTokens(endpoint);
    882            }
    883          }
   \                     ??emAfLoadAttributeDefaults_2: (+1)
   \   00000100   0xB007             ADD      SP,SP,#+28
   \   00000102   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    884          

   \                                 In section .text, align 2, keep-with-next
    885          void emAfLoadAttributesFromTokens(int8u endpoint)
    886          {
    887            // On EZSP host we currently do not support this. We need to come up with some
    888            // callbacks.
    889          #ifndef EZSP_HOST
    890            GENERATED_TOKEN_LOADER(endpoint);
    891          #endif // EZSP_HOST
    892          }
   \                     emAfLoadAttributesFromTokens: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    893          
    894          // 'data' argument may be null, since we changed the ptrToDefaultValue
    895          // to be null instead of pointing to all zeroes.
    896          // This function has to be able to deal with that.

   \                                 In section .text, align 2, keep-with-next
    897          void emAfSaveAttributeToToken(int8u *data,
    898                                        int8u endpoint,
    899                                        EmberAfClusterId clusterId,
    900                                        EmberAfAttributeMetadata *metadata)
    901          {
    902            // Get out of here if this attribute doesn't have a token.
    903            if ( !emberAfAttributeIsTokenized(metadata)) return;
    904          
    905          // On EZSP host we currently do not support this. We need to come up with some
    906          // callbacks.
    907          #ifndef EZSP_HOST
    908            GENERATED_TOKEN_SAVER;
    909          #endif // EZSP_HOST
    910          }
   \                     emAfSaveAttributeToToken: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    911          
    912          // This function returns the actual function point from the array,
    913          // iterating over the function bits.

   \                                 In section .text, align 2, keep-with-next
    914          EmberAfGenericClusterFunction
    915          emberAfFindClusterFunction(EmberAfCluster *cluster,
    916                                     EmberAfClusterMask functionMask) {
   \                     emberAfFindClusterFunction: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    917            EmberAfClusterMask mask = 0x01;
    918            int8u functionIndex = 0;
    919          
    920            if ( (cluster->mask & functionMask) == 0 )
   \   00000002   0x7B04             LDRB     R4,[R0, #+12]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x420C             TST      R4,R1
   \   0000000A   0xD105             BNE.N    ??emberAfFindClusterFunction_0
    921              return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}
    922          
    923            while ( mask < functionMask ) {
    924              if ( (cluster->mask & mask) != 0 )
   \                     ??emberAfFindClusterFunction_1: (+1)
   \   00000010   0x4214             TST      R4,R2
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x1C5B             ADDNE    R3,R3,#+1
    925                functionIndex++;
    926              mask <<= 1;
   \   00000016   0x0052             LSLS     R2,R2,#+1
    927            }
   \                     ??emberAfFindClusterFunction_0: (+1)
   \   00000018   0xB2D2             UXTB     R2,R2
   \   0000001A   0x428A             CMP      R2,R1
   \   0000001C   0xD3F8             BCC.N    ??emberAfFindClusterFunction_1
    928            return cluster->functions[functionIndex];
   \   0000001E   0x6900             LDR      R0,[R0, #+16]
   \   00000020   0xB2DB             UXTB     R3,R3
   \   00000022   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    929          }
    930          
    931          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY
    932          /**
    933           * This function populates command IDs into a given buffer.
    934           *
    935           * It returns TRUE if commands are complete, meaning there are NO MORE
    936           * commands that would be returned after the last command.
    937           * It returns FALSE, if there were more commands, but were not populated
    938           * because of maxIdCount limitation.
    939           */

   \                                 In section .text, align 2, keep-with-next
    940          boolean emberAfExtractCommandIds(boolean outgoing,
    941                                           EmberAfClusterCommand *cmd,
    942                                           int16u clusterId,
    943                                           int8u *buffer,
    944                                           int16u bufferLength,
    945                                           int16u *bufferIndex,
    946                                           int8u startId,
    947                                           int8u maxIdCount) {
   \                     emberAfExtractCommandIds: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4688             MOV      R8,R1
    948            int16u i, count=0;
    949            boolean returnValue = TRUE;
   \   00000006   0x2101             MOVS     R1,#+1
    950            int8u cmdDirMask = 0;
    951          
    952            // determine the appropriate mask to match the request
    953            // discover commands generated, client is asking server what commands do you generate?
    954            if (outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xF898 0x0015      LDRB     R0,[R8, #+21]
   \   0000000E   0xF04F 0x0C00      MOV      R12,#+0
   \   00000012   0xD007             BEQ.N    ??emberAfExtractCommandIds_0
   \   00000014   0xB910             CBNZ.N   R0,??emberAfExtractCommandIds_1
    955              cmdDirMask = COMMAND_MASK_OUTGOING_SERVER;
   \   00000016   0xF04F 0x0E02      MOV      LR,#+2
   \   0000001A   0xE009             B.N      ??emberAfExtractCommandIds_2
    956            // discover commands generated server is asking client what commands do you generate?
    957            } else if (outgoing && (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT)) {
   \                     ??emberAfExtractCommandIds_1: (+1)
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD105             BNE.N    ??emberAfExtractCommandIds_3
    958              cmdDirMask = COMMAND_MASK_OUTGOING_CLIENT;
   \   00000020   0x468E             MOV      LR,R1
   \   00000022   0xE005             B.N      ??emberAfExtractCommandIds_2
    959            // discover commands received client is asking server what commands do you receive?
    960            } else if (!outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \                     ??emberAfExtractCommandIds_0: (+1)
   \   00000024   0xB910             CBNZ.N   R0,??emberAfExtractCommandIds_3
    961              cmdDirMask = COMMAND_MASK_INCOMING_SERVER;
   \   00000026   0xF04F 0x0E08      MOV      LR,#+8
   \   0000002A   0xE001             B.N      ??emberAfExtractCommandIds_2
    962            // discover commands received server is asking client what commands do you receive?
    963            } else {
    964              cmdDirMask = COMMAND_MASK_INCOMING_CLIENT;
   \                     ??emberAfExtractCommandIds_3: (+1)
   \   0000002C   0xF04F 0x0E04      MOV      LR,#+4
    965            }
    966          
    967            for ( i = 0; i < EMBER_AF_GENERATED_COMMAND_COUNT; i++ ) {
   \                     ??emberAfExtractCommandIds_2: (+1)
   \   00000030   0x9808             LDR      R0,[SP, #+32]
   \   00000032   0x9D09             LDR      R5,[SP, #+36]
   \   00000034   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000038   0xF8DD 0xA02C      LDR      R10,[SP, #+44]
   \   0000003C   0x2400             MOVS     R4,#+0
    968              if ( generatedCommands[i].clusterId != clusterId )
   \                     ??emberAfExtractCommandIds_4: (+1)
   \   0000003E   0x.... 0x....      ADR.W    R7,generatedCommands
   \   00000042   0xEB07 0x0684      ADD      R6,R7,R4, LSL #+2
   \   00000046   0x8837             LDRH     R7,[R6, #+0]
   \   00000048   0x4297             CMP      R7,R2
   \   0000004A   0xD11E             BNE.N    ??emberAfExtractCommandIds_5
    969                continue;
    970          
    971              if ((generatedCommands[i].mask & cmdDirMask) == 0 )
   \   0000004C   0x78F7             LDRB     R7,[R6, #+3]
   \   0000004E   0xEA17 0x0F0E      TST      R7,LR
   \   00000052   0xD01A             BEQ.N    ??emberAfExtractCommandIds_5
    972                continue;
    973          
    974              //Only start from the passed command id
    975              if (generatedCommands[i].commandId < startId)
   \   00000054   0x78B7             LDRB     R7,[R6, #+2]
   \   00000056   0x454F             CMP      R7,R9
   \   00000058   0xD317             BCC.N    ??emberAfExtractCommandIds_5
    976                continue;
    977          
    978              // According to spec: if cmd->mfgSpecific is set, then we ONLY return the
    979              // mfg specific commands. If it's not, then we ONLY return non-mfg specific.
    980              if ( generatedCommands[i].mask & COMMAND_MASK_MANUFACTURER_SPECIFIC ) {
   \   0000005A   0x78F7             LDRB     R7,[R6, #+3]
   \   0000005C   0x06FF             LSLS     R7,R7,#+27
   \   0000005E   0xF898 0x700F      LDRB     R7,[R8, #+15]
   \   00000062   0xD501             BPL.N    ??emberAfExtractCommandIds_6
    981                 // Command is Mfg specific
    982                if ( !cmd->mfgSpecific ) continue; // ignore if asking for not mfg specific
   \   00000064   0xB90F             CBNZ.N   R7,??emberAfExtractCommandIds_7
   \   00000066   0xE010             B.N      ??emberAfExtractCommandIds_5
    983             } else {
    984                // Command is not mfg specific.
    985                if ( cmd->mfgSpecific ) continue; // Ignore if asking for mfg specific
   \                     ??emberAfExtractCommandIds_6: (+1)
   \   00000068   0xB97F             CBNZ.N   R7,??emberAfExtractCommandIds_5
    986              }
    987          
    988              // The one we are about to put in, is beyond the maxIdCount,
    989              // so instead of populating it in, we set the return flag to
    990              // false and get out of here.
    991              if ( maxIdCount == count || count >= bufferLength ) {
   \                     ??emberAfExtractCommandIds_7: (+1)
   \   0000006A   0x45E2             CMP      R10,R12
   \   0000006C   0xD001             BEQ.N    ??emberAfExtractCommandIds_8
   \   0000006E   0x4584             CMP      R12,R0
   \   00000070   0xDB01             BLT.N    ??emberAfExtractCommandIds_9
    992                returnValue = FALSE;
   \                     ??emberAfExtractCommandIds_8: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
    993                break;
   \   00000074   0xE00D             B.N      ??emberAfExtractCommandIds_10
    994              }
    995              buffer[count] = generatedCommands[i].commandId;
   \                     ??emberAfExtractCommandIds_9: (+1)
   \   00000076   0x78B7             LDRB     R7,[R6, #+2]
   \   00000078   0xF80C 0x7003      STRB     R7,[R12, R3]
    996              (*bufferIndex)++;
    997              count++;
   \   0000007C   0xF10C 0x0601      ADD      R6,R12,#+1
   \   00000080   0x882F             LDRH     R7,[R5, #+0]
   \   00000082   0x1C7F             ADDS     R7,R7,#+1
   \   00000084   0x802F             STRH     R7,[R5, #+0]
   \   00000086   0xFA1F 0xFC86      UXTH     R12,R6
    998            }
   \                     ??emberAfExtractCommandIds_5: (+1)
   \   0000008A   0x1C64             ADDS     R4,R4,#+1
   \   0000008C   0xB2A4             UXTH     R4,R4
   \   0000008E   0x2C3C             CMP      R4,#+60
   \   00000090   0xDBD5             BLT.N    ??emberAfExtractCommandIds_4
    999            return returnValue;
   \                     ??emberAfExtractCommandIds_10: (+1)
   \   00000092   0x4608             MOV      R0,R1
   \   00000094   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1000          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     emberEndpointCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x........         DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x........         DC32     emberAfExternalAttributeWriteCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x........         DC32     emberAfExternalAttributeReadCallback

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 0
   \              0x03 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x0104 0x0104      DC16 260, 260, 260
   \              0x0104       
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0102 0x0006      DC16 258, 6, 7
   \              0x0007       
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x00 0x01          DC8 0, 1, 2, 0
   \              0x02 0x00    
   1001          #else
   1002          // We just need an empty stub if we don't support it
   1003          boolean emberAfExtractCommandIds(boolean outgoing,
   1004                                           EmberAfClusterCommand *cmd,
   1005                                           int16u clusterId,
   1006                                           int8u *buffer,
   1007                                           int16u bufferLength,
   1008                                           int16u *bufferIndex,
   1009                                           int8u startId,
   1010                                           int8u maxIdCount) {
   1011            return TRUE;
   1012          }
   1013          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   emAfCallInits
        16   -> emberAfEndpointIndexIsEnabled
        16   -> initializeEndpoint
      24   emAfClusterAttributeChangedCallback
        24   -- Indirect call
        24   -> emberAfFindCluster
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      24   emAfClusterPreAttributeChangedCallback
        24   -- Indirect call
        24   -> emberAfFindCluster
        24   -> emberAfFindClusterFunction
        24   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
       0   emAfGetManufacturerCodeForAttribute
         0   -> emAfGetManufacturerCodeForCluster
         0   -> getManufacturerCode
       0   emAfGetManufacturerCodeForCluster
         0   -> getManufacturerCode
      64   emAfLoadAttributeDefaults
        64   -> emAfGetManufacturerCodeForAttribute
        64   -> emAfReadOrWriteAttribute
        64   -> emAfSaveAttributeToToken
        64   -> emberAfIndexFromEndpoint
        64   -> emberGetCurrentNetwork
       0   emAfLoadAttributesFromTokens
       8   emAfMatchAttribute
         8   -> emAfGetManufacturerCodeForAttribute
       8   emAfMatchCluster
         8   -> emAfGetManufacturerCodeForCluster
      56   emAfReadOrWriteAttribute
        56   -- Indirect call
        56   -> emAfGetManufacturerCodeForAttribute
        56   -> emAfMatchAttribute
        56   -> emAfMatchCluster
        56   -> emberAfCopyLongString
        56   -> emberAfCopyString
        56   -> emberAfEndpointIndexIsEnabled
        56   -> emberAfIsLongStringAttributeType
        56   -> emberAfIsStringAttributeType
        56   -> halCommonMemCopy
        56   -> halCommonMemSet
       0   emAfSaveAttributeToToken
      16   emberAfClusterCount
        16   -> emberAfIndexFromEndpoint
      24   emberAfClusterDefaultResponseCallback
        24   -- Indirect call
        24   -> emberAfFindCluster
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      40   emberAfClusterIndex
        40   -> emberAfFindClusterInType
      40   emberAfClusterMessageSentCallback
        40   -- Indirect call
        40   -> emberAfFindCluster
        40   -> emberAfFindClusterFunction
        40   -> emberAfPushEndpointNetworkIndex
       8   emberAfContainsClient
         8   -> emberAfFindCluster
       8   emberAfContainsCluster
         8   -> emberAfFindCluster
       8   emberAfContainsServer
         8   -> emberAfFindCluster
      32   emberAfEndpointConfigure
       0   emberAfEndpointCount
      16   emberAfEndpointEnableDisable
        16   -> emberAfDeactivateClusterTick
        16   -> findIndexFromEndpoint
        16   -> initializeEndpoint
       0   emberAfEndpointFromIndex
       0   emberAfEndpointIndexIsEnabled
       8   emberAfEndpointIsEnabled
         8   -> emberAfEndpointIndexIsEnabled
         8   -> findIndexFromEndpoint
      32   emberAfExtractCommandIds
      16   emberAfFindCluster
         0   -> emberAfFindClusterInType
        16   -> emberAfIndexFromEndpoint
       0   emberAfFindClusterClientEndpointIndex
         0   -> findClusterEndpointIndex
       8   emberAfFindClusterFunction
      12   emberAfFindClusterInType
       0   emberAfFindClusterServerEndpointIndex
         0   -> findClusterEndpointIndex
      32   emberAfGetClustersFromEndpoint
        32   -> emberAfClusterCount
        32   -> emberAfGetNthCluster
      16   emberAfGetNthCluster
        16   -> emberAfIndexFromEndpoint
       0   emberAfIndexFromEndpoint
         0   -> findIndexFromEndpoint
       0   emberAfInitializeAttributes
         0   -> emAfLoadAttributeDefaults
       0   emberAfIsLongStringAttributeType
       0   emberAfIsStringAttributeType
       0   emberAfIsThisDataTypeAStringType
      32   emberAfLocateAttributeMetadata
        32   -> emAfReadOrWriteAttribute
       0   emberAfResetAttributes
         0   -> emAfLoadAttributeDefaults
      32   findClusterEndpointIndex
        32   -> emberAfFindCluster
      12   findIndexFromEndpoint
       8   getManufacturerCode
      24   initializeEndpoint
        24   -- Indirect call
        24   -> emberAfClusterInitCallback
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable35_3
       8  ?Subroutine0
      10  ?Subroutine1
      12  ?Subroutine2
       4  ?_0
       8  ?_1
       8  ?_2
       4  ?_3
       4  ?_4
       4  ?_5
       2  attributeManufacturerCodeCount
       4  attributeManufacturerCodes
       2  clusterManufacturerCodeCount
       4  clusterManufacturerCodes
      42  emAfCallInits
      70  emAfClusterAttributeChangedCallback
      64  emAfClusterPreAttributeChangedCallback
      48  emAfEndpoints
      34  emAfGetManufacturerCodeForAttribute
      22  emAfGetManufacturerCodeForCluster
     262  emAfLoadAttributeDefaults
       2  emAfLoadAttributesFromTokens
      38  emAfMatchAttribute
      44  emAfMatchCluster
       4  emAfNetworks
     402  emAfReadOrWriteAttribute
       2  emAfSaveAttributeToToken
      72  emberAfClusterCount
      44  emberAfClusterDefaultResponseCallback
      72  emberAfClusterIndex
      88  emberAfClusterMessageSentCallback
       6  emberAfContainsClient
       6  emberAfContainsCluster
       4  emberAfContainsServer
     134  emberAfEndpointConfigure
       8  emberAfEndpointCount
      96  emberAfEndpointEnableDisable
       8  emberAfEndpointFromIndex
      16  emberAfEndpointIndexIsEnabled
      24  emberAfEndpointIsEnabled
     152  emberAfExtractCommandIds
      36  emberAfFindCluster
       2  emberAfFindClusterClientEndpointIndex
      40  emberAfFindClusterFunction
      60  emberAfFindClusterInType
       4  emberAfFindClusterServerEndpointIndex
       4  emberAfFuncArrayGroupsClusterServer
       8  emberAfFuncArrayIdentifyClusterServer
       4  emberAfFuncArrayLevelControlClusterServer
       8  emberAfFuncArrayOtaBootloadClusterClient
       4  emberAfFuncArrayScenesClusterServer
       8  emberAfFuncArrayTunnelingClusterServer
      72  emberAfGetClustersFromEndpoint
      74  emberAfGetNthCluster
       4  emberAfIndexFromEndpoint
       4  emberAfInitializeAttributes
      16  emberAfIsLongStringAttributeType
      16  emberAfIsStringAttributeType
      24  emberAfIsThisDataTypeAStringType
      50  emberAfLocateAttributeMetadata
       2  emberAfResetAttributes
     376  emberEndpointCount
          attributeData
          singletonAttributeData
      72  findClusterEndpointIndex
      46  findIndexFromEndpoint
     324  generatedAttributes
     340  generatedClusters
     240  generatedCommands
      80  generatedDefaults
      24  generatedEmberAfEndpointTypes
      30  getManufacturerCode
      58  initializeEndpoint

 
   424 bytes in section .bss
   132 bytes in section .rodata
 3 328 bytes in section .text
 
 3 328 bytes of CODE  memory
   132 bytes of CONST memory
   424 bytes of DATA  memory

Errors: none
Warnings: none
