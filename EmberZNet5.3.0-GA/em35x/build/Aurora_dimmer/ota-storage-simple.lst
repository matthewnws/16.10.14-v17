###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:34:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple\ota-storage-simple.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple\ota-storage-simple.c"
#        -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"ota-storage-simple.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\ota-storage-simple.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\ota-storage-simple.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple\ota-storage-simple.c
      1          // *****************************************************************************
      2          // * ota-storage-simple.c
      3          // *
      4          // * This is the implementation of a very simple storage interface for either
      5          // * OTA client or server.  It keeps track of only one file.  The actual storage
      6          // * device is defined by the developer, but it is assumed to be a device
      7          // * with a continuous block of space (such as an EEPROM).  
      8          // * 
      9          // * Copyright 2010 by Ember Corporation. All rights reserved.              *80*
     10          // *****************************************************************************
     11          
     12          #include "app/framework/include/af.h"
     13          #include "callback.h"
     14          #include "app/framework/plugin/ota-common/ota.h"
     15          #include "app/framework/plugin/ota-storage-common/ota-storage.h"
     16          
     17          #include "app/framework/util/util.h"
     18          #include "app/framework/util/common.h"
     19          
     20          //------------------------------------------------------------------------------
     21          // Globals
     22          
     23          // Either we have a full image that can be used by a server to send to clients
     24          // and can be used by clients to bootload, or we have a partial image that can
     25          // be used by clients in the process of downloading a file.
     26          static boolean storageHasFullImage;
     27          
     28          // We cache certain image info since it will be accessed often.
     29          static EmberAfOtaImageId cachedImageId;
     30          static int32u cachedImageSize;
     31          

   \                                 In section .text, align 4, keep-with-next
     32          static PGM int8u magicNumberBytes[] = { 0x1e, 0xf1, 0xee, 0x0b };
   \                     magicNumberBytes:
   \   00000000   0x1E 0xF1          DC8 30, 241, 238, 11
   \              0xEE 0x0B    

   \                                 In section .bss, align 4
   \                     cachedImageId:
   \   00000000                      DS8 16
   \   00000010                      DS8 1
   \   00000011                      DS8 1
   \   00000012                      DS8 2
   \   00000014                      DS8 4
     33          #define TOTAL_MAGIC_NUMBER_BYTES  4
     34          
     35          // This is the minimum length we need to obtain maunfacturer ID, image type ID
     36          // and version
     37          #define IMAGE_INFO_HEADER_LENGTH (VERSION_OFFSET + 4)
     38          
     39          //------------------------------------------------------------------------------
     40          // Forward Declarations
     41          
     42          static EmberAfOtaStorageStatus readAndValidateStoredImage(EmberAfOtaHeader* returnData,
     43                                                                    boolean printMagicNumberError);
     44          static EmberAfOtaImageId getCurrentImageId(void);
     45          static int16u getLittleEndianInt16uFromBlock(const int8u* block);
     46          static int32u getLittleEndianInt32uFromBlock(const int8u* block);
     47          static boolean initDone = FALSE;
     48          
     49          //------------------------------------------------------------------------------
     50          

   \                                 In section .text, align 2, keep-with-next
     51          EmberAfOtaStorageStatus emberAfOtaStorageInitCallback(void)
     52          {
   \                     emberAfOtaStorageInitCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     53            EmberAfOtaHeader header;
     54          
     55            if (initDone) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable22
   \   00000006   0x7C60             LDRB     R0,[R4, #+17]
   \   00000008   0xB092             SUB      SP,SP,#+72
   \   0000000A   0xB970             CBNZ.N   R0,??emberAfOtaStorageInitCallback_0
     56              return EMBER_AF_OTA_STORAGE_SUCCESS;
     57            }
     58          
     59            if (!emberAfOtaStorageDriverInitCallback()) {
   \   0000000C   0x.... 0x....      BL       emberAfOtaStorageDriverInitCallback
   \   00000010   0xB908             CBNZ.N   R0,??emberAfOtaStorageInitCallback_1
     60              return EMBER_AF_OTA_STORAGE_ERROR;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE00A             B.N      ??emberAfOtaStorageInitCallback_2
     61            }
     62          
     63            storageHasFullImage = (EMBER_AF_OTA_STORAGE_SUCCESS
     64                                   == readAndValidateStoredImage(&header, 
     65                                                                 FALSE));  // print magic number error?
   \                     ??emberAfOtaStorageInitCallback_1: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       readAndValidateStoredImage
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x4180             SBCS     R0,R0,R0
   \   00000022   0x0FC0             LSRS     R0,R0,#+31
   \   00000024   0x7420             STRB     R0,[R4, #+16]
     66          
     67            initDone = TRUE;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7460             STRB     R0,[R4, #+17]
     68          
     69            return EMBER_AF_OTA_STORAGE_SUCCESS;
   \                     ??emberAfOtaStorageInitCallback_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??emberAfOtaStorageInitCallback_2: (+1)
   \   0000002C   0xB012             ADD      SP,SP,#+72
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
     70          }
     71          

   \                                 In section .text, align 2, keep-with-next
     72          int8u emberAfOtaStorageGetCountCallback(void)
     73          {
     74            return (storageHasFullImage ? 1 : 0);
   \                     emberAfOtaStorageGetCountCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000004   0x7C00             LDRB     R0,[R0, #+16]
   \   00000006   0xB100             CBZ.N    R0,??emberAfOtaStorageGetCountCallback_0
   \   00000008   0x2001             MOVS     R0,#+1
   \                     ??emberAfOtaStorageGetCountCallback_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return
     75          }
     76          

   \                                 In section .text, align 2, keep-with-next
     77          EmberAfOtaImageId emberAfOtaStorageSearchCallback(int16u manufacturerId, 
     78                                                            int16u manufacturerDeviceId,
     79                                                            const int16u* hardwareVersion)
     80          {
   \                     emberAfOtaStorageSearchCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     81            if (manufacturerId != cachedImageId.manufacturerId
     82                || manufacturerDeviceId != cachedImageId.imageTypeId) {
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable22
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x8828             LDRH     R0,[R5, #+0]
   \   0000000A   0xB289             UXTH     R1,R1
   \   0000000C   0xB092             SUB      SP,SP,#+72
   \   0000000E   0x4281             CMP      R1,R0
   \   00000010   0xBF02             ITTT     EQ 
   \   00000012   0x8868             LDRHEQ   R0,[R5, #+2]
   \   00000014   0xB292             UXTHEQ   R2,R2
   \   00000016   0x4282             CMPEQ    R2,R0
   \   00000018   0x461E             MOV      R6,R3
   \   0000001A   0xD112             BNE.N    ??emberAfOtaStorageSearchCallback_0
     83              return emberAfInvalidImageId;
     84            }
     85          
     86            if (hardwareVersion) {
   \   0000001C   0xB1A6             CBZ.N    R6,??emberAfOtaStorageSearchCallback_1
     87              EmberAfOtaHeader header;
     88              if (EMBER_AF_OTA_STORAGE_SUCCESS
     89                  != readAndValidateStoredImage(&header, 
     90                                                FALSE)) {  // print magic number error?
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       readAndValidateStoredImage
   \   00000026   0xB960             CBNZ.N   R0,??emberAfOtaStorageSearchCallback_0
     91                return emberAfInvalidImageId;
     92              }
     93              if (headerHasHardwareVersions(&header)
     94                  && (header.minimumHardwareVersion > *hardwareVersion
     95                      || header.maximumHardwareVersion < *hardwareVersion)) {
   \   00000028   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002C   0x0740             LSLS     R0,R0,#+29
   \   0000002E   0xD50B             BPL.N    ??emberAfOtaStorageSearchCallback_1
   \   00000030   0x8830             LDRH     R0,[R6, #+0]
   \   00000032   0xF8BD 0x1042      LDRH     R1,[SP, #+66]
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xBF24             ITT      CS 
   \   0000003A   0xF8BD 0x1044      LDRHCS   R1,[SP, #+68]
   \   0000003E   0x4281             CMPCS    R1,R0
   \   00000040   0xD202             BCS.N    ??emberAfOtaStorageSearchCallback_1
     96                return emberAfInvalidImageId;
   \                     ??emberAfOtaStorageSearchCallback_0: (+1)
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x....             LDR.N    R1,??DataTable22_1
   \   00000046   0xE001             B.N      ??emberAfOtaStorageSearchCallback_2
     97              }
     98            }
     99            return cachedImageId;
   \                     ??emberAfOtaStorageSearchCallback_1: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x4629             MOV      R1,R5
   \                     ??emberAfOtaStorageSearchCallback_2: (+1)
   \   0000004C   0x2210             MOVS     R2,#+16
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000052   0xB012             ADD      SP,SP,#+72
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          EmberAfOtaImageId emberAfOtaStorageIteratorFirstCallback(void)
    103          {
   \                     emberAfOtaStorageIteratorFirstCallback: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    104            return getCurrentImageId();
   \   00000002   0x....             LDR.N    R1,??DataTable22
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x7C08             LDRB     R0,[R1, #+16]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x....             LDREQ.N  R1,??DataTable22_1
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000001A   0xB004             ADD      SP,SP,#+16
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    105          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xA900             ADD      R1,SP,#+0
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0x.... 0x....      B.W      __aeabi_memcpy4
    106          

   \                                 In section .text, align 2, keep-with-next
    107          EmberAfOtaImageId emberAfOtaStorageIteratorNextCallback(void)
    108          {
    109            return emberAfInvalidImageId;
   \                     emberAfOtaStorageIteratorNextCallback: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable22_1
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0x.... 0x....      B.W      __aeabi_memcpy4
    110          }
    111          

   \                                 In section .text, align 2, keep-with-next
    112          EmberAfOtaStorageStatus emberAfOtaStorageGetFullHeaderCallback(const EmberAfOtaImageId* id,
    113                                                                         EmberAfOtaHeader* returnData)
    114          {
   \                     emberAfOtaStorageGetFullHeaderCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    115            EmberAfOtaStorageStatus status;
    116          
    117            if (!storageHasFullImage) {
   \   00000004   0x....             LDR.N    R5,??DataTable22
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x7C29             LDRB     R1,[R5, #+16]
   \   0000000A   0xB909             CBNZ.N   R1,??emberAfOtaStorageGetFullHeaderCallback_0
    118              return EMBER_AF_OTA_STORAGE_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    119            }
    120          
    121            status = readAndValidateStoredImage(returnData, 
    122                                                FALSE);  // print magic number error?
    123            return (EMBER_AF_OTA_STORAGE_SUCCESS == status
    124                    && 0 == MEMCOMPARE(&cachedImageId, id, sizeof(EmberAfOtaImageId))
    125                    ? EMBER_AF_OTA_STORAGE_SUCCESS
    126                    : EMBER_AF_OTA_STORAGE_ERROR);
   \                     ??emberAfOtaStorageGetFullHeaderCallback_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x.... 0x....      BL       readAndValidateStoredImage
   \   00000016   0xB928             CBNZ.N   R0,??emberAfOtaStorageGetFullHeaderCallback_1
   \   00000018   0x2210             MOVS     R2,#+16
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       halCommonMemCompare
   \   00000022   0xB100             CBZ.N    R0,??emberAfOtaStorageGetFullHeaderCallback_2
   \                     ??emberAfOtaStorageGetFullHeaderCallback_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \                     ??emberAfOtaStorageGetFullHeaderCallback_2: (+1)
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    127          }
    128          

   \                                 In section .text, align 2, keep-with-next
    129          int32u emberAfOtaStorageGetTotalImageSizeCallback(const EmberAfOtaImageId* id)
    130          {
   \                     emberAfOtaStorageGetTotalImageSizeCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    131            if (storageHasFullImage
    132                && (0 == MEMCOMPARE(&cachedImageId, id, sizeof(EmberAfOtaImageId)))) {
   \   00000002   0x....             LDR.N    R4,??DataTable22
   \   00000004   0x7C21             LDRB     R1,[R4, #+16]
   \   00000006   0xB139             CBZ.N    R1,??emberAfOtaStorageGetTotalImageSizeCallback_0
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x2210             MOVS     R2,#+16
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       halCommonMemCompare
   \   00000012   0xB908             CBNZ.N   R0,??emberAfOtaStorageGetTotalImageSizeCallback_0
    133              return cachedImageSize;
   \   00000014   0x6960             LDR      R0,[R4, #+20]
   \   00000016   0xBD10             POP      {R4,PC}
    134            }
    135            return 0;
   \                     ??emberAfOtaStorageGetTotalImageSizeCallback_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          static void clearCachedId(void)
    139          {
    140            MEMSET(&cachedImageId, 0, sizeof(EmberAfOtaImageId));
   \                     clearCachedId: (+1)
   \   00000000   0x2210             MOVS     R2,#+16
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable22
   \   00000006   0x.... 0x....      B.W      halCommonMemSet
    141          }
    142          

   \                                 In section .text, align 2, keep-with-next
    143          static EmberAfOtaStorageStatus readAndValidateStoredImage(EmberAfOtaHeader* returnData,
    144                                                                    boolean printMagicNumberError)
    145          {
   \                     readAndValidateStoredImage: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB094             SUB      SP,SP,#+80
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
    146            int8u data[OTA_MAXIMUM_HEADER_LENGTH_2_BYTE_ALIGNED];
    147            int8u indexOrReadLength = 0;
    148            int8u parseData;
    149          
    150            // Read up to the maximum OTA header size even if it is not that big.
    151            // The code will not process the extra bytes unless the header indicates
    152            // optional fields are used.
    153            if (!emberAfOtaStorageDriverReadCallback(0,   // offset
    154                                                     OTA_MAXIMUM_HEADER_LENGTH_2_BYTE_ALIGNED,
    155                                                     data)) {
   \   0000000A   0xAA02             ADD      R2,SP,#+8
   \   0000000C   0x2146             MOVS     R1,#+70
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       emberAfOtaStorageDriverReadCallback
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xB910             CBNZ.N   R0,??readAndValidateStoredImage_0
    156              otaPrintln("emberAfOtaStorageDriverReadCallback() failed!");
   \   00000018   0x.... 0x....      ADR.W    R1,?_0
   \   0000001C   0xE0A9             B.N      ??readAndValidateStoredImage_1
    157              return EMBER_AF_OTA_STORAGE_ERROR;
    158            }
    159          
    160            MEMSET(returnData, 0, sizeof(EmberAfOtaHeader));
   \                     ??readAndValidateStoredImage_0: (+1)
   \   0000001E   0x2248             MOVS     R2,#+72
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       halCommonMemSet
    161          
    162            if (0 != MEMPGMCOMPARE(data, magicNumberBytes, TOTAL_MAGIC_NUMBER_BYTES)) {
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0x.... 0x....      ADR.W    R1,magicNumberBytes
   \   0000002E   0xA802             ADD      R0,SP,#+8
   \   00000030   0x.... 0x....      BL       halCommonMemPGMCompare
   \   00000034   0xF10D 0x0808      ADD      R8,SP,#+8
   \   00000038   0xB188             CBZ.N    R0,??readAndValidateStoredImage_2
    163              if (printMagicNumberError) {
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD00E             BEQ.N    ??readAndValidateStoredImage_3
    164                otaPrintln("Bad magic number in file: 0x%X 0x%X 0x%X 0x%X",
    165                           data[0],
    166                           data[1],
    167                           data[2],
    168                           data[3]);
   \   0000003E   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000042   0xF898 0x3001      LDRB     R3,[R8, #+1]
   \   00000046   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000004A   0x.... 0x....      ADR.W    R1,?_1
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       emberAfPrintln
    169              }
    170              return EMBER_AF_OTA_STORAGE_ERROR;
   \                     ??readAndValidateStoredImage_3: (+1)
   \   0000005C   0xE08C             B.N      ??readAndValidateStoredImage_4
    171            }
    172          
    173            returnData->headerVersion = 
    174              getLittleEndianInt16uFromBlock(data + HEADER_VERSION_OFFSET);
   \                     ??readAndValidateStoredImage_2: (+1)
   \   0000005E   0xA803             ADD      R0,SP,#+12
   \   00000060   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
    175          
    176            if (returnData->headerVersion != OTA_HEADER_VERSION) {
   \   00000064   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000068   0x8020             STRH     R0,[R4, #+0]
   \   0000006A   0xD006             BEQ.N    ??readAndValidateStoredImage_5
    177              otaPrintln("Bad version in file 0x%2X", returnData->headerVersion);
   \   0000006C   0x4602             MOV      R2,R0
   \   0000006E   0x.... 0x....      ADR.W    R1,?_2
   \   00000072   0x2040             MOVS     R0,#+64
   \   00000074   0x.... 0x....      BL       emberAfPrintln
    178              return EMBER_AF_OTA_STORAGE_ERROR;
   \   00000078   0xE07E             B.N      ??readAndValidateStoredImage_4
    179            }
    180          
    181            returnData->headerLength = 
    182              getLittleEndianInt16uFromBlock(data + HEADER_LENGTH_OFFSET);
   \                     ??readAndValidateStoredImage_5: (+1)
   \   0000007A   0xF10D 0x000E      ADD      R0,SP,#+14
   \   0000007E   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   00000082   0x8060             STRH     R0,[R4, #+2]
    183            returnData->fieldControl = 
    184              getLittleEndianInt16uFromBlock(data + FIELD_CONTROL_OFFSET);
   \   00000084   0xA804             ADD      R0,SP,#+16
   \   00000086   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   0000008A   0x80A0             STRH     R0,[R4, #+4]
    185            returnData->manufacturerId = 
    186              getLittleEndianInt16uFromBlock(data + MANUFACTURER_ID_OFFSET);
   \   0000008C   0xF10D 0x0012      ADD      R0,SP,#+18
   \   00000090   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   00000094   0x80E0             STRH     R0,[R4, #+6]
    187            returnData->imageTypeId = 
    188              getLittleEndianInt16uFromBlock(data + IMAGE_TYPE_ID_OFFSET);
   \   00000096   0xA805             ADD      R0,SP,#+20
   \   00000098   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   0000009C   0x8120             STRH     R0,[R4, #+8]
    189            returnData->firmwareVersion = 
    190              getLittleEndianInt32uFromBlock(data + VERSION_OFFSET);
   \   0000009E   0xF10D 0x0016      ADD      R0,SP,#+22
   \   000000A2   0x.... 0x....      BL       getLittleEndianInt32uFromBlock
   \   000000A6   0x60E0             STR      R0,[R4, #+12]
    191            returnData->zigbeeStackVersion = 
    192              getLittleEndianInt16uFromBlock(data + STACK_VERSION_OFFSET);
   \   000000A8   0xF10D 0x001A      ADD      R0,SP,#+26
   \   000000AC   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   000000B0   0x8220             STRH     R0,[R4, #+16]
    193          
    194            // We add +1 because the actual length of the string in the data structure
    195            // is longer.  This is to account for a 32-byte string in the OTA header
    196            // that does NOT have a NULL terminator.
    197            MEMSET(returnData->headerString,  0, EMBER_AF_OTA_MAX_HEADER_STRING_LENGTH + 1);
   \   000000B2   0x2221             MOVS     R2,#+33
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0xF104 0x0012      ADD      R0,R4,#+18
   \   000000BA   0x.... 0x....      BL       halCommonMemSet
    198            MEMCOPY(returnData->headerString, 
    199                    data + HEADER_STRING_OFFSET, 
    200                    EMBER_AF_OTA_MAX_HEADER_STRING_LENGTH);
   \   000000BE   0x2220             MOVS     R2,#+32
   \   000000C0   0xA907             ADD      R1,SP,#+28
   \   000000C2   0xF104 0x0012      ADD      R0,R4,#+18
   \   000000C6   0x.... 0x....      BL       halCommonMemCopy
    201          
    202            returnData->imageSize = 
    203              getLittleEndianInt32uFromBlock(data + IMAGE_SIZE_OFFSET);
   \   000000CA   0xA80F             ADD      R0,SP,#+60
   \   000000CC   0x.... 0x....      BL       getLittleEndianInt32uFromBlock
    204            cachedImageSize = returnData->imageSize;
   \   000000D0   0x....             LDR.N    R7,??DataTable22
   \   000000D2   0x6360             STR      R0,[R4, #+52]
   \   000000D4   0x6178             STR      R0,[R7, #+20]
    205          
    206            clearCachedId();
   \   000000D6   0x.... 0x....      BL       clearCachedId
    207            cachedImageId.manufacturerId  = returnData->manufacturerId;
   \   000000DA   0x88E0             LDRH     R0,[R4, #+6]
   \   000000DC   0x8038             STRH     R0,[R7, #+0]
    208            cachedImageId.imageTypeId     = returnData->imageTypeId;
   \   000000DE   0x8920             LDRH     R0,[R4, #+8]
   \   000000E0   0x8078             STRH     R0,[R7, #+2]
    209            cachedImageId.firmwareVersion = returnData->firmwareVersion;
   \   000000E2   0x68E0             LDR      R0,[R4, #+12]
   \   000000E4   0x6078             STR      R0,[R7, #+4]
    210          
    211            if (returnData->fieldControl == 0) {
   \   000000E6   0x88A0             LDRH     R0,[R4, #+4]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD04C             BEQ.N    ??readAndValidateStoredImage_6
    212              return EMBER_AF_OTA_STORAGE_SUCCESS;
    213            }
    214          
    215            // In an attempt to save flash space, reuse the conditional code here.
    216            // First time through we figure out the total size of the optional fields
    217            // to read from flash.
    218            // Second time through we extract the data and copy into the data struct.
    219            for (parseData = 0; parseData < 2; parseData++) {
   \   000000EC   0x2600             MOVS     R6,#+0
   \   000000EE   0xF104 0x0938      ADD      R9,R4,#+56
    220              if (headerHasSecurityCredentials(returnData)) {
   \                     ??readAndValidateStoredImage_7: (+1)
   \   000000F2   0x88A0             LDRH     R0,[R4, #+4]
   \   000000F4   0x07C1             LSLS     R1,R0,#+31
   \   000000F6   0xD506             BPL.N    ??readAndValidateStoredImage_8
    221                if (parseData) {
   \   000000F8   0xB11E             CBZ.N    R6,??readAndValidateStoredImage_9
    222                  returnData->securityCredentials = data[indexOrReadLength];
   \   000000FA   0xF815 0x1008      LDRB     R1,[R5, R8]
   \   000000FE   0xF889 0x1000      STRB     R1,[R9, #+0]
    223                }
    224                indexOrReadLength++;
   \                     ??readAndValidateStoredImage_9: (+1)
   \   00000102   0x1C6D             ADDS     R5,R5,#+1
   \   00000104   0xB2ED             UXTB     R5,R5
    225              }
    226              if (headerHasUpgradeFileDest(returnData)) {
   \                     ??readAndValidateStoredImage_8: (+1)
   \   00000106   0x0780             LSLS     R0,R0,#+30
   \   00000108   0xD511             BPL.N    ??readAndValidateStoredImage_10
    227                if (parseData) {
   \   0000010A   0xB176             CBZ.N    R6,??readAndValidateStoredImage_11
    228                  MEMCOPY(returnData->upgradeFileDestination, 
    229                          data + indexOrReadLength, 
    230                          EUI64_SIZE);
   \   0000010C   0xA802             ADD      R0,SP,#+8
   \   0000010E   0xEB05 0x0A00      ADD      R10,R5,R0
   \   00000112   0x2208             MOVS     R2,#+8
   \   00000114   0x4651             MOV      R1,R10
   \   00000116   0xF104 0x0039      ADD      R0,R4,#+57
   \   0000011A   0x.... 0x....      BL       halCommonMemCopy
    231                  MEMCOPY(cachedImageId.deviceSpecificFileEui64, 
    232                          data + indexOrReadLength, 
    233                          EUI64_SIZE);
   \   0000011E   0x2208             MOVS     R2,#+8
   \   00000120   0x4651             MOV      R1,R10
   \   00000122   0xF107 0x0008      ADD      R0,R7,#+8
   \   00000126   0x.... 0x....      BL       halCommonMemCopy
    234                }
    235                indexOrReadLength += EUI64_SIZE;
   \                     ??readAndValidateStoredImage_11: (+1)
   \   0000012A   0x3508             ADDS     R5,R5,#+8
   \   0000012C   0xB2ED             UXTB     R5,R5
    236              }
    237              if (headerHasHardwareVersions(returnData)) {
   \                     ??readAndValidateStoredImage_10: (+1)
   \   0000012E   0x7920             LDRB     R0,[R4, #+4]
   \   00000130   0x0740             LSLS     R0,R0,#+29
   \   00000132   0xD510             BPL.N    ??readAndValidateStoredImage_12
    238                if (parseData) {
   \   00000134   0xB16E             CBZ.N    R6,??readAndValidateStoredImage_13
    239                  returnData->minimumHardwareVersion = 
    240                    getLittleEndianInt16uFromBlock(data + indexOrReadLength);
   \   00000136   0xA802             ADD      R0,SP,#+8
   \   00000138   0xEB05 0x0A00      ADD      R10,R5,R0
   \   0000013C   0x4650             MOV      R0,R10
   \   0000013E   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   00000142   0xF8A9 0x000A      STRH     R0,[R9, #+10]
    241                  returnData->maximumHardwareVersion = 
    242                    getLittleEndianInt16uFromBlock(data + indexOrReadLength + 2);
   \   00000146   0xF10A 0x0002      ADD      R0,R10,#+2
   \   0000014A   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   0000014E   0xF8A9 0x000C      STRH     R0,[R9, #+12]
    243                }
    244                indexOrReadLength += 4;
   \                     ??readAndValidateStoredImage_13: (+1)
   \   00000152   0x1D2D             ADDS     R5,R5,#+4
   \   00000154   0xB2ED             UXTB     R5,R5
    245              }
    246          
    247              if (parseData) {
   \                     ??readAndValidateStoredImage_12: (+1)
   \   00000156   0xB996             CBNZ.N   R6,??readAndValidateStoredImage_14
    248                // We are done.  Don't read data from the storage device.
    249                continue;
    250              }
    251          
    252              if (indexOrReadLength > OTA_MAXIMUM_HEADER_LENGTH_2_BYTE_ALIGNED) {
   \   00000158   0x2D47             CMP      R5,#+71
   \   0000015A   0xDB02             BLT.N    ??readAndValidateStoredImage_15
    253                otaPrintln("Error: readAndValidateStoredImage() tried to read more data than it could hold.");
   \   0000015C   0x.... 0x....      ADR.W    R1,?_3
   \   00000160   0xE007             B.N      ??readAndValidateStoredImage_1
    254                return EMBER_AF_OTA_STORAGE_ERROR;
    255              }
    256          
    257              if (!emberAfOtaStorageDriverReadCallback(OPTIONAL_FIELDS_OFFSET,
    258                                                       indexOrReadLength, // now it's a read length
    259                                                       data)) {
   \                     ??readAndValidateStoredImage_15: (+1)
   \   00000162   0xAA02             ADD      R2,SP,#+8
   \   00000164   0x4629             MOV      R1,R5
   \   00000166   0x2038             MOVS     R0,#+56
   \   00000168   0x.... 0x....      BL       emberAfOtaStorageDriverReadCallback
   \   0000016C   0xB930             CBNZ.N   R0,??readAndValidateStoredImage_16
    260                otaPrintln("emberAfOtaStorageDriverReadCallback() FAILED!");
   \   0000016E   0x.... 0x....      ADR.W    R1,?_4
   \                     ??readAndValidateStoredImage_1: (+1)
   \   00000172   0x2040             MOVS     R0,#+64
   \   00000174   0x.... 0x....      BL       emberAfPrintln
    261                return EMBER_AF_OTA_STORAGE_ERROR;
   \                     ??readAndValidateStoredImage_4: (+1)
   \   00000178   0x2001             MOVS     R0,#+1
   \   0000017A   0xE005             B.N      ??readAndValidateStoredImage_17
    262              }
    263              indexOrReadLength = OPTIONAL_FIELDS_OFFSET;  // now it's an index again
   \                     ??readAndValidateStoredImage_16: (+1)
   \   0000017C   0x2538             MOVS     R5,#+56
    264          
    265            } // end for loop
   \                     ??readAndValidateStoredImage_14: (+1)
   \   0000017E   0x1C76             ADDS     R6,R6,#+1
   \   00000180   0xB2F6             UXTB     R6,R6
   \   00000182   0x2E02             CMP      R6,#+2
   \   00000184   0xDBB5             BLT.N    ??readAndValidateStoredImage_7
    266          
    267            return EMBER_AF_OTA_STORAGE_SUCCESS;
   \                     ??readAndValidateStoredImage_6: (+1)
   \   00000186   0x2000             MOVS     R0,#+0
   \                     ??readAndValidateStoredImage_17: (+1)
   \   00000188   0xB014             ADD      SP,SP,#+80
   \   0000018A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    268          }
    269          

   \                                 In section .text, align 2, keep-with-next
    270          EmberAfOtaStorageStatus emberAfOtaStorageReadImageDataCallback(const EmberAfOtaImageId* id,
    271                                                                         int32u offset,
    272                                                                         int32u length, 
    273                                                                         int8u* returnData,
    274                                                                         int32u* returnedLength)
    275          {
   \                     emberAfOtaStorageReadImageDataCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    276            if (0 != MEMCOMPARE(id, &cachedImageId, sizeof(EmberAfOtaImageId))) {
   \   00000006   0x....             LDR.N    R7,??DataTable22
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x2210             MOVS     R2,#+16
   \   0000000C   0x4639             MOV      R1,R7
   \   0000000E   0x.... 0x....      BL       halCommonMemCompare
   \   00000012   0xB978             CBNZ.N   R0,??emberAfOtaStorageReadImageDataCallback_0
    277              return EMBER_AF_OTA_STORAGE_ERROR;
    278            }
    279            length = (length > (cachedImageSize - offset)
    280                      ? (cachedImageSize - offset)
    281                      : length);
   \   00000014   0x6978             LDR      R0,[R7, #+20]
   \   00000016   0x1B00             SUBS     R0,R0,R4
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xBF38             IT       CC 
   \   0000001C   0x4605             MOVCC    R5,R0
    282          
    283            if (!emberAfOtaStorageDriverReadCallback(offset,
    284                                                      length,
    285                                                      returnData)) {
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       emberAfOtaStorageDriverReadCallback
   \   00000028   0xB930             CBNZ.N   R0,??emberAfOtaStorageReadImageDataCallback_1
    286              otaPrintln("emberAfOtaStorageDriverReadCallback() FAILED!");
   \   0000002A   0x.... 0x....      ADR.W    R1,?_4
   \   0000002E   0x2040             MOVS     R0,#+64
   \   00000030   0x.... 0x....      BL       emberAfPrintln
    287              return EMBER_AF_OTA_STORAGE_ERROR;
   \                     ??emberAfOtaStorageReadImageDataCallback_0: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}
    288            }
    289            *returnedLength = length;
   \                     ??emberAfOtaStorageReadImageDataCallback_1: (+1)
   \   00000038   0x9806             LDR      R0,[SP, #+24]
   \   0000003A   0x6005             STR      R5,[R0, #+0]
    290            return EMBER_AF_OTA_STORAGE_SUCCESS;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    291          }
    292          

   \                                 In section .text, align 2, keep-with-next
    293          EmberAfOtaStorageStatus emberAfOtaStorageFinishDownloadCallback(int32u offset)
    294          {
   \                     emberAfOtaStorageFinishDownloadCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    295            emberAfOtaStorageDriverDownloadFinishCallback(offset);
   \   00000002   0x.... 0x....      BL       emberAfOtaStorageDriverDownloadFinishCallback
    296            return EMBER_AF_OTA_STORAGE_SUCCESS;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    297          }
    298          

   \                                 In section .text, align 2, keep-with-next
    299          EmberAfOtaStorageStatus emberAfOtaStorageClearTempDataCallback(void)
    300          {
    301            storageHasFullImage = FALSE;
   \                     emberAfOtaStorageClearTempDataCallback: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable22
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x7408             STRB     R0,[R1, #+16]
    302          
    303            return emberAfOtaStorageDriverInvalidateImageCallback();  
   \   00000006   0x.... 0x....      B.W      emberAfOtaStorageDriverInvalidateImageCallback
    304          }
    305          

   \                                 In section .text, align 2, keep-with-next
    306          EmberAfOtaStorageStatus emberAfOtaStorageWriteTempDataCallback(int32u offset,
    307                                                                         int32u length,
    308                                                                         const int8u* data)
    309          {
   \                     emberAfOtaStorageWriteTempDataCallback: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0xB580             PUSH     {R7,LR}
    310            return (emberAfOtaStorageDriverWriteCallback(data,
    311                                                         offset,
    312                                                         length)
    313                    ? EMBER_AF_OTA_STORAGE_SUCCESS
    314                    : EMBER_AF_OTA_STORAGE_ERROR);
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x.... 0x....      BL       emberAfOtaStorageDriverWriteCallback
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x0FC0             LSRS     R0,R0,#+31
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    315          }
    316          

   \                                 In section .text, align 2, keep-with-next
    317          EmberAfOtaStorageStatus emberAfOtaStorageCheckTempDataCallback(int32u* returnOffset,
    318                                                                         int32u* returnTotalSize,
    319                                                                         EmberAfOtaImageId* returnOtaImageId)
    320          {
   \                     emberAfOtaStorageCheckTempDataCallback: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB096             SUB      SP,SP,#+88
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4690             MOV      R8,R2
    321            // Right now, we don't support continuing a download after a reboot.  Either the
    322            // entire image is in flash or we assume nothing has been downloaded.
    323            EmberAfOtaHeader header;
    324            int32u lastOffset = emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback();
   \   0000000C   0x.... 0x....      BL       emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback
   \   00000010   0x4607             MOV      R7,R0
    325            otaPrintln("Last offset downloaded: 0x%4X", lastOffset);
   \   00000012   0x463A             MOV      R2,R7
   \   00000014   0x.... 0x....      ADR.W    R1,?_5
   \   00000018   0x....             LDR.N    R4,??DataTable22
   \   0000001A   0x2040             MOVS     R0,#+64
   \   0000001C   0x.... 0x....      BL       emberAfPrintln
    326            if (lastOffset > OTA_MINIMUM_HEADER_LENGTH
    327                && (EMBER_AF_OTA_STORAGE_SUCCESS
    328                    == readAndValidateStoredImage(&header, 
    329                                                  TRUE))) {  // print magic number error?
   \   00000020   0x2F39             CMP      R7,#+57
   \   00000022   0xD318             BCC.N    ??emberAfOtaStorageCheckTempDataCallback_0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xA804             ADD      R0,SP,#+16
   \   00000028   0x.... 0x....      BL       readAndValidateStoredImage
   \   0000002C   0xB998             CBNZ.N   R0,??emberAfOtaStorageCheckTempDataCallback_0
    330              *returnTotalSize = header.imageSize;
   \   0000002E   0x9811             LDR      R0,[SP, #+68]
   \   00000030   0x6030             STR      R0,[R6, #+0]
    331              *returnOtaImageId = emAfOtaStorageGetImageIdFromHeader(&header);
   \   00000032   0xA904             ADD      R1,SP,#+16
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       emAfOtaStorageGetImageIdFromHeader
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       ?Subroutine0
    332              if (lastOffset >= header.imageSize) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000040   0x9811             LDR      R0,[SP, #+68]
   \   00000042   0x4287             CMP      R7,R0
   \   00000044   0xD304             BCC.N    ??emberAfOtaStorageCheckTempDataCallback_1
    333                storageHasFullImage = TRUE;
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x7421             STRB     R1,[R4, #+16]
    334                *returnOffset = header.imageSize;
   \   0000004A   0x6028             STR      R0,[R5, #+0]
    335              } else {
    336                *returnOffset = lastOffset;
    337                return EMBER_AF_OTA_STORAGE_PARTIAL_FILE_FOUND;
    338              }
    339              return EMBER_AF_OTA_STORAGE_SUCCESS;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE005             B.N      ??emberAfOtaStorageCheckTempDataCallback_2
   \                     ??emberAfOtaStorageCheckTempDataCallback_1: (+1)
   \   00000050   0x602F             STR      R7,[R5, #+0]
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0xE002             B.N      ??emberAfOtaStorageCheckTempDataCallback_2
    340            }
    341            storageHasFullImage = FALSE;
   \                     ??emberAfOtaStorageCheckTempDataCallback_0: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x7420             STRB     R0,[R4, #+16]
    342          
    343            return EMBER_AF_OTA_STORAGE_ERROR;
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??emberAfOtaStorageCheckTempDataCallback_2: (+1)
   \   0000005C   0xB016             ADD      SP,SP,#+88
   \   0000005E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    344          }
    345          

   \                                 In section .text, align 2, keep-with-next
    346          EmberAfOtaStorageStatus emberAfOtaStorageDeleteImageCallback(const EmberAfOtaImageId* id)
    347          {
   \                     emberAfOtaStorageDeleteImageCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    348            EmberAfOtaStorageStatus status;
    349          
    350            if (storageHasFullImage) {
   \   00000002   0x....             LDR.N    R5,??DataTable22
   \   00000004   0x7C28             LDRB     R0,[R5, #+16]
   \   00000006   0xB110             CBZ.N    R0,??emberAfOtaStorageDeleteImageCallback_0
    351              status = emberAfOtaStorageDriverInvalidateImageCallback();
   \   00000008   0x.... 0x....      BL       emberAfOtaStorageDriverInvalidateImageCallback
   \   0000000C   0x4604             MOV      R4,R0
    352            }
    353          
    354            storageHasFullImage = FALSE;
   \                     ??emberAfOtaStorageDeleteImageCallback_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7428             STRB     R0,[R5, #+16]
    355            clearCachedId();
   \   00000012   0x.... 0x....      BL       clearCachedId
    356            
    357            return status;
   \   00000016   0xB2E0             UXTB     R0,R4
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    358          }
    359          

   \                                 In section .text, align 2, keep-with-next
    360          void emAfOtaStorageInfoPrint(void)
    361          {
   \                     emAfOtaStorageInfoPrint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    362            otaPrintln("Storage Module: OTA Simple Storage Plugin");
   \   00000002   0x.... 0x....      ADR.W    R1,?_6
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       emberAfPrintln
    363            otaPrintln("Images Stored:  %d of 1\n",
    364                       (storageHasFullImage ? 1 : 0));
   \   0000000C   0x....             LDR.N    R0,??DataTable22
   \   0000000E   0x7C02             LDRB     R2,[R0, #+16]
   \   00000010   0xB102             CBZ.N    R2,??emAfOtaStorageInfoPrint_0
   \   00000012   0x2201             MOVS     R2,#+1
   \                     ??emAfOtaStorageInfoPrint_0: (+1)
   \   00000014   0x.... 0x....      ADR.W    R1,?_7
   \   00000018   0x2040             MOVS     R0,#+64
   \   0000001A   0x.... 0x....      BL       emberAfPrintln
    365            emAfOtaStorageDriverInfoPrint();
   \   0000001E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000022   0x.... 0x....      B.W      emAfOtaStorageDriverInfoPrint
    366          }
    367          
    368          static EmberAfOtaImageId getCurrentImageId(void)
    369          {
    370            if (!storageHasFullImage) {
    371              return emberAfInvalidImageId;
    372            }
    373            return cachedImageId;
    374          }
    375          

   \                                 In section .text, align 2, keep-with-next
    376          static int16u getLittleEndianInt16uFromBlock(const int8u* block)
    377          {
    378            return (block[0] + (((int16u)(block[1])) << 8));
   \                     getLittleEndianInt16uFromBlock: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x7840             LDRB     R0,[R0, #+1]
   \   00000004   0xEB01 0x2000      ADD      R0,R1,R0, LSL #+8
   \   00000008   0xB280             UXTH     R0,R0
   \   0000000A   0x4770             BX       LR               ;; return
    379          }
    380          

   \                                 In section .text, align 2, keep-with-next
    381          static int32u getLittleEndianInt32uFromBlock(const int8u* block)
    382          {
   \                     getLittleEndianInt32uFromBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    383            int32u value = (getLittleEndianInt16uFromBlock(block)
    384                            + (((int32u)getLittleEndianInt16uFromBlock(block + 2))
    385                               << 16));
    386            return value;
   \   00000004   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x1CA0             ADDS     R0,R4,#+2
   \   0000000C   0x.... 0x....      BL       getLittleEndianInt16uFromBlock
   \   00000010   0xEB05 0x4000      ADD      R0,R5,R0, LSL #+16
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    387          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     cachedImageId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x........         DC32     emberAfInvalidImageId

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x65 0x6D          DC8 "emberAfOtaStorageDriverReadCallback() failed!"
   \              0x62 0x65    
   \              0x72 0x41    
   \              0x66 0x4F    
   \              0x74 0x61    
   \              0x53 0x74    
   \              0x6F 0x72    
   \              0x61 0x67    
   \              0x65 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \              0x72 0x52    
   \              0x65 0x61    
   \              0x64 0x43    
   \              0x61 0x6C    
   \              0x6C 0x62    
   \              0x61 0x63    
   \              0x6B 0x28    
   \              0x29 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x21 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x42 0x61          DC8 "Bad magic number in file: 0x%X 0x%X 0x%X 0x%X"
   \              0x64 0x20    
   \              0x6D 0x61    
   \              0x67 0x69    
   \              0x63 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x3A 0x20    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x58 0x20    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x58 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x42 0x61          DC8 "Bad version in file 0x%2X"
   \              0x64 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x69 0x6E    
   \              0x20 0x66    
   \              0x69 0x6C    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x25 0x32    
   \              0x58 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 72H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x72    
   \   00000008   0x65 0x61          DC8 65H, 61H, 64H, 41H, 6EH, 64H, 56H, 61H
   \              0x64 0x41    
   \              0x6E 0x64    
   \              0x56 0x61    
   \   00000010   0x6C 0x69          DC8 6CH, 69H, 64H, 61H, 74H, 65H, 53H, 74H
   \              0x64 0x61    
   \              0x74 0x65    
   \              0x53 0x74    
   \   00000018   0x6F 0x72          DC8 6FH, 72H, 65H, 64H, 49H, 6DH, 61H, 67H
   \              0x65 0x64    
   \              0x49 0x6D    
   \              0x61 0x67    
   \   00000020   0x65 0x28          DC8 65H, 28H, 29H, 20H, 74H, 72H, 69H, 65H
   \              0x29 0x20    
   \              0x74 0x72    
   \              0x69 0x65    
   \   00000028   0x64 0x20          DC8 64H, 20H, 74H, 6FH, 20H, 72H, 65H, 61H
   \              0x74 0x6F    
   \              0x20 0x72    
   \              0x65 0x61    
   \   00000030   0x64 0x20          DC8 64H, 20H, 6DH, 6FH, 72H, 65H, 20H, 64H
   \              0x6D 0x6F    
   \              0x72 0x65    
   \              0x20 0x64    
   \   00000038   0x61 0x74          DC8 61H, 74H, 61H, 20H, 74H, 68H, 61H, 6EH
   \              0x61 0x20    
   \              0x74 0x68    
   \              0x61 0x6E    
   \   00000040   0x20 0x69          DC8 20H, 69H, 74H, 20H, 63H, 6FH, 75H, 6CH
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x75 0x6C    
   \   00000048   0x64 0x20          DC8 64H, 20H, 68H, 6FH, 6CH, 64H, 2EH, 0
   \              0x68 0x6F    
   \              0x6C 0x64    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x65 0x6D          DC8 "emberAfOtaStorageDriverReadCallback() FAILED!"
   \              0x62 0x65    
   \              0x72 0x41    
   \              0x66 0x4F    
   \              0x74 0x61    
   \              0x53 0x74    
   \              0x6F 0x72    
   \              0x61 0x67    
   \              0x65 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \              0x72 0x52    
   \              0x65 0x61    
   \              0x64 0x43    
   \              0x61 0x6C    
   \              0x6C 0x62    
   \              0x61 0x63    
   \              0x6B 0x28    
   \              0x29 0x20    
   \              0x46 0x41    
   \              0x49 0x4C    
   \              0x45 0x44    
   \              0x21 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x4C 0x61          DC8 "Last offset downloaded: 0x%4X"
   \              0x73 0x74    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x64 0x6F    
   \              0x77 0x6E    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x65 0x64    
   \              0x3A 0x20    
   \              0x30 0x78    
   \              0x25 0x34    
   \              0x58 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x53 0x74          DC8 "Storage Module: OTA Simple Storage Plugin"
   \              0x6F 0x72    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x4D 0x6F    
   \              0x64 0x75    
   \              0x6C 0x65    
   \              0x3A 0x20    
   \              0x4F 0x54    
   \              0x41 0x20    
   \              0x53 0x69    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x20 0x53    
   \              0x74 0x6F    
   \              0x72 0x61    
   \              0x67 0x65    
   \              0x20 0x50    
   \              0x6C 0x75    
   \              0x67 0x69    
   \              0x6E 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x49 0x6D          DC8 "Images Stored:  %d of 1\012"
   \              0x61 0x67    
   \              0x65 0x73    
   \              0x20 0x53    
   \              0x74 0x6F    
   \              0x72 0x65    
   \              0x64 0x3A    
   \              0x20 0x20    
   \              0x25 0x64    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x31 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    388          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   clearCachedId
         0   -> halCommonMemSet
       8   emAfOtaStorageInfoPrint
         0   -> emAfOtaStorageDriverInfoPrint
         8   -> emberAfPrintln
     112   emberAfOtaStorageCheckTempDataCallback
       112   -> __aeabi_memcpy4
       112   -> emAfOtaStorageGetImageIdFromHeader
       112   -> emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback
       112   -> emberAfPrintln
       112   -> readAndValidateStoredImage
       0   emberAfOtaStorageClearTempDataCallback
         0   -> emberAfOtaStorageDriverInvalidateImageCallback
      16   emberAfOtaStorageDeleteImageCallback
        16   -> clearCachedId
        16   -> emberAfOtaStorageDriverInvalidateImageCallback
       8   emberAfOtaStorageFinishDownloadCallback
         8   -> emberAfOtaStorageDriverDownloadFinishCallback
       0   emberAfOtaStorageGetCountCallback
      16   emberAfOtaStorageGetFullHeaderCallback
        16   -> halCommonMemCompare
        16   -> readAndValidateStoredImage
       8   emberAfOtaStorageGetTotalImageSizeCallback
         8   -> halCommonMemCompare
      80   emberAfOtaStorageInitCallback
        80   -> emberAfOtaStorageDriverInitCallback
        80   -> readAndValidateStoredImage
      24   emberAfOtaStorageIteratorFirstCallback
        24   -> __aeabi_memcpy4
       0   emberAfOtaStorageIteratorNextCallback
         0   -> __aeabi_memcpy4
      24   emberAfOtaStorageReadImageDataCallback
        24   -> emberAfOtaStorageDriverReadCallback
        24   -> emberAfPrintln
        24   -> halCommonMemCompare
      88   emberAfOtaStorageSearchCallback
        88   -> __aeabi_memcpy4
        88   -> readAndValidateStoredImage
       8   emberAfOtaStorageWriteTempDataCallback
         8   -> emberAfOtaStorageDriverWriteCallback
       0   getLittleEndianInt16uFromBlock
      16   getLittleEndianInt32uFromBlock
        16   -> getLittleEndianInt16uFromBlock
     112   readAndValidateStoredImage
       112   -> clearCachedId
       112   -> emberAfOtaStorageDriverReadCallback
       112   -> emberAfPrintln
       112   -> getLittleEndianInt16uFromBlock
       112   -> getLittleEndianInt32uFromBlock
       112   -> halCommonMemCopy
       112   -> halCommonMemPGMCompare
       112   -> halCommonMemSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       8  ?Subroutine0
      48  ?_0
      48  ?_1
      28  ?_2
      80  ?_3
      48  ?_4
      32  ?_5
      44  ?_6
      28  ?_7
      24  cachedImageId
          storageHasFullImage
          initDone
          cachedImageSize
      10  clearCachedId
      38  emAfOtaStorageInfoPrint
      98  emberAfOtaStorageCheckTempDataCallback
      10  emberAfOtaStorageClearTempDataCallback
      26  emberAfOtaStorageDeleteImageCallback
      10  emberAfOtaStorageFinishDownloadCallback
      12  emberAfOtaStorageGetCountCallback
      42  emberAfOtaStorageGetFullHeaderCallback
      28  emberAfOtaStorageGetTotalImageSizeCallback
      48  emberAfOtaStorageInitCallback
      30  emberAfOtaStorageIteratorFirstCallback
       8  emberAfOtaStorageIteratorNextCallback
      64  emberAfOtaStorageReadImageDataCallback
      86  emberAfOtaStorageSearchCallback
      22  emberAfOtaStorageWriteTempDataCallback
      12  getLittleEndianInt16uFromBlock
      22  getLittleEndianInt32uFromBlock
       4  magicNumberBytes
     398  readAndValidateStoredImage

 
    24 bytes in section .bss
 1 340 bytes in section .text
 
 1 340 bytes of CODE memory
    24 bytes of DATA memory

Errors: none
Warnings: none
