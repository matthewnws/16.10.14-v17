###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:34:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\util\serial\command-interpreter2.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\util\serial\command-interpreter2.c" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"command-interpreter2.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\util\serial\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\command-interpreter2.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\command-interpreter2.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\util\serial\command-interpreter2.c
      1          /**
      2           * File: command-interpreter.c
      3           * Description: processes commands incoming over the serial port.
      4           *
      5           * Culprit(s): Richard Kelsey, Matteo Paris
      6           *
      7           * Copyright 2008 by Ember Corporation.  All rights reserved.               *80*
      8           */
      9          
     10          #include PLATFORM_HEADER
     11          
     12          #ifdef EZSP_HOST
     13            // Includes needed for ember related functions for the EZSP host
     14            #include "stack/include/error.h"
     15            #include "stack/include/ember-types.h"
     16            #include "app/util/ezsp/ezsp-protocol.h"
     17            #include "app/util/ezsp/ezsp.h"
     18            #include "app/util/ezsp/serial-interface.h"
     19            extern int8u emberEndpointCount;
     20          #else
     21            #include "stack/include/ember.h"
     22          #endif
     23          
     24          #include "hal/hal.h"
     25          #include "app/util/serial/serial.h"
     26          #include "app/util/serial/command-interpreter2.h"
     27          
     28          #if defined(EMBER_REQUIRE_FULL_COMMAND_NAME) \
     29            || defined(EMBER_REQUIRE_EXACT_COMMAND_NAME)
     30            #undef EMBER_REQUIRE_EXACT_COMMAND_NAME
     31            #define EMBER_REQUIRE_EXACT_COMMAND_NAME TRUE
     32          #else
     33            #define EMBER_REQUIRE_EXACT_COMMAND_NAME FALSE
     34          #endif
     35          
     36          #if !defined APP_SERIAL
     37            extern int8u serialPort;
     38            #define APP_SERIAL serialPort
     39          #endif
     40          
     41          #if defined EMBER_COMMAND_INTEPRETER_HAS_DESCRIPTION_FIELD
     42            #define printIfEntryHasDescription(entry, ...) \
     43            if ((entry)->description != NULL) {            \
     44              emberSerialPrintf(APP_SERIAL,                \
     45                                __VA_ARGS__);              \
     46              }
     47            #define printIfEntryHasArgumentDescriptions(entry, ...) \
     48            if ((entry)->argumentDescriptions != NULL) {            \
     49              emberSerialPrintf(APP_SERIAL,                         \
     50                                __VA_ARGS__);                       \
     51            }
     52          #else
     53            #define printIfEntryHasDescription(entry, ...) 
     54            #define printIfEntryHasArgumentDescriptions(entry, ...)
     55          #endif
     56          
     57          //------------------------------------------------------------------------------
     58          // Forward declarations.
     59          static void callCommandAction(void);
     60          static int32u stringToUnsignedInt(int8u argNum, boolean swallowLeadingSign);
     61          static int8u charDowncase(int8u c);
     62          
     63          //------------------------------------------------------------------------------
     64          // Command parsing state
     65          
     66          typedef struct {
     67          
     68            // Finite-state machine's current state. 
     69            int8u state;
     70          
     71            // The command line is stored in this buffer.
     72            // Spaces and trailing '"' and '}' characters are removed,
     73            // and hex strings are converted to bytes. 
     74            int8u buffer[EMBER_COMMAND_BUFFER_LENGTH];
     75          
     76            // Indices of the tokens (command(s) and arguments) in the above buffer.
     77            // The (+ 1) lets us store the ending index.
     78            int8u tokenIndices[MAX_TOKEN_COUNT + 1];
     79          
     80            // The number of tokens read in, including the command(s). 
     81            int8u tokenCount;
     82          
     83            // Used while reading in the command line. 
     84            int8u index;
     85          
     86            // First error found in this command. 
     87            int8u error;
     88          
     89            // Storage for reading in a hex string. A value of 0xFF means unused. 
     90            int8u hexHighNibble;
     91          
     92            // The token number of the first true argument after possible nested commands.
     93            int8u argOffset;
     94          
     95          } EmberCommandState;
     96          
     97          static EmberCommandState commandState;
     98          

   \                                 In section .data, align 1
     99          static int8u defaultBase = 10;
   \                     defaultBase:
   \   00000000   0x0A               DC8 10

   \                                 In section .bss, align 4
   \                     commandState:
   \   00000000                      DS8 120
    100          
    101          // Remember the previous character seen by emberProcessCommandString() to ignore
    102          // an LF following a CR.
    103          static int8u previousCharacter = 0;
    104          
    105          EmberCommandEntry *emberCurrentCommand;
   \                     emberCurrentCommand:
   \   00000078                      DS8 4

   \                                 In section .bss, align 1
   \                     previousCharacter:
   \   00000000                      DS8 1
    106          
    107          enum {
    108            CMD_AWAITING_ARGUMENT,
    109            CMD_READING_ARGUMENT,
    110            CMD_READING_STRING,                  // have read opening " but not closing "
    111            CMD_READING_HEX_STRING,              // have read opening { but not closing }
    112            CMD_READING_TO_EOL                   // clean up after error
    113          };
    114          
    115          // This byte is used to toggle certain internal features on or off.
    116          // By default all are off.

   \                                 In section .bss, align 1
    117          int8u emberCommandInterpreter2Configuration = 0x00;
   \                     emberCommandInterpreter2Configuration:
   \   00000000                      DS8 1
    118          
    119          #ifdef EMBER_TEST
    120          char *stateNames[] =
    121            {
    122              "awaiting argument",
    123              "reading argument",
    124              "reading string",
    125              "reading hex string",
    126              "reading to eol"
    127            };
    128          #endif
    129          
    130          // We provide a way of overriding the default base for numbers on the
    131          // command line for backwards compatibility.
    132          // This function is intentionally NOT documented in the .h file so it
    133          // isn't used anywhere it shouldn't be.

   \                                 In section .text, align 2, keep-with-next
    134          void emberCommandReaderSetDefaultBase(int8u base)
    135          {
    136            defaultBase = base;
   \                     emberCommandReaderSetDefaultBase: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_8
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    137          }
   \   00000006   0x4770             BX       LR               ;; return
    138          
    139          // Some users of command-interpreter2 need the command buffer to be set to 0
    140          // so the command arg is NULL terminated when a pointer is returned.
    141          // It might be better to always zero out the buffer when we reset 
    142          // commandState.state to CMD_AWAITING_ARGUMENT, but I don't want to break any
    143          // other existing apps, so I'm letting the app decide if it wants to zero out
    144          // the buffer.

   \                                 In section .text, align 2, keep-with-next
    145          void emberCommandClearBuffer(void)
    146          {
    147            MEMSET(commandState.buffer, 0, EMBER_COMMAND_BUFFER_LENGTH);
   \                     emberCommandClearBuffer: (+1)
   \   00000000   0x2264             MOVS     R2,#+100
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable38_9
   \   00000008   0x.... 0x....      B.W      halCommonMemSet
    148          }
    149          

   \                                 In section .text, align 2, keep-with-next
    150          const char *emberCommandName(void)
    151          {
    152            return emberCurrentCommand->name;
   \                     emberCommandName: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable38_10
   \   00000004   0x6F80             LDR      R0,[R0, #+120]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return
    153          }
    154          
    155          //----------------------------------------------------------------
    156          // Initialize the state maachine.
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void emberCommandReaderInit(void)
    159          {
    160            commandState.state = CMD_AWAITING_ARGUMENT;
   \                     emberCommandReaderInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable38_10
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    161            commandState.index = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF100 0x0165      ADD      R1,R0,#+101
   \   0000000E   0x734A             STRB     R2,[R1, #+13]
    162            commandState.tokenIndices[0] = 0;
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    163            commandState.tokenCount = 0;
   \   00000012   0x730A             STRB     R2,[R1, #+12]
    164            commandState.error = EMBER_CMD_SUCCESS;
   \   00000014   0x738A             STRB     R2,[R1, #+14]
    165            commandState.hexHighNibble = 0xFF;
   \   00000016   0x22FF             MOVS     R2,#+255
   \   00000018   0x73CA             STRB     R2,[R1, #+15]
    166            commandState.argOffset = 0;
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x740A             STRB     R2,[R1, #+16]
    167            emberCurrentCommand = NULL;
   \   0000001E   0x6782             STR      R2,[R0, #+120]
    168          }
   \   00000020   0x4770             BX       LR               ;; return
    169          
    170          // Returns a value > 15 if ch is not a hex digit.

   \                                 In section .text, align 2, keep-with-next
    171          static int8u hexToInt(int8u ch)
    172          {
    173            return ch - (ch >= 'a' ? 'a' - 10
    174                         : (ch >= 'A' ? 'A' - 10
    175                            : (ch <= '9' ? '0'
    176                               : 0)));
   \                     hexToInt: (+1)
   \   00000000   0x2861             CMP      R0,#+97
   \   00000002   0xBFA8             IT       GE 
   \   00000004   0x2157             MOVGE    R1,#+87
   \   00000006   0xDA07             BGE.N    ??hexToInt_0
   \   00000008   0x2841             CMP      R0,#+65
   \   0000000A   0xBFA8             IT       GE 
   \   0000000C   0x2137             MOVGE    R1,#+55
   \   0000000E   0xDA03             BGE.N    ??hexToInt_0
   \   00000010   0x283A             CMP      R0,#+58
   \   00000012   0xBFB4             ITE      LT 
   \   00000014   0x2130             MOVLT    R1,#+48
   \   00000016   0x2100             MOVGE    R1,#+0
   \                     ??hexToInt_0: (+1)
   \   00000018   0x1A40             SUBS     R0,R0,R1
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x4770             BX       LR               ;; return
    177          }
    178          

   \                                 In section .text, align 2, keep-with-next
    179          static int8u tokenLength(int8u num)
    180          {
    181            return (commandState.tokenIndices[num + 1] 
    182                    - commandState.tokenIndices[num]);
   \                     tokenLength: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   00000004   0x1840             ADDS     R0,R0,R1
   \   00000006   0x3065             ADDS     R0,R0,#+101
   \   00000008   0x7841             LDRB     R1,[R0, #+1]
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x....             B.N      ?Subroutine0
    183          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1A08             SUBS     R0,R1,R0
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    184          

   \                                 In section .text, align 2, keep-with-next
    185          static int8u *tokenPointer(int8s tokenNum)
    186          {
    187            return commandState.buffer + commandState.tokenIndices[tokenNum];
   \                     tokenPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   00000004   0x1840             ADDS     R0,R0,R1
   \   00000006   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   0000000A   0x1840             ADDS     R0,R0,R1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x4770             BX       LR               ;; return
    188          }
    189          
    190          
    191          //----------------------------------------------------------------
    192          // This is a state machine for parsing commands.  If 'input' is NULL
    193          // 'sizeOrPort' is treated as a port and characters are read from there.
    194          // 
    195          // Goto's are used where one parse state naturally falls into another,
    196          // and to save flash.
    197          

   \                                 In section .text, align 2, keep-with-next
    198          boolean emberProcessCommandString(int8u *input, int8u sizeOrPort)
    199          {
   \                     emberProcessCommandString: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    200            boolean isEol = FALSE;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable38_10
   \   00000008   0x4680             MOV      R8,R0
   \   0000000A   0x4689             MOV      R9,R1
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xF105 0x0671      ADD      R6,R5,#+113
   \   00000012   0xE002             B.N      ??emberProcessCommandString_0
    201            boolean isSpace, isQuote;
    202          
    203            while (TRUE) {
    204              int8u next;
    205              
    206              if (input == NULL) {
    207                switch (emberSerialReadByte(sizeOrPort, &next)) {
    208                case EMBER_SUCCESS:
    209                  break;
    210                case EMBER_SERIAL_RX_EMPTY:
    211                  return isEol;
    212                default:
    213                  commandState.error = EMBER_CMD_ERR_PORT_PROBLEM;
    214                  goto READING_TO_EOL;
    215                }
    216              } else if (sizeOrPort == 0) {
    217                return isEol;
    218              } else {
    219                next = *input;
    220                input += 1;
    221                sizeOrPort -= 1;
    222              }
    223          
    224              //   fprintf(stderr, "[processing '%c' (%s)]\n", next, stateNames[commandState.state]);
    225          
    226              if (previousCharacter == '\r' && next == '\n') {
    227                previousCharacter = next;
   \                     ??emberProcessCommandString_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable38_11
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    228                continue;
    229              }
   \                     ??emberProcessCommandString_0: (+1)
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD10A             BNE.N    ??emberProcessCommandString_2
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0xFA5F 0xF089      UXTB     R0,R9
   \   00000026   0x.... 0x....      BL       emberSerialReadByte
   \   0000002A   0xB180             CBZ.N    R0,??emberProcessCommandString_3
   \   0000002C   0x2826             CMP      R0,#+38
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0x2001             MOVNE    R0,#+1
   \   00000032   0xD173             BNE.N    ??emberProcessCommandString_4
   \   00000034   0xE002             B.N      ??emberProcessCommandString_5
   \                     ??emberProcessCommandString_2: (+1)
   \   00000036   0xFA5F 0xF189      UXTB     R1,R9
   \   0000003A   0xB911             CBNZ.N   R1,??emberProcessCommandString_6
   \                     ??emberProcessCommandString_5: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??emberProcessCommandString_6: (+1)
   \   00000042   0xF818 0x0B01      LDRB     R0,[R8], #+1
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000004A   0xF1A1 0x0901      SUB      R9,R1,#+1
   \                     ??emberProcessCommandString_3: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable38_11
   \   00000052   0x7809             LDRB     R1,[R1, #+0]
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x290D             CMP      R1,#+13
   \   0000005A   0xBF08             IT       EQ 
   \   0000005C   0x280A             CMPEQ    R0,#+10
   \   0000005E   0xD0D9             BEQ.N    ??emberProcessCommandString_1
    230              previousCharacter = next;
   \   00000060   0x.... 0x....      LDR.W    R2,??DataTable38_11
    231              isEol = ((next == '\r') || (next == '\n'));
   \   00000064   0x280D             CMP      R0,#+13
   \   00000066   0x7010             STRB     R0,[R2, #+0]
   \   00000068   0xD105             BNE.N    ??emberProcessCommandString_7
   \                     ??emberProcessCommandString_8: (+1)
   \   0000006A   0x2401             MOVS     R4,#+1
   \                     ??emberProcessCommandString_9: (+1)
   \   0000006C   0x2700             MOVS     R7,#+0
    232              isSpace = (next == ' ');
    233              isQuote = (next == '"');
   \   0000006E   0x2822             CMP      R0,#+34
   \   00000070   0xD107             BNE.N    ??emberProcessCommandString_10
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0xE006             B.N      ??emberProcessCommandString_11
   \                     ??emberProcessCommandString_7: (+1)
   \   00000076   0x280A             CMP      R0,#+10
   \   00000078   0xD0F7             BEQ.N    ??emberProcessCommandString_8
   \   0000007A   0x2400             MOVS     R4,#+0
   \   0000007C   0x2820             CMP      R0,#+32
   \   0000007E   0xD1F5             BNE.N    ??emberProcessCommandString_9
   \   00000080   0x2701             MOVS     R7,#+1
   \                     ??emberProcessCommandString_10: (+1)
   \   00000082   0x2100             MOVS     R1,#+0
    234          
    235          
    236              switch (commandState.state) {
   \                     ??emberProcessCommandString_11: (+1)
   \   00000084   0x782A             LDRB     R2,[R5, #+0]
   \   00000086   0xB132             CBZ.N    R2,??emberProcessCommandString_12
   \   00000088   0x2A02             CMP      R2,#+2
   \   0000008A   0xD01F             BEQ.N    ??emberProcessCommandString_13
   \   0000008C   0xD316             BCC.N    ??emberProcessCommandString_14
   \   0000008E   0x2A04             CMP      R2,#+4
   \   00000090   0xD047             BEQ.N    ??emberProcessCommandString_15
   \   00000092   0xD31F             BCC.N    ??emberProcessCommandString_16
   \   00000094   0xE7C1             B.N      ??emberProcessCommandString_0
    237          
    238              case CMD_AWAITING_ARGUMENT:
    239                if (isEol) {
   \                     ??emberProcessCommandString_12: (+1)
   \   00000096   0xB114             CBZ.N    R4,??emberProcessCommandString_17
    240                  callCommandAction();
   \                     ??emberProcessCommandString_18: (+1)
   \   00000098   0x.... 0x....      BL       callCommandAction
   \   0000009C   0xE7BD             B.N      ??emberProcessCommandString_0
    241                } else if (! isSpace) {
   \                     ??emberProcessCommandString_17: (+1)
   \   0000009E   0x2F00             CMP      R7,#+0
   \   000000A0   0xD1BB             BNE.N    ??emberProcessCommandString_0
    242                  if (isQuote) {
   \   000000A2   0xB131             CBZ.N    R1,??emberProcessCommandString_19
    243                    commandState.state = CMD_READING_STRING;
   \   000000A4   0x2002             MOVS     R0,#+2
   \                     ??emberProcessCommandString_20: (+1)
   \   000000A6   0x7028             STRB     R0,[R5, #+0]
   \                     ??emberProcessCommandString_21: (+1)
   \   000000A8   0x7877             LDRB     R7,[R6, #+1]
   \   000000AA   0x2F64             CMP      R7,#+100
   \   000000AC   0xD14E             BNE.N    ??emberProcessCommandString_22
    244                  } else if (next == '{') {
    245                    commandState.state = CMD_READING_HEX_STRING;
    246                  } else {
    247                    commandState.state = CMD_READING_ARGUMENT;
    248                  }
    249                  goto WRITE_TO_BUFFER;
    250                }
    251                break;
    252          
    253              case CMD_READING_ARGUMENT:
    254                if (isEol || isSpace) {
    255                  goto END_ARGUMENT;
    256                } else {
    257                  goto WRITE_TO_BUFFER;
    258                }
    259          
    260              case CMD_READING_STRING:
    261                if (isQuote) {
    262                  goto END_ARGUMENT;
    263                } else if (isEol) {
    264                  commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    265                  goto READING_TO_EOL;
    266                } else {
    267                  goto WRITE_TO_BUFFER;
    268                }
    269          
    270              case CMD_READING_HEX_STRING: {
    271                boolean waitingForLowNibble = (commandState.hexHighNibble != 0xFF);
    272                if (next == '}') {
    273                  if (waitingForLowNibble) {
    274                    commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    275                    goto READING_TO_EOL;
    276                  }
    277                  goto END_ARGUMENT;
    278                } else {
    279                  int8u value = hexToInt(next);
    280                  if (value < 16) {
    281                    if (waitingForLowNibble) {
    282                      next = (commandState.hexHighNibble << 4) + value;
    283                      commandState.hexHighNibble = 0xFF;
    284                      goto WRITE_TO_BUFFER;
    285                    } else {
    286                      commandState.hexHighNibble = value;
    287                    }
    288                  } else if (! isSpace) {
    289                    commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    290                    goto READING_TO_EOL;
    291                  }
    292                }
    293                break;
    294              }
    295          
    296              READING_TO_EOL:
    297                commandState.state = CMD_READING_TO_EOL;
    298                
    299              case CMD_READING_TO_EOL:
    300                if (isEol) {
    301                  if (commandState.error != EMBER_CMD_SUCCESS) {
    302                    emberCommandErrorHandler(commandState.error);
    303                  }
    304                  emberCommandReaderInit();
    305                }
    306                break;
    307          
    308              END_ARGUMENT:
    309                if (commandState.tokenCount == MAX_TOKEN_COUNT) {
    310                  commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    311                  goto READING_TO_EOL;
    312                }
    313                commandState.tokenCount += 1;
    314                commandState.tokenIndices[commandState.tokenCount] = commandState.index;
    315                commandState.state = CMD_AWAITING_ARGUMENT;
    316                if (isEol) {
    317                  callCommandAction();
    318                }
    319                break;
    320          
    321              WRITE_TO_BUFFER:
    322                if (commandState.index == EMBER_COMMAND_BUFFER_LENGTH) {
    323                  commandState.error = EMBER_CMD_ERR_STRING_TOO_LONG;
   \   000000AE   0x2006             MOVS     R0,#+6
   \   000000B0   0xE034             B.N      ??emberProcessCommandString_4
    324                  goto READING_TO_EOL;
    325                }
   \                     ??emberProcessCommandString_19: (+1)
   \   000000B2   0x287B             CMP      R0,#+123
   \   000000B4   0xBF14             ITE      NE 
   \   000000B6   0x2001             MOVNE    R0,#+1
   \   000000B8   0x2003             MOVEQ    R0,#+3
   \   000000BA   0xE7F4             B.N      ??emberProcessCommandString_20
   \                     ??emberProcessCommandString_14: (+1)
   \   000000BC   0xEA57 0x0004      ORRS     R0,R7,R4
   \   000000C0   0xD0F2             BEQ.N    ??emberProcessCommandString_21
   \                     ??emberProcessCommandString_23: (+1)
   \   000000C2   0x7830             LDRB     R0,[R6, #+0]
   \   000000C4   0x280B             CMP      R0,#+11
   \   000000C6   0xD135             BNE.N    ??emberProcessCommandString_24
   \   000000C8   0x2003             MOVS     R0,#+3
   \   000000CA   0xE027             B.N      ??emberProcessCommandString_4
   \                     ??emberProcessCommandString_13: (+1)
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD1F8             BNE.N    ??emberProcessCommandString_23
   \   000000D0   0xBB1C             CBNZ.N   R4,??emberProcessCommandString_25
   \   000000D2   0xE7E9             B.N      ??emberProcessCommandString_21
   \                     ??emberProcessCommandString_16: (+1)
   \   000000D4   0xF896 0xA003      LDRB     R10,[R6, #+3]
   \   000000D8   0xF1BA 0x0FFF      CMP      R10,#+255
   \   000000DC   0xBF14             ITE      NE 
   \   000000DE   0xF04F 0x0B01      MOVNE    R11,#+1
   \   000000E2   0xF04F 0x0B00      MOVEQ    R11,#+0
   \   000000E6   0x287D             CMP      R0,#+125
   \   000000E8   0xD103             BNE.N    ??emberProcessCommandString_26
   \   000000EA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000EE   0xD114             BNE.N    ??emberProcessCommandString_25
   \   000000F0   0xE7E7             B.N      ??emberProcessCommandString_23
   \                     ??emberProcessCommandString_26: (+1)
   \   000000F2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       hexToInt
   \   000000FA   0x2810             CMP      R0,#+16
   \   000000FC   0xDA0B             BGE.N    ??emberProcessCommandString_27
   \   000000FE   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000102   0xD006             BEQ.N    ??emberProcessCommandString_28
   \   00000104   0xEB00 0x100A      ADD      R0,R0,R10, LSL #+4
   \   00000108   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000010C   0x20FF             MOVS     R0,#+255
   \   0000010E   0x70F0             STRB     R0,[R6, #+3]
   \   00000110   0xE7CA             B.N      ??emberProcessCommandString_21
   \                     ??emberProcessCommandString_28: (+1)
   \   00000112   0x70F0             STRB     R0,[R6, #+3]
   \                     ??emberProcessCommandString_29: (+1)
   \   00000114   0xE781             B.N      ??emberProcessCommandString_0
   \                     ??emberProcessCommandString_27: (+1)
   \   00000116   0x2F00             CMP      R7,#+0
   \   00000118   0xD1FC             BNE.N    ??emberProcessCommandString_29
   \                     ??emberProcessCommandString_25: (+1)
   \   0000011A   0x2005             MOVS     R0,#+5
   \                     ??emberProcessCommandString_4: (+1)
   \   0000011C   0x70B0             STRB     R0,[R6, #+2]
   \   0000011E   0x2004             MOVS     R0,#+4
   \   00000120   0x7028             STRB     R0,[R5, #+0]
   \                     ??emberProcessCommandString_15: (+1)
   \   00000122   0x2C00             CMP      R4,#+0
   \   00000124   0xD005             BEQ.N    ??emberProcessCommandString_30
   \   00000126   0x78B0             LDRB     R0,[R6, #+2]
   \   00000128   0xB108             CBZ.N    R0,??emberProcessCommandString_31
   \   0000012A   0x.... 0x....      BL       emberCommandErrorHandler
   \                     ??emberProcessCommandString_31: (+1)
   \   0000012E   0x.... 0x....      BL       emberCommandReaderInit
   \                     ??emberProcessCommandString_30: (+1)
   \   00000132   0xE772             B.N      ??emberProcessCommandString_0
   \                     ??emberProcessCommandString_24: (+1)
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \   00000136   0x7030             STRB     R0,[R6, #+0]
   \   00000138   0xB2C0             UXTB     R0,R0
   \   0000013A   0x7871             LDRB     R1,[R6, #+1]
   \   0000013C   0x1940             ADDS     R0,R0,R5
   \   0000013E   0xF880 0x1065      STRB     R1,[R0, #+101]
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x2C00             CMP      R4,#+0
   \   00000146   0x7028             STRB     R0,[R5, #+0]
   \   00000148   0xD0F3             BEQ.N    ??emberProcessCommandString_30
   \   0000014A   0xE7A5             B.N      ??emberProcessCommandString_18
    326                if (commandState.state == CMD_READING_ARGUMENT) {
   \                     ??emberProcessCommandString_22: (+1)
   \   0000014C   0x7828             LDRB     R0,[R5, #+0]
   \   0000014E   0x2801             CMP      R0,#+1
   \   00000150   0xD105             BNE.N    ??emberProcessCommandString_32
    327                  next = charDowncase(next);
   \   00000152   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000156   0x.... 0x....      BL       charDowncase
   \   0000015A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    328                }
    329                commandState.buffer[commandState.index] = next;
   \                     ??emberProcessCommandString_32: (+1)
   \   0000015E   0x1979             ADDS     R1,R7,R5
   \   00000160   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000164   0x7048             STRB     R0,[R1, #+1]
    330                commandState.index += 1;
   \   00000166   0x7870             LDRB     R0,[R6, #+1]
   \   00000168   0x1C40             ADDS     R0,R0,#+1
   \   0000016A   0x7070             STRB     R0,[R6, #+1]
    331                break;
   \   0000016C   0xE755             B.N      ??emberProcessCommandString_0
    332          
    333              default: {
    334              }
    335              } //close switch.
    336            }
    337          }
    338          
    339          //----------------------------------------------------------------
    340          // Command lookup and processing
    341          
    342          // Returs true if entry is a nested command, and in this case
    343          // it populates the nestedCommand pointer.
    344          // Otherwise it returns false, and does nothing with nestedCommand
    345          //
    346          // Nested commands are implemented by setting the action
    347          // field to NULL, and the argumentTypes field is a pointer
    348          // to a nested EmberCommandEntry array. The older mechanism is
    349          // to set argumentTypes to "n" and then the action field
    350          // contains the EmberCommandEntry, but that approach has a problem
    351          // on AVR128, therefore it is technically deprecated. If you have 
    352          // a choice, put NULL for action and a table under argumentTypes.

   \                                 In section .text, align 2, keep-with-next
    353          static boolean getNestedCommand(EmberCommandEntry *entry,
    354                                          EmberCommandEntry **nestedCommand) {
    355            if ( entry -> action == NULL ) {
   \                     getNestedCommand: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x0003             MOVS     R3,R0
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x600A             STREQ    R2,[R1, #+0]
    356              *nestedCommand = (EmberCommandEntry*)entry->argumentTypes;
    357              return TRUE;
   \   0000000A   0xD003             BEQ.N    ??getNestedCommand_0
    358            } else if ( entry -> argumentTypes[0] == 'n' ) {
   \   0000000C   0x7812             LDRB     R2,[R2, #+0]
   \   0000000E   0x2A6E             CMP      R2,#+110
   \   00000010   0xD102             BNE.N    ??getNestedCommand_1
    359              *nestedCommand = (EmberCommandEntry*)(void*)entry->action;
   \   00000012   0x6008             STR      R0,[R1, #+0]
    360              return TRUE;
   \                     ??getNestedCommand_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR
    361            } else {
    362              return FALSE;
   \                     ??getNestedCommand_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    363            }
    364          }
    365          

   \                                 In section .text, align 2, keep-with-next
    366          static int8u charDowncase(int8u c)
    367          {
    368            if ('A' <= c && c <= 'Z')
   \                     charDowncase: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0x291A             CMP      R1,#+26
   \   00000006   0xBF3C             ITT      CC 
   \   00000008   0x3020             ADDCC    R0,R0,#+32
   \   0000000A   0xB2C0             UXTBCC   R0,R0
    369              return c + 'a' - 'A';
    370            else
    371              return c;
   \   0000000C   0x4770             BX       LR               ;; return
    372          }
    373          

   \                                 In section .text, align 2, keep-with-next
    374          static int8u firstByteOfArg(int8u argNum)
    375          {
    376            int8u tokenNum = argNum + commandState.argOffset;
    377            return commandState.buffer[commandState.tokenIndices[tokenNum]];
   \                     firstByteOfArg: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   00000004   0xF891 0x2075      LDRB     R2,[R1, #+117]
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x1840             ADDS     R0,R0,R1
   \   0000000E   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   00000012   0x1840             ADDS     R0,R0,R1
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x4770             BX       LR               ;; return
    378          }
    379          
    380          // To support existing lazy-typer functionality in the app framework, 
    381          // we allow the user to shorten the entered command so long as the
    382          // substring matches no more than one command in the table.
    383          //
    384          // To allow CONST savings by storing abbreviated command names, we also
    385          // allow matching if the input command is longer than the stored command.
    386          // To reduce complexity, we do not handle multiple inexact matches.  
    387          // For example, if there are commands 'A' and 'AB', and the user enters 
    388          // 'ABC', nothing will match.
    389          
    390          static EmberCommandEntry *commandLookup(EmberCommandEntry *commandFinger, 
    391                                                  int8u tokenNum)
    392          {
    393            EmberCommandEntry *inexactMatch = NULL;
    394            int8u *inputCommand = tokenPointer(tokenNum);
    395            int8u inputLength = tokenLength(tokenNum);
    396            boolean multipleMatches = FALSE;
    397          
    398            for (; commandFinger->name != NULL; commandFinger++) {
    399              PGM_P entryFinger = commandFinger->name;
    400              int8u *inputFinger = inputCommand;
    401              for (;; entryFinger++, inputFinger++) {
    402                boolean endInput = (inputFinger - inputCommand == inputLength);
    403                boolean endEntry = (*entryFinger == 0);
    404                if (endInput && endEntry) {
    405                  return commandFinger;  // Exact match.
    406                } else if (endInput || endEntry) {
    407                  if (inexactMatch != NULL) {
    408                    multipleMatches = TRUE;  // Multiple matches.
    409                    break;
    410                  } else {
    411                    inexactMatch = commandFinger;
    412                    break;
    413                  }
    414                } else if (charDowncase(*inputFinger) != charDowncase(*entryFinger)) {
    415                  break;
    416                }
    417              }
    418            }
    419            return (multipleMatches || EMBER_REQUIRE_EXACT_COMMAND_NAME ? NULL : inexactMatch);
    420          }
    421          
    422          static void echoPrint(void)
    423          {
    424            int8u tokenNum = 0;
    425            for ( ; tokenNum < commandState.tokenCount; tokenNum++ ) {
    426              int8u *ptr = tokenPointer(tokenNum);
    427              int8u len = tokenLength(tokenNum);
    428              emberSerialWriteData(APP_SERIAL, ptr, len);
    429              emberSerialPrintf(APP_SERIAL, " ");
    430            }
    431            emberSerialPrintf(APP_SERIAL, "\r\n");
    432          }
    433          

   \                                 In section .text, align 2, keep-with-next
    434          static void callCommandAction(void)
    435          {
   \                     callCommandAction: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
    436            EmberCommandEntry *commandFinger = emberCommandTable;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable38_12
    437            int8u tokenNum = 0;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable38_13
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD063             BEQ.N    ??callCommandAction_0
    438            // We need a separate argTypeNum index because of the '*' arg type.
    439            int8u argTypeNum, argNum; 
    440          
    441            if (commandState.tokenCount == 0) {
    442              goto kickout2;
    443            }
    444          
    445            // If we have echo, we echo here.
    446            if ( emberCommandInterpreterIsEchoOn() ) {
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable38_14
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD51B             BPL.N    ??CrossCallReturnLabel_4
    447              echoPrint();
   \   00000020   0x2600             MOVS     R6,#+0
   \   00000022   0x.... 0x....      ADR.W    R8,??DataTable34  ;; " "
   \   00000026   0xE010             B.N      ??callCommandAction_1
   \                     ??callCommandAction_2: (+1)
   \   00000028   0xB270             SXTB     R0,R6
   \   0000002A   0x.... 0x....      BL       tokenPointer
   \   0000002E   0x4607             MOV      R7,R0
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       tokenLength
   \   00000036   0x4602             MOV      R2,R0
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       emberSerialWriteData
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       emberSerialPrintf
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \                     ??callCommandAction_1: (+1)
   \   0000004A   0x7828             LDRB     R0,[R5, #+0]
   \   0000004C   0xB2F6             UXTB     R6,R6
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD3EA             BCC.N    ??callCommandAction_2
   \   00000052   0x....             ADR.N    R1,??DataTable34_1  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000054   0x.... 0x....      BL       ?Subroutine2
    448            }
    449          
    450            // Lookup the command.
    451            while (TRUE) {
    452              commandFinger = commandLookup(commandFinger, tokenNum);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000058   0x9E01             LDR      R6,[SP, #+4]
   \   0000005A   0xB260             SXTB     R0,R4
   \   0000005C   0x.... 0x....      BL       tokenPointer
   \   00000060   0x4683             MOV      R11,R0
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       tokenLength
   \   00000068   0xF04F 0x0800      MOV      R8,#+0
   \   0000006C   0x9002             STR      R0,[SP, #+8]
   \   0000006E   0x2700             MOVS     R7,#+0
   \   00000070   0xE00D             B.N      ??callCommandAction_3
   \                     ??callCommandAction_4: (+1)
   \   00000072   0xF819 0x0B01      LDRB     R0,[R9], #+1
   \   00000076   0x.... 0x....      BL       charDowncase
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0xF81A 0x0B01      LDRB     R0,[R10], #+1
   \   00000080   0x.... 0x....      BL       charDowncase
   \   00000084   0x9900             LDR      R1,[SP, #+0]
   \   00000086   0xB2C9             UXTB     R1,R1
   \   00000088   0x4281             CMP      R1,R0
   \   0000008A   0xD006             BEQ.N    ??callCommandAction_5
   \                     ??callCommandAction_6: (+1)
   \   0000008C   0x360C             ADDS     R6,R6,#+12
   \                     ??callCommandAction_3: (+1)
   \   0000008E   0xF8D6 0xA000      LDR      R10,[R6, #+0]
   \   00000092   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000096   0xD017             BEQ.N    ??callCommandAction_7
   \   00000098   0x46D9             MOV      R9,R11
   \                     ??callCommandAction_5: (+1)
   \   0000009A   0x9902             LDR      R1,[SP, #+8]
   \   0000009C   0xEBA9 0x000B      SUB      R0,R9,R11
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000A6   0xBF0C             ITE      EQ 
   \   000000A8   0x2101             MOVEQ    R1,#+1
   \   000000AA   0x2100             MOVNE    R1,#+0
   \   000000AC   0x1E42             SUBS     R2,R0,#+1
   \   000000AE   0x4192             SBCS     R2,R2,R2
   \   000000B0   0xEA11 0x7FD2      TST      R1,R2, LSR #+31
   \   000000B4   0xD10C             BNE.N    ??callCommandAction_8
   \   000000B6   0xEA51 0x70D2      ORRS     R0,R1,R2, LSR #+31
   \   000000BA   0xD0DA             BEQ.N    ??callCommandAction_4
   \   000000BC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C0   0xBF0C             ITE      EQ 
   \   000000C2   0x46B0             MOVEQ    R8,R6
   \   000000C4   0x2701             MOVNE    R7,#+1
   \   000000C6   0xE7E1             B.N      ??callCommandAction_6
   \                     ??callCommandAction_7: (+1)
   \   000000C8   0x2F00             CMP      R7,#+0
   \   000000CA   0xBF14             ITE      NE 
   \   000000CC   0x2600             MOVNE    R6,#+0
   \   000000CE   0x4646             MOVEQ    R6,R8
   \                     ??callCommandAction_8: (+1)
   \   000000D0   0x9601             STR      R6,[SP, #+4]
    453              if (commandFinger == NULL) {
   \   000000D2   0xB946             CBNZ.N   R6,??callCommandAction_9
    454                commandState.error = EMBER_CMD_ERR_NO_SUCH_COMMAND;
   \   000000D4   0x2002             MOVS     R0,#+2
   \                     ??callCommandAction_10: (+1)
   \   000000D6   0x70A8             STRB     R0,[R5, #+2]
    455                goto kickout;
    456              } else {
    457                emberCurrentCommand = commandFinger;
    458                tokenNum += 1;
    459                commandState.argOffset += 1;
    460          
    461                if ( getNestedCommand(commandFinger, &commandFinger) ) {
    462                  if (tokenNum >= commandState.tokenCount) {
    463                    commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    464                    goto kickout;
    465                  }
    466                } else {
    467                  break;
    468                }
    469              }
    470            }
    471          
    472            // If you put '?' as the first character
    473            // of the argument format string, then you effectivelly
    474            // prevent the argument validation, and the command gets executed.
    475            // At that point it is down to the command to deal with whatever
    476            // arguments it got.
    477            if ( commandFinger->argumentTypes[0] == '?' ) 
    478              goto kickout;
    479            
    480            // Validate the arguments.
    481            for(argTypeNum = 0, argNum = 0; 
    482                tokenNum < commandState.tokenCount; 
    483                tokenNum++, argNum++) {
    484              int8u type = commandFinger->argumentTypes[argTypeNum];
    485              int8u firstChar = firstByteOfArg(argNum);
    486              switch(type) {
    487          
    488              // Integers
    489              case 'u':
    490              case 'v':
    491              case 'w':
    492              case 's': {
    493                int32u limit = (type == 'u' ? 0xFF
    494                                : (type == 'v' ? 0xFFFF
    495                                   : (type =='s' ? 0x7F : 0xFFFFFFFFUL)));
    496                if (stringToUnsignedInt(argNum, TRUE) > limit) {
    497                  commandState.error = EMBER_CMD_ERR_ARGUMENT_OUT_OF_RANGE;
    498                }
    499                break;
    500              }
    501          
    502              // String
    503              case 'b':
    504                if (firstChar != '"' && firstChar != '{') {
    505                  commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    506                }
    507                break;
    508          
    509              case 0:
    510                commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    511                break;
    512          
    513              default:
    514                commandState.error = EMBER_CMD_ERR_INVALID_ARGUMENT_TYPE;
    515                break;
    516              }
    517          
    518              if (commandFinger->argumentTypes[argTypeNum + 1] != '*') {
    519                argTypeNum += 1;
    520              }
    521          
    522              if (commandState.error != EMBER_CMD_SUCCESS) {
    523                goto kickout;
    524              }
    525            }
    526          
    527            if (! (commandFinger->argumentTypes[argTypeNum] == 0
    528                   || commandFinger->argumentTypes[argTypeNum + 1] == '*')) {
    529              commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    530            }
    531          
    532           kickout:
    533          
    534            if (commandState.error == EMBER_CMD_SUCCESS) {
    535              emberCommandActionHandler(commandFinger->action);
    536            } else {
    537              emberCommandErrorHandler(commandState.error);
   \                     ??callCommandAction_11: (+1)
   \   000000D8   0x78A8             LDRB     R0,[R5, #+2]
   \   000000DA   0x.... 0x....      BL       emberCommandErrorHandler
    538            }
    539          
    540           kickout2:
    541          
    542            emberCommandReaderInit();
   \                     ??callCommandAction_0: (+1)
   \   000000DE   0x.... 0x....      BL       emberCommandReaderInit
    543          }
   \   000000E2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??callCommandAction_9: (+1)
   \   000000E6   0x7928             LDRB     R0,[R5, #+4]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x7128             STRB     R0,[R5, #+4]
   \   000000F0   0x678E             STR      R6,[R1, #+120]
   \   000000F2   0xA901             ADD      R1,SP,#+4
   \   000000F4   0x9801             LDR      R0,[SP, #+4]
   \   000000F6   0x.... 0x....      BL       getNestedCommand
   \   000000FA   0x1C64             ADDS     R4,R4,#+1
   \   000000FC   0xB120             CBZ.N    R0,??callCommandAction_12
   \   000000FE   0x7828             LDRB     R0,[R5, #+0]
   \   00000100   0xB2E4             UXTB     R4,R4
   \   00000102   0x4284             CMP      R4,R0
   \   00000104   0xD3A8             BCC.N    ??CrossCallReturnLabel_4
   \   00000106   0xE051             B.N      ??callCommandAction_13
   \                     ??callCommandAction_12: (+1)
   \   00000108   0x9801             LDR      R0,[SP, #+4]
   \   0000010A   0x6880             LDR      R0,[R0, #+8]
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x283F             CMP      R0,#+63
   \   00000110   0xD04E             BEQ.N    ??callCommandAction_14
   \   00000112   0x2600             MOVS     R6,#+0
   \   00000114   0x46B0             MOV      R8,R6
   \   00000116   0xE00F             B.N      ??callCommandAction_15
   \                     ??callCommandAction_16: (+1)
   \   00000118   0x2007             MOVS     R0,#+7
   \                     ??callCommandAction_17: (+1)
   \   0000011A   0x70A8             STRB     R0,[R5, #+2]
   \                     ??callCommandAction_18: (+1)
   \   0000011C   0x9801             LDR      R0,[SP, #+4]
   \   0000011E   0x6880             LDR      R0,[R0, #+8]
   \   00000120   0x1830             ADDS     R0,R6,R0
   \   00000122   0x7840             LDRB     R0,[R0, #+1]
   \   00000124   0x282A             CMP      R0,#+42
   \   00000126   0x78A8             LDRB     R0,[R5, #+2]
   \   00000128   0xBF1C             ITT      NE 
   \   0000012A   0x1C76             ADDNE    R6,R6,#+1
   \   0000012C   0xB2F6             UXTBNE   R6,R6
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD13E             BNE.N    ??callCommandAction_14
   \   00000132   0x1C64             ADDS     R4,R4,#+1
   \   00000134   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??callCommandAction_15: (+1)
   \   00000138   0x7828             LDRB     R0,[R5, #+0]
   \   0000013A   0xB2E4             UXTB     R4,R4
   \   0000013C   0x4284             CMP      R4,R0
   \   0000013E   0x9801             LDR      R0,[SP, #+4]
   \   00000140   0x6880             LDR      R0,[R0, #+8]
   \   00000142   0xD22C             BCS.N    ??callCommandAction_19
   \   00000144   0x5C37             LDRB     R7,[R6, R0]
   \   00000146   0xFA5F 0xF088      UXTB     R0,R8
   \   0000014A   0x.... 0x....      BL       firstByteOfArg
   \   0000014E   0xB327             CBZ.N    R7,??callCommandAction_20
   \   00000150   0xF1B7 0x0162      SUBS     R1,R7,#+98
   \   00000154   0xD01B             BEQ.N    ??callCommandAction_21
   \   00000156   0x3911             SUBS     R1,R1,#+17
   \   00000158   0xD002             BEQ.N    ??callCommandAction_22
   \   0000015A   0x1E89             SUBS     R1,R1,#+2
   \   0000015C   0x2902             CMP      R1,#+2
   \   0000015E   0xD8DB             BHI.N    ??callCommandAction_16
   \                     ??callCommandAction_22: (+1)
   \   00000160   0x2F75             CMP      R7,#+117
   \   00000162   0xBF08             IT       EQ 
   \   00000164   0x27FF             MOVEQ    R7,#+255
   \   00000166   0xD009             BEQ.N    ??callCommandAction_23
   \   00000168   0x2F76             CMP      R7,#+118
   \   0000016A   0xBF08             IT       EQ 
   \   0000016C   0xF64F 0x77FF      MOVWEQ   R7,#+65535
   \   00000170   0xD004             BEQ.N    ??callCommandAction_23
   \   00000172   0x2F73             CMP      R7,#+115
   \   00000174   0xBF0C             ITE      EQ 
   \   00000176   0x277F             MOVEQ    R7,#+127
   \   00000178   0xF04F 0x37FF      MOVNE    R7,#-1
   \                     ??callCommandAction_23: (+1)
   \   0000017C   0x2101             MOVS     R1,#+1
   \   0000017E   0xFA5F 0xF088      UXTB     R0,R8
   \   00000182   0x.... 0x....      BL       stringToUnsignedInt
   \   00000186   0x4287             CMP      R7,R0
   \   00000188   0xD2C8             BCS.N    ??callCommandAction_18
   \   0000018A   0x2004             MOVS     R0,#+4
   \   0000018C   0xE7C5             B.N      ??callCommandAction_17
   \                     ??callCommandAction_21: (+1)
   \   0000018E   0x2822             CMP      R0,#+34
   \   00000190   0xBF18             IT       NE 
   \   00000192   0x287B             CMPNE    R0,#+123
   \   00000194   0xD0C2             BEQ.N    ??callCommandAction_18
   \   00000196   0x2005             MOVS     R0,#+5
   \   00000198   0xE7BF             B.N      ??callCommandAction_17
   \                     ??callCommandAction_20: (+1)
   \   0000019A   0x2003             MOVS     R0,#+3
   \   0000019C   0xE7BD             B.N      ??callCommandAction_17
   \                     ??callCommandAction_19: (+1)
   \   0000019E   0x5C31             LDRB     R1,[R6, R0]
   \   000001A0   0x2900             CMP      R1,#+0
   \   000001A2   0xBF1E             ITTT     NE 
   \   000001A4   0x1830             ADDNE    R0,R6,R0
   \   000001A6   0x7840             LDRBNE   R0,[R0, #+1]
   \   000001A8   0x282A             CMPNE    R0,#+42
   \   000001AA   0xD001             BEQ.N    ??callCommandAction_14
   \                     ??callCommandAction_13: (+1)
   \   000001AC   0x2003             MOVS     R0,#+3
   \   000001AE   0xE792             B.N      ??callCommandAction_10
   \                     ??callCommandAction_14: (+1)
   \   000001B0   0x78A8             LDRB     R0,[R5, #+2]
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD190             BNE.N    ??callCommandAction_11
   \   000001B6   0x9801             LDR      R0,[SP, #+4]
   \   000001B8   0x6840             LDR      R0,[R0, #+4]
   \   000001BA   0x.... 0x....      BL       emberCommandActionHandler
   \   000001BE   0xE78E             B.N      ??callCommandAction_0
    544          
    545          
    546          //----------------------------------------------------------------
    547          // Retrieving arguments
    548          

   \                                 In section .text, align 2, keep-with-next
    549          int8u emberCommandArgumentCount(void)
    550          {
    551            return (commandState.tokenCount - commandState.argOffset);
   \                     emberCommandArgumentCount: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable38_13
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7900             LDRB     R0,[R0, #+4]
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
    552          }
    553          

   \                                 In section .text, align 2, keep-with-next
    554          static int32u stringToUnsignedInt(int8u argNum, boolean swallowLeadingSign)
    555          {
   \                     stringToUnsignedInt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4688             MOV      R8,R1
    556            int8u tokenNum = argNum + commandState.argOffset;
   \   00000006   0x....             LDR.N    R1,??DataTable38_10
   \   00000008   0xF101 0x0573      ADD      R5,R1,#+115
    557            int8u *string = commandState.buffer + commandState.tokenIndices[tokenNum];
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x78AA             LDRB     R2,[R5, #+2]
   \   00000010   0x1810             ADDS     R0,R2,R0
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x1842             ADDS     R2,R0,R1
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xF892 0x2065      LDRB     R2,[R2, #+101]
   \   0000001C   0x1851             ADDS     R1,R2,R1
   \   0000001E   0x1C4E             ADDS     R6,R1,#+1
    558            int8u length = tokenLength(tokenNum);
   \   00000020   0x.... 0x....      BL       tokenLength
   \   00000024   0x4682             MOV      R10,R0
    559            int32u result = 0;
    560            int8u base = defaultBase;
   \   00000026   0x....             LDR.N    R0,??DataTable38_8
   \   00000028   0xF890 0x9000      LDRB     R9,[R0, #+0]
    561            int8u i;
    562            for (i = 0; i < length; i++) {
   \   0000002C   0xE008             B.N      ??stringToUnsignedInt_0
    563              int8u next = string[i];
    564              if (swallowLeadingSign && i == 0 && next == '-') {
    565                // do nothing
    566              } else if ((next == 'x' || next == 'X')
    567                         && result == 0
    568                         && (i == 1 || i == 2)) {
   \                     ??stringToUnsignedInt_1: (+1)
   \   0000002E   0xB9AC             CBNZ.N   R4,??stringToUnsignedInt_2
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x2F02             CMPNE    R7,#+2
   \   00000036   0xD111             BNE.N    ??stringToUnsignedInt_2
    569                base = 16;
   \   00000038   0xF04F 0x0910      MOV      R9,#+16
    570              } else {
   \                     ??stringToUnsignedInt_3: (+1)
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   \   0000003E   0xB2FF             UXTB     R7,R7
   \                     ??stringToUnsignedInt_0: (+1)
   \   00000040   0x4557             CMP      R7,R10
   \   00000042   0xDA16             BGE.N    ??stringToUnsignedInt_4
   \   00000044   0x5DB8             LDRB     R0,[R7, R6]
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xD003             BEQ.N    ??stringToUnsignedInt_5
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x282D             CMPEQ    R0,#+45
   \   00000052   0xD0F3             BEQ.N    ??stringToUnsignedInt_3
   \                     ??stringToUnsignedInt_5: (+1)
   \   00000054   0x2878             CMP      R0,#+120
   \   00000056   0xBF18             IT       NE 
   \   00000058   0x2858             CMPNE    R0,#+88
   \   0000005A   0xD0E8             BEQ.N    ??stringToUnsignedInt_1
    571                int8u value = hexToInt(next);
   \                     ??stringToUnsignedInt_2: (+1)
   \   0000005C   0x.... 0x....      BL       hexToInt
    572                if (value < base) {
   \   00000060   0x4548             CMP      R0,R9
   \   00000062   0xBFB8             IT       LT 
   \   00000064   0xFB09 0x0404      MLALT    R4,R9,R4,R0
    573                  result = result * base + value;
   \   00000068   0xDBE8             BLT.N    ??stringToUnsignedInt_3
    574                } else {
    575                  commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
   \   0000006A   0x2005             MOVS     R0,#+5
   \   0000006C   0x7028             STRB     R0,[R5, #+0]
    576                  return 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE000             B.N      ??stringToUnsignedInt_6
    577                }
    578              }
    579            }
    580            return result;
   \                     ??stringToUnsignedInt_4: (+1)
   \   00000072   0x4620             MOV      R0,R4
   \                     ??stringToUnsignedInt_6: (+1)
   \   00000074   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    581          }
    582          

   \                                 In section .text, align 2, keep-with-next
    583          int32u emberUnsignedCommandArgument(int8u argNum) 
    584          {
    585            return stringToUnsignedInt(argNum, FALSE);
   \                     emberUnsignedCommandArgument: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      stringToUnsignedInt
    586          }
    587          

   \                                 In section .text, align 2, keep-with-next
    588          int16s emberSignedCommandArgument(int8u argNum)
    589          {
   \                     emberSignedCommandArgument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    590            boolean negative = (firstByteOfArg(argNum) == '-');
   \   00000004   0x.... 0x....      BL       firstByteOfArg
   \   00000008   0x282D             CMP      R0,#+45
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2501             MOVEQ    R5,#+1
   \   0000000E   0x2500             MOVNE    R5,#+0
    591            int16s result = (int16s) stringToUnsignedInt(argNum, negative);
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       stringToUnsignedInt
    592            return (negative ? -result : result);
   \   00000018   0xB10D             CBZ.N    R5,??emberSignedCommandArgument_0
   \   0000001A   0xB200             SXTH     R0,R0
   \   0000001C   0x4240             RSBS     R0,R0,#+0
   \                     ??emberSignedCommandArgument_0: (+1)
   \   0000001E   0xB200             SXTH     R0,R0
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    593          }
    594          

   \                                 In section .text, align 2, keep-with-next
    595          int8u *emberStringCommandArgument(int8s argNum, int8u *length)
    596          {
   \                     emberStringCommandArgument: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    597            int8u tokenNum = argNum + commandState.argOffset;
   \   00000004   0x....             LDR.N    R1,??DataTable38_10
   \   00000006   0xF891 0x1075      LDRB     R1,[R1, #+117]
   \   0000000A   0x180D             ADDS     R5,R1,R0
    598            int8u leadingQuote = (argNum < 0 ? 0 : 1);
   \   0000000C   0x43C6             MVNS     R6,R0
    599            if (length != NULL) {
   \   0000000E   0xB12C             CBZ.N    R4,??emberStringCommandArgument_0
    600              *length = tokenLength(tokenNum) - leadingQuote;
   \   00000010   0xB2E8             UXTB     R0,R5
   \   00000012   0x.... 0x....      BL       tokenLength
   \   00000016   0xEBA0 0x70D6      SUB      R0,R0,R6, LSR #+31
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
    601            }
    602            return tokenPointer(tokenNum) + leadingQuote;
   \                     ??emberStringCommandArgument_0: (+1)
   \   0000001C   0xB268             SXTB     R0,R5
   \   0000001E   0x.... 0x....      BL       tokenPointer
   \   00000022   0xEB00 0x70D6      ADD      R0,R0,R6, LSR #+31
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    603          }
    604          

   \                                 In section .text, align 2, keep-with-next
    605          int8u emberCopyStringArgument(int8s argNum, 
    606                                        int8u *destination, 
    607                                        int8u maxLength,
    608                                        boolean leftPad)
    609          {
   \                     emberCopyStringArgument: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x461F             MOV      R7,R3
    610            int8u padLength;
    611            int8u argLength;
    612            int8u *contents = emberStringCommandArgument(argNum, &argLength);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      BL       emberStringCommandArgument
   \   0000000E   0x4605             MOV      R5,R0
    613            if (argLength > maxLength) {
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xBF98             IT       LS 
   \   00000018   0x4630             MOVLS    R0,R6
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    614              argLength = maxLength;
    615            }
    616            padLength = leftPad ? maxLength - argLength : 0;
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xBF1A             ITTE     NE 
   \   00000022   0xF89D 0x0000      LDRBNE   R0,[SP, #+0]
   \   00000026   0x1A36             SUBNE    R6,R6,R0
   \   00000028   0x2600             MOVEQ    R6,#+0
    617            MEMSET(destination, 0, padLength);
   \   0000002A   0xB2F6             UXTB     R6,R6
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       halCommonMemSet
    618            MEMCOPY(destination + padLength, contents, argLength);
   \   00000036   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0x1930             ADDS     R0,R6,R4
   \   0000003E   0x.... 0x....      BL       halCommonMemCopy
    619            return argLength;
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    620          }
    621          
    622          #if !defined(EMBER_APPLICATION_HAS_COMMAND_ACTION_HANDLER)
    623          void emberCommandActionHandler(const CommandAction action)
    624          {
    625            (*action)();
    626          }
    627          #endif
    628          
    629          #if !defined(EMBER_APPLICATION_HAS_COMMAND_ERROR_HANDLER)

   \                                 In section .data, align 4
    630          PGM_NO_CONST PGM_P emberCommandErrorNames[] =
   \                     emberCommandErrorNames:
   \   00000000   0x........         DC32 ?_0, ?_1, ?_2, ?_3, ?_4, ?_5, ?_6, ?_7
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
    631            {
    632              "",
    633              "Serial port error",
    634              "No such command",
    635              "Wrong number of args",
    636              "Arg out of range",
    637              "Arg syntax error",
    638              "Too long",
    639              "Bad arg type"
    640            };
    641          
    642          

   \                                 In section .text, align 2, keep-with-next
    643          static void printCommandUsage(boolean singleCommandUsage,
    644                                        EmberCommandEntry *entry) 
    645          {
   \                     printCommandUsage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    646            PGM_P arg = entry->argumentTypes;
   \   00000006   0x68AE             LDR      R6,[R5, #+8]
    647            emberSerialPrintf(APP_SERIAL, "%p", entry->name);
   \   00000008   0x682A             LDR      R2,[R5, #+0]
   \   0000000A   0x....             ADR.N    R1,??DataTable38  ;; 0x25, 0x70, 0x00, 0x00
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       emberSerialPrintf
    648          
    649            if ( entry -> action == NULL ) {
   \   00000012   0x6868             LDR      R0,[R5, #+4]
   \   00000014   0x....             ADR.N    R7,??DataTable38_1  ;; ""
   \   00000016   0xB918             CBNZ.N   R0,??printCommandUsage_0
    650              emberSerialPrintf(APP_SERIAL, "...");
   \   00000018   0x....             ADR.N    R1,??DataTable38_2  ;; "..."
   \   0000001A   0x.... 0x....      BL       emberSerialPrintf
   \   0000001E   0xE02C             B.N      ??printCommandUsage_1
    651            } else if (singleCommandUsage) {
   \                     ??printCommandUsage_0: (+1)
   \   00000020   0xB91C             CBNZ.N   R4,??printCommandUsage_2
   \   00000022   0xE02A             B.N      ??printCommandUsage_1
    652              int8u argumentIndex = 0;
    653              printIfEntryHasDescription(entry, " (args) \n");
    654              while (*arg) {
    655                int8u c = *arg;
    656                printIfEntryHasArgumentDescriptions(entry,
    657                                                    "  ");
    658                emberSerialPrintf(APP_SERIAL,
    659                                  (c == 'u' ? " <int8u>"
    660                                   : c == 'v' ? " <int16u>"
    661                                   : c == 'w' ? " <int32u>"
    662                                   : c == 's' ? " <int8s>"
    663                                   : c == 'b' ? " <string>"
    664                                   : c == 'n' ? " ..."
    665                                   : c == '*' ? " *"
    666                                   : " ?"));
   \                     ??printCommandUsage_3: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine2
    667                printIfEntryHasArgumentDescriptions(entry,
    668                                                    "  %p\n",
    669                                                    entry->argumentDescriptions[argumentIndex]);
    670                argumentIndex++;
    671                arg += 1;
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \                     ??printCommandUsage_2: (+1)
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0xB310             CBZ.N    R0,??printCommandUsage_4
   \   0000002E   0x2875             CMP      R0,#+117
   \   00000030   0xBF08             IT       EQ 
   \   00000032   0x.... 0x....      ADREQ.W  R1,?_12
   \   00000036   0xD0F5             BEQ.N    ??printCommandUsage_3
   \   00000038   0x2876             CMP      R0,#+118
   \   0000003A   0xBF08             IT       EQ 
   \   0000003C   0x.... 0x....      ADREQ.W  R1,?_13
   \   00000040   0xD0F0             BEQ.N    ??printCommandUsage_3
   \   00000042   0x2877             CMP      R0,#+119
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x.... 0x....      ADREQ.W  R1,?_14
   \   0000004A   0xD0EB             BEQ.N    ??printCommandUsage_3
   \   0000004C   0x2873             CMP      R0,#+115
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x.... 0x....      ADREQ.W  R1,?_15
   \   00000054   0xD0E6             BEQ.N    ??printCommandUsage_3
   \   00000056   0x2862             CMP      R0,#+98
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0x.... 0x....      ADREQ.W  R1,?_16
   \   0000005E   0xD0E1             BEQ.N    ??printCommandUsage_3
   \   00000060   0x286E             CMP      R0,#+110
   \   00000062   0xBF08             IT       EQ 
   \   00000064   0x.... 0x....      ADREQ.W  R1,?_17
   \   00000068   0xD0DC             BEQ.N    ??printCommandUsage_3
   \   0000006A   0x282A             CMP      R0,#+42
   \   0000006C   0xBF0C             ITE      EQ 
   \   0000006E   0x....             ADREQ.N  R1,??DataTable38_3  ;; 0x20, 0x2A, 0x00, 0x00
   \   00000070   0x....             ADRNE.N  R1,??DataTable38_4  ;; 0x20, 0x3F, 0x00, 0x00
   \   00000072   0xE7D7             B.N      ??printCommandUsage_3
    672              }
    673              emberSerialPrintfLine(APP_SERIAL, "");
   \                     ??printCommandUsage_4: (+1)
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0x.... 0x....      BL       emberSerialPrintfLine
    674            }
    675            emberSerialWaitSend(APP_SERIAL);
   \                     ??printCommandUsage_1: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      BL       emberSerialWaitSend
    676            printIfEntryHasDescription(entry, " - %p", entry->description);
    677            
    678            emberSerialPrintfLine(APP_SERIAL, "");
   \   00000080   0x4639             MOV      R1,R7
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       emberSerialPrintfLine
    679            emberSerialWaitSend(APP_SERIAL);
   \   00000088   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000008C   0x....             B.N      ?Subroutine1
    680          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      emberSerialPrintf

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      emberSerialWaitSend
    681          

   \                                 In section .text, align 2, keep-with-next
    682          void emberPrintCommandUsage(EmberCommandEntry *entry)
    683          {
   \                     emberPrintCommandUsage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    684            EmberCommandEntry *commandFinger;
    685            printCommandUsage(TRUE,
    686                              entry);
   \   00000006   0x4621             MOV      R1,R4
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       printCommandUsage
    687          
    688            if ( getNestedCommand(entry, &commandFinger) ) {
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       getNestedCommand
   \   00000016   0xB950             CBNZ.N   R0,??emberPrintCommandUsage_0
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}
    689              for (; commandFinger->name != NULL; commandFinger++) {
    690                emberSerialPrintf(APP_SERIAL, "  ");
   \                     ??emberPrintCommandUsage_1: (+1)
   \   0000001A   0x....             ADR.N    R1,??DataTable38_5  ;; 0x20, 0x20, 0x00, 0x00
   \   0000001C   0x.... 0x....      BL       ?Subroutine2
    691                printCommandUsage(FALSE,
    692                                  commandFinger);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       printCommandUsage
    693              }   
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x300C             ADDS     R0,R0,#+12
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \                     ??emberPrintCommandUsage_0: (+1)
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1F1             BNE.N    ??emberPrintCommandUsage_1
    694            }
    695          }
   \   00000036   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    696          

   \                                 In section .text, align 2, keep-with-next
    697          void emberPrintCommandUsageNotes(void)
    698          {
   \                     emberPrintCommandUsageNotes: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    699            emberSerialPrintf(APP_SERIAL, 
    700                              "Usage:\r\n"
    701                              "<int>: 123 or 0x1ABC\r\n"
    702                              "<string>: \"foo\" or {0A 1B 2C}\r\n\r\n");
   \   00000002   0x.... 0x....      ADR.W    R1,?_21
   \   00000006   0x.... 0x....      BL       ?Subroutine2
    703            emberSerialWaitSend(APP_SERIAL);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E                      REQUIRE ?Subroutine1
   \   0000000E                      ;; // Fall through to label ?Subroutine1
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          void emberPrintCommandTable(void)
    707          {
   \                     emberPrintCommandTable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    708            EmberCommandEntry *commandFinger = emberCommandTable;
    709            emberPrintCommandUsageNotes();
   \   00000002   0x.... 0x....      BL       emberPrintCommandUsageNotes
   \   00000006   0x....             LDR.N    R4,??DataTable38_12
   \   00000008   0xE004             B.N      ??emberPrintCommandTable_0
    710            for (; commandFinger->name != NULL; commandFinger++) {
    711              printCommandUsage(FALSE, commandFinger);
   \                     ??emberPrintCommandTable_1: (+1)
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       printCommandUsage
    712            }
   \   00000012   0x340C             ADDS     R4,R4,#+12
   \                     ??emberPrintCommandTable_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F7             BNE.N    ??emberPrintCommandTable_1
    713          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    714          

   \                                 In section .text, align 2, keep-with-next
    715          void emberCommandErrorHandler(EmberCommandStatus status)
    716          {
   \                     emberCommandErrorHandler: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    717            emberSerialPrintf(APP_SERIAL, "%p\r\n", emberCommandErrorNames[status]);
   \   00000004   0x....             LDR.N    R1,??DataTable38_15
   \   00000006   0x....             LDR.N    R4,??DataTable38_10
   \   00000008   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   0000000C   0x.... 0x....      ADR.W    R1,?_22
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       emberSerialPrintf
    718          
    719            if (emberCurrentCommand == NULL) {
   \   00000016   0x6FA0             LDR      R0,[R4, #+120]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xBF04             ITT      EQ 
    720              emberPrintCommandTable();
   \   0000001C   0xE8BD 0x43F1      POPEQ    {R0,R4-R9,LR}
   \   00000020   0x.... 0x....      BEQ.W    emberPrintCommandTable
    721            } else {
    722              int8u *finger;
    723              int8u tokenNum, i;
    724              emberPrintCommandUsageNotes();
   \   00000024   0x.... 0x....      BL       emberPrintCommandUsageNotes
    725              // Reconstruct any parent commands from the buffer.
    726              for (tokenNum = 0; tokenNum < commandState.argOffset - 1; tokenNum++) {
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0x....             ADR.N    R6,??DataTable38_6  ;; " "
   \   0000002C   0x.... 0x....      ADR.W    R9,??DataTable38_7  ;; 0x25, 0x63, 0x00, 0x00
   \   00000030   0xE010             B.N      ??emberCommandErrorHandler_0
    727                finger = tokenPointer(tokenNum);
    728                for (i = 0; i < tokenLength(tokenNum); i++) {
    729                  emberSerialPrintf(APP_SERIAL, "%c", finger[i]);
   \                     ??emberCommandErrorHandler_1: (+1)
   \   00000032   0xF817 0x2008      LDRB     R2,[R7, R8]
   \   00000036   0x4649             MOV      R1,R9
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       emberSerialPrintf
    730                }
   \   0000003E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emberCommandErrorHandler_2: (+1)
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       tokenLength
   \   00000046   0xB2FF             UXTB     R7,R7
   \   00000048   0x4287             CMP      R7,R0
   \   0000004A   0xD3F2             BCC.N    ??emberCommandErrorHandler_1
    731                emberSerialPrintf(APP_SERIAL, " ");
   \   0000004C   0x4631             MOV      R1,R6
   \   0000004E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000052   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emberCommandErrorHandler_0: (+1)
   \   00000054   0xF894 0x0075      LDRB     R0,[R4, #+117]
   \   00000058   0xB2ED             UXTB     R5,R5
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0x4285             CMP      R5,R0
   \   0000005E   0xDA05             BGE.N    ??emberCommandErrorHandler_3
   \   00000060   0xB268             SXTB     R0,R5
   \   00000062   0x.... 0x....      BL       tokenPointer
   \   00000066   0x4680             MOV      R8,R0
   \   00000068   0x2700             MOVS     R7,#+0
   \   0000006A   0xE7E9             B.N      ??emberCommandErrorHandler_2
    732              }
    733              emberPrintCommandUsage(emberCurrentCommand);
   \                     ??emberCommandErrorHandler_3: (+1)
   \   0000006C   0x6FA0             LDR      R0,[R4, #+120]
   \   0000006E   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000072   0x....             B.N      emberPrintCommandUsage
    734            }
    735          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x25 0x70          DC8      0x25, 0x70, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x2E 0x2E          DC8      "..."
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x20 0x2A          DC8      0x20, 0x2A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \   00000000   0x20 0x3F          DC8      0x20, 0x3F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \   00000000   0x20 0x20          DC8      0x20, 0x20, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \   00000000   0x25 0x63          DC8      0x25, 0x63, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_8:
   \   00000000   0x........         DC32     defaultBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_9:
   \   00000000   0x........         DC32     commandState+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_10:
   \   00000000   0x........         DC32     commandState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_11:
   \   00000000   0x........         DC32     previousCharacter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_12:
   \   00000000   0x........         DC32     emberCommandTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_13:
   \   00000000   0x........         DC32     commandState+0x71

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_14:
   \   00000000   0x........         DC32     emberCommandInterpreter2Configuration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_15:
   \   00000000   0x........         DC32     emberCommandErrorNames

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x20 0x3C          DC8 " <int8u>"
   \              0x69 0x6E    
   \              0x74 0x38    
   \              0x75 0x3E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x20 0x3C          DC8 " <int16u>"
   \              0x69 0x6E    
   \              0x74 0x31    
   \              0x36 0x75    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x20 0x3C          DC8 " <int32u>"
   \              0x69 0x6E    
   \              0x74 0x33    
   \              0x32 0x75    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x20 0x3C          DC8 " <int8s>"
   \              0x69 0x6E    
   \              0x74 0x38    
   \              0x73 0x3E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x20 0x3C          DC8 " <string>"
   \              0x73 0x74    
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x20 0x2E          DC8 " ..."
   \              0x2E 0x2E    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_0:
   \   00000000   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x53 0x65          DC8 "Serial port error"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x70    
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x4E 0x6F          DC8 "No such command"
   \              0x20 0x73    
   \              0x75 0x63    
   \              0x68 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x55 0x73          DC8 55H, 73H, 61H, 67H, 65H, 3AH, 0DH, 0AH
   \              0x61 0x67    
   \              0x65 0x3A    
   \              0x0D 0x0A    
   \   00000008   0x3C 0x69          DC8 3CH, 69H, 6EH, 74H, 3EH, 3AH, 20H, 31H
   \              0x6E 0x74    
   \              0x3E 0x3A    
   \              0x20 0x31    
   \   00000010   0x32 0x33          DC8 32H, 33H, 20H, 6FH, 72H, 20H, 30H, 78H
   \              0x20 0x6F    
   \              0x72 0x20    
   \              0x30 0x78    
   \   00000018   0x31 0x41          DC8 31H, 41H, 42H, 43H, 0DH, 0AH, 3CH, 73H
   \              0x42 0x43    
   \              0x0D 0x0A    
   \              0x3C 0x73    
   \   00000020   0x74 0x72          DC8 74H, 72H, 69H, 6EH, 67H, 3EH, 3AH, 20H
   \              0x69 0x6E    
   \              0x67 0x3E    
   \              0x3A 0x20    
   \   00000028   0x22 0x66          DC8 22H, 66H, 6FH, 6FH, 22H, 20H, 6FH, 72H
   \              0x6F 0x6F    
   \              0x22 0x20    
   \              0x6F 0x72    
   \   00000030   0x20 0x7B          DC8 20H, 7BH, 30H, 41H, 20H, 31H, 42H, 20H
   \              0x30 0x41    
   \              0x20 0x31    
   \              0x42 0x20    
   \   00000038   0x32 0x43          DC8 32H, 43H, 7DH, 0DH, 0AH, 0DH, 0AH, 0
   \              0x7D 0x0D    
   \              0x0A 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x25 0x70          DC8 "%p\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x57 0x72          DC8 "Wrong number of args"
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x61 0x72    
   \              0x67 0x73    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x41 0x72          DC8 "Arg out of range"
   \              0x67 0x20    
   \              0x6F 0x75    
   \              0x74 0x20    
   \              0x6F 0x66    
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x41 0x72          DC8 "Arg syntax error"
   \              0x67 0x20    
   \              0x73 0x79    
   \              0x6E 0x74    
   \              0x61 0x78    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x54 0x6F          DC8 "Too long"
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x42 0x61          DC8 "Bad arg type"
   \              0x64 0x20    
   \              0x61 0x72    
   \              0x67 0x20    
   \              0x74 0x79    
   \              0x70 0x65    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_8:
   \   00000000   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x25 0x70          DC8 "%p"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x2E 0x2E          DC8 "..."
   \              0x2E 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x20 0x2A          DC8 " *"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x20 0x3F          DC8 " ?"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_20:
   \   00000000   0x20 0x20          DC8 "  "
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x25 0x63          DC8 "%c"
   \              0x00         
   \   00000003   0x00               DC8 0
    736          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   callCommandAction
        48   -> charDowncase
        48   -> emberCommandActionHandler
        48   -> emberCommandErrorHandler
        48   -> emberCommandReaderInit
        48   -> emberSerialPrintf
        48   -> emberSerialWriteData
        48   -> firstByteOfArg
        48   -> getNestedCommand
        48   -> stringToUnsignedInt
        48   -> tokenLength
        48   -> tokenPointer
       0   charDowncase
       0   emberCommandArgumentCount
       0   emberCommandClearBuffer
         0   -> halCommonMemSet
      32   emberCommandErrorHandler
        32   -> emberPrintCommandTable
         0   -> emberPrintCommandUsage
        32   -> emberPrintCommandUsageNotes
        32   -> emberSerialPrintf
        32   -> tokenLength
        32   -> tokenPointer
       0   emberCommandName
       0   emberCommandReaderInit
       0   emberCommandReaderSetDefaultBase
      24   emberCopyStringArgument
        24   -> emberStringCommandArgument
        24   -> halCommonMemCopy
        24   -> halCommonMemSet
       8   emberPrintCommandTable
         8   -> emberPrintCommandUsageNotes
         8   -> printCommandUsage
      16   emberPrintCommandUsage
        16   -> emberSerialPrintf
        16   -> getNestedCommand
        16   -> printCommandUsage
       8   emberPrintCommandUsageNotes
         8   -> emberSerialPrintf
         0   -> emberSerialWaitSend
      40   emberProcessCommandString
        40   -> callCommandAction
        40   -> charDowncase
        40   -> emberCommandErrorHandler
        40   -> emberCommandReaderInit
        40   -> emberSerialReadByte
        40   -> hexToInt
      16   emberSignedCommandArgument
        16   -> firstByteOfArg
        16   -> stringToUnsignedInt
      16   emberStringCommandArgument
        16   -> tokenLength
        16   -> tokenPointer
       0   emberUnsignedCommandArgument
         0   -> stringToUnsignedInt
       0   firstByteOfArg
       0   getNestedCommand
       0   hexToInt
      24   printCommandUsage
        24   -> emberSerialPrintf
        24   -> emberSerialPrintfLine
         0   -> emberSerialWaitSend
        24   -> emberSerialWaitSend
      32   stringToUnsignedInt
        32   -> hexToInt
        32   -> tokenLength
       0   tokenLength
       0   tokenPointer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_10
       4  ??DataTable38_11
       4  ??DataTable38_12
       4  ??DataTable38_13
       4  ??DataTable38_14
       4  ??DataTable38_15
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable38_8
       4  ??DataTable38_9
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       1  ?_0
      20  ?_1
       4  ?_10
       4  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
       8  ?_17
       4  ?_18
       4  ?_19
      16  ?_2
       4  ?_20
      64  ?_21
       8  ?_22
       4  ?_23
      24  ?_3
      20  ?_4
      20  ?_5
      12  ?_6
      16  ?_7
       2  ?_8
       4  ?_9
     448  callCommandAction
      14  charDowncase
     124  commandState
          emberCurrentCommand
       1  defaultBase
       6  emberCommandArgumentCount
      12  emberCommandClearBuffer
     116  emberCommandErrorHandler
      32  emberCommandErrorNames
       1  emberCommandInterpreter2Configuration
      10  emberCommandName
      34  emberCommandReaderInit
       8  emberCommandReaderSetDefaultBase
      72  emberCopyStringArgument
      28  emberPrintCommandTable
      56  emberPrintCommandUsage
      14  emberPrintCommandUsageNotes
     366  emberProcessCommandString
      34  emberSignedCommandArgument
      40  emberStringCommandArgument
       4  emberUnsignedCommandArgument
      24  firstByteOfArg
      28  getNestedCommand
      30  hexToInt
       1  previousCharacter
     142  printCommandUsage
     120  stringToUnsignedInt
      14  tokenLength
      16  tokenPointer

 
   126 bytes in section .bss
    33 bytes in section .data
   159 bytes in section .rodata
 1 866 bytes in section .text
 
 1 866 bytes of CODE  memory
   159 bytes of CONST memory
   159 bytes of DATA  memory

Errors: none
Warnings: none
