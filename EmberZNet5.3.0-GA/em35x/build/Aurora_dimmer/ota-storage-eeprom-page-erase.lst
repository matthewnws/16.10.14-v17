###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:34:24
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple-eeprom\ota-storage-eeprom-page-erase.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple-eeprom\ota-storage-eeprom-page-erase.c"
#        -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"ota-storage-eeprom-page-erase.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple-eeprom\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\ota-storage-eeprom-page-erase.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\ota-storage-eeprom-page-erase.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\ota-storage-simple-eeprom\ota-storage-eeprom-page-erase.c
      1          // *****************************************************************************
      2          // * ota-storage-eeprom-driver-page-erase.c
      3          // *
      4          // * This code is intended for EEPROM devices that do not support 
      5          // * read-modify-write and must perform a page erase prior to writing data.
      6          // * 
      7          // * Copyright 2012 by Ember Corporation. All rights reserved.              *80*
      8          // *****************************************************************************
      9          
     10          #include "app/framework/include/af.h"
     11          
     12          #include "app/framework/plugin/ota-common/ota.h"
     13          #include "app/framework/plugin/ota-storage-common/ota-storage.h"
     14          #include "app/framework/plugin/ota-client/ota-client.h"
     15          #include "app/framework/plugin/eeprom/eeprom.h"
     16          
     17          //#define DEBUG_PRINT
     18          #define OTA_STORAGE_EEPROM_INTERNAL_HEADER
     19          #include "ota-storage-eeprom.h"
     20          #undef OTA_STORAGE_EEPROM_INTERNAL_HEADER
     21          
     22          #if !defined(EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_READ_MODIFY_WRITE_SUPPORT)
     23          
     24          #if defined(EMBER_TEST)
     25          #include "hal/micro/unix/simulation/fake-eeprom.h"
     26          #endif
     27          
     28          //------------------------------------------------------------------------------
     29          // Globals
     30          

   \                                 In section .data, align 4
     31          static int32s lastRecordedByteMaskIndex = -1;
     32          static boolean lastRecordedByteMaskIndexKnown = FALSE;
   \                     lastRecordedByteMaskIndexKnown:
   \   00000000   0x00               DC8 0
   \   00000001   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000004   0xFFFFFFFF         DC32 -1
     33          

   \                                 In section .bss, align 4
     34          static int32u currentEraseOffset;
     35          static int32u endEraseOffset;
     36          static boolean newEraseOperation;
   \                     newEraseOperation:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 4
   \   00000008                      DS8 4
     37          
     38          static EmberAfEventSleepControl storedSleepControl;
     39          
     40          // this arbitrary size is to limit the amount we store on the call stack
     41          #define BYTE_MASK_READ_SIZE 20
     42          
     43          //------------------------------------------------------------------------------
     44          // Forward declarations
     45          
     46          #define startEraseOperation(begin, end) \
     47            eraseOperation(TRUE, /* start new erase? */ \
     48                           (begin),                     \
     49                           (end))
     50          
     51          #define continueEraseOperation() \
     52            eraseOperation(FALSE,   /* start new erase?       */                \
     53                           0,       /* begin offset (ignored) */                \
     54                           0)       /* end offset (ignored)   */                \
     55          
     56          //------------------------------------------------------------------------------
     57          
     58          // We want to get the log(2, PAGE_SIZE) so that we can use bitwise shifts
     59          // instead of multiple and divide for various page size related operations.
     60          // For the xap, 32-bit divide/modulus requires a software library and eats up
     61          // a lot of flash.

   \                                 In section .text, align 2, keep-with-next
     62          static int8u determinePageSizeLog(void)
     63          {
   \                     determinePageSizeLog: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     64            int8u pageSizeLog;
     65            for (pageSizeLog = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE000             B.N      ??determinePageSizeLog_0
     66                 (1 << pageSizeLog) < (emberAfPluginEepromInfo()->pageSize); 
     67                 pageSizeLog++) {
   \                     ??determinePageSizeLog_1: (+1)
   \   00000006   0x1C64             ADDS     R4,R4,#+1
   \                     ??determinePageSizeLog_0: (+1)
   \   00000008   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x40A1             LSLS     R1,R1,R4
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD3F7             BCC.N    ??determinePageSizeLog_1
     68            }
     69            //  debugPrint("PageSizeLog: %d", pageSizeLog);
     70            return pageSizeLog;
   \   00000016   0xB2E0             UXTB     R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          static boolean checkDelay(boolean mustSetTimer)
     74          {
   \                     checkDelay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     75            if (emberAfPluginEepromBusy() || mustSetTimer) {
   \   00000004   0x.... 0x....      BL       emberAfPluginEepromBusy
   \   00000008   0x4320             ORRS     R0,R4,R0
   \   0000000A   0xD009             BEQ.N    ??checkDelay_0
     76              int32u delay = emberAfPluginEepromInfo()->pageEraseMs >> 2;
   \   0000000C   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   00000010   0x8880             LDRH     R0,[R0, #+4]
   \   00000012   0x0881             LSRS     R1,R0,#+2
     77              if (delay == 0) {
   \   00000014   0xBF08             IT       EQ 
   \   00000016   0x2101             MOVEQ    R1,#+1
     78                delay = 1;
     79              }
     80              debugPrint("Waiting %d ms for erase to complete.", delay);
     81              emberAfEventControlSetDelay(&emberAfPluginOtaStorageSimpleEepromPageEraseEventControl,
     82                                          delay);
   \   00000018   0x....             LDR.N    R0,??DataTable12
   \   0000001A   0x.... 0x....      BL       emberAfEventControlSetDelay
     83              return TRUE;
   \   0000001E   0x2001             MOVS     R0,#+1
     84            }
     85          
     86            return FALSE;
   \                     ??checkDelay_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     87          }
     88          
     89          // Returns TRUE for success (erase operation continuing or completed)
     90          // Returns FALSE for error (erase not started).

   \                                 In section .text, align 2, keep-with-next
     91          static boolean eraseOperation(boolean startNewErase,
     92                                        int32u beginOffset,
     93                                        int32u endOffset)
     94          {
   \                     eraseOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     95            boolean success = TRUE;
   \   00000002   0x2501             MOVS     R5,#+1
     96          
     97            EMBER_TEST_ASSERT(!startNewErase
     98                              || (startNewErase
     99                                  && emberAfPluginOtaStorageSimpleEepromPageEraseEventControl.status == EMBER_EVENT_INACTIVE));
    100          
    101            // In case the first time we are called the EEPROM is busy,
    102            // we will delay.  However we haven't erased the first page
    103            // yet so we must take care not to increment the offset yet.
    104          
    105            if (startNewErase) {
   \   00000004   0x....             LDR.N    R4,??DataTable12_1
   \   00000006   0xB178             CBZ.N    R0,??eraseOperation_0
    106              newEraseOperation = TRUE;
    107              currentEraseOffset = beginOffset;
    108              endEraseOffset = endOffset;
   \   00000008   0x60A2             STR      R2,[R4, #+8]
   \   0000000A   0x6061             STR      R1,[R4, #+4]
    109              otaPrintln("Starting erase from offset 0x%4X to 0x%4X",
    110                         beginOffset,
    111                         endEraseOffset);
   \   0000000C   0x4613             MOV      R3,R2
   \   0000000E   0x460A             MOV      R2,R1
   \   00000010   0x7025             STRB     R5,[R4, #+0]
   \   00000012   0x2040             MOVS     R0,#+64
   \   00000014   0x.... 0x....      ADR.W    R1,?_0
   \   00000018   0x.... 0x....      BL       emberAfPrintln
    112              storedSleepControl = emberAfGetDefaultSleepControlCallback();
   \   0000001C   0x.... 0x....      BL       emberAfGetDefaultSleepControlCallback
   \   00000020   0x7060             STRB     R0,[R4, #+1]
    113              emberAfSetDefaultSleepControlCallback(EMBER_AF_STAY_AWAKE);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       emberAfSetDefaultSleepControlCallback
    114            }
    115          
    116            if (checkDelay(FALSE)) {  // must set timer?
   \                     ??eraseOperation_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       checkDelay
   \   0000002E   0xB9B0             CBNZ.N   R0,??eraseOperation_1
    117              return TRUE;
    118            }
    119          
    120            if (!newEraseOperation) {
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0xB928             CBNZ.N   R0,??eraseOperation_2
    121              currentEraseOffset += emberAfPluginEepromInfo()->pageSize;
   \   00000034   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x1840             ADDS     R0,R0,R1
   \   0000003E   0x6060             STR      R0,[R4, #+4]
    122            }
    123          
    124            if (currentEraseOffset < endEraseOffset) {
   \                     ??eraseOperation_2: (+1)
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0x68A1             LDR      R1,[R4, #+8]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD213             BCS.N    ??eraseOperation_3
    125              int8u status;
    126              debugPrint("Erasing page %d of %d",
    127                         (currentEraseOffset >> determinePageSizeLog()) + 1,
    128                         (endEraseOffset >> determinePageSizeLog()));
    129              status = emberAfPluginEepromErase(currentEraseOffset, emberAfPluginEepromInfo()->pageSize);
   \   00000048   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   0000004C   0x6881             LDR      R1,[R0, #+8]
   \   0000004E   0x6860             LDR      R0,[R4, #+4]
   \   00000050   0x.... 0x....      BL       emberAfPluginEepromErase
    130              success = (status == EEPROM_SUCCESS);
   \   00000054   0xB920             CBNZ.N   R0,??eraseOperation_4
   \   00000056   0x7020             STRB     R0,[R4, #+0]
    131              newEraseOperation = FALSE;
    132              if (success) {
    133                checkDelay(TRUE); // must set timer?
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       checkDelay
    134                return TRUE;
   \                     ??eraseOperation_1: (+1)
   \   0000005E   0xE017             B.N      ??eraseOperation_5
    135              }
   \                     ??eraseOperation_4: (+1)
   \   00000060   0x2500             MOVS     R5,#+0
    136              otaPrintln("Could not start ERASE! (0x%X)", status);
   \   00000062   0x4602             MOV      R2,R0
   \   00000064   0x7025             STRB     R5,[R4, #+0]
   \   00000066   0x2040             MOVS     R0,#+64
   \   00000068   0x.... 0x....      ADR.W    R1,?_1
   \   0000006C   0x.... 0x....      BL       emberAfPrintln
    137            }
    138          
    139            emberAfSetDefaultSleepControl(storedSleepControl);
   \                     ??eraseOperation_3: (+1)
   \   00000070   0x7860             LDRB     R0,[R4, #+1]
   \   00000072   0x.... 0x....      BL       emberAfSetDefaultSleepControlCallback
    140          
    141            otaPrintln("EEPROM Erase complete");
   \   00000076   0x.... 0x....      ADR.W    R1,?_2
   \   0000007A   0x2040             MOVS     R0,#+64
   \   0000007C   0x.... 0x....      BL       emberAfPrintln
    142          
    143            if (!emAfOtaStorageCheckDownloadMetaData()) {
   \   00000080   0x.... 0x....      BL       emAfOtaStorageCheckDownloadMetaData
   \   00000084   0xB908             CBNZ.N   R0,??eraseOperation_6
    144              // This was a full erase that wiped the meta-data.
    145              emAfOtaStorageWriteDownloadMetaData();
   \   00000086   0x.... 0x....      BL       emAfOtaStorageWriteDownloadMetaData
    146            }
    147          
    148            emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback(success);
   \                     ??eraseOperation_6: (+1)
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback
    149            return TRUE;
   \                     ??eraseOperation_5: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    150          }
    151          

   \                                 In section .text, align 2, keep-with-next
    152          static boolean isMultipleOfPageSize(int32u address)
    153          {
   \                     isMultipleOfPageSize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    154            int32u pageSizeBits = ((1 << determinePageSizeLog()) - 1);
    155            return ((pageSizeBits & address) == 0);
   \   00000004   0x.... 0x....      BL       determinePageSizeLog
   \   00000008   0x2501             MOVS     R5,#+1
   \   0000000A   0xFA05 0xF000      LSL      R0,R5,R0
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4020             ANDS     R0,R4,R0
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x4180             SBCS     R0,R0,R0
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    156          }
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void emAfOtaStorageEepromInit(void)
    159          {
   \                     emAfOtaStorageEepromInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    160            int16u expectedCapabilities = (EEPROM_CAPABILITIES_PAGE_ERASE_REQD
    161                                           | EEPROM_CAPABILITIES_ERASE_SUPPORTED);
    162            int32u spaceReservedForOta = (EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_STORAGE_END
    163                                          - EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_STORAGE_START);
    164            const HalEepromInformationType *info = emberAfPluginEepromInfo();
   \   00000002   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   00000006   0x0005             MOVS     R5,R0
    165          
    166            // NOTE: if the info pointer is NULL it's a good indicator that your data
    167            // flash isn't properly connected and jumpered in or that your bootloader
    168            // is too old to support EEPROM info.
    169            assert(info != NULL);
   \   00000008   0x.... 0x....      ADR.W    R4,?_3
   \   0000000C   0xD102             BNE.N    ??CrossCallReturnLabel_3
   \   0000000E   0x21A9             MOVS     R1,#+169
   \   00000010   0x.... 0x....      BL       ?Subroutine0
    170            assert(expectedCapabilities
    171                   == (info->capabilitiesMask & expectedCapabilities));
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000014   0x78A8             LDRB     R0,[R5, #+2]
   \   00000016   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD002             BEQ.N    ??CrossCallReturnLabel_2
   \   0000001E   0x21AB             MOVS     R1,#+171
   \   00000020   0x.... 0x....      BL       ?Subroutine0
    172            assert(isMultipleOfPageSize(EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_STORAGE_START));
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       isMultipleOfPageSize
   \   0000002A   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_1
   \   0000002C   0x21AC             MOVS     R1,#+172
   \   0000002E   0x.... 0x....      BL       ?Subroutine0
    173            assert(isMultipleOfPageSize(spaceReservedForOta));
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000032   0xF44F 0x2000      MOV      R0,#+524288
   \   00000036   0x.... 0x....      BL       isMultipleOfPageSize
   \   0000003A   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_0
   \   0000003C   0x21AD             MOVS     R1,#+173
   \   0000003E   0x.... 0x....      BL       ?Subroutine0
    174          
    175            // Need to make sure that the bytemask used to store each
    176            // fully downloaded page is big enough to hold all the pages we have been
    177            // allocated.
    178            assert((MAX_BYTEMASK_LENGTH / emberAfPluginEepromGetWordSize())
    179                   >= (spaceReservedForOta >> determinePageSizeLog()));
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000042   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   00000046   0x4605             MOV      R5,R0
   \   00000048   0x.... 0x....      BL       determinePageSizeLog
   \   0000004C   0xF44F 0x2600      MOV      R6,#+524288
   \   00000050   0xFA26 0xF100      LSR      R1,R6,R0
   \   00000054   0xF44F 0x7000      MOV      R0,#+512
   \   00000058   0xFB90 0xF0F5      SDIV     R0,R0,R5
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD205             BCS.N    ??emAfOtaStorageEepromInit_0
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000066   0x21B3             MOVS     R1,#+179
   \   00000068   0x.... 0x....      B.W      halInternalAssertFailed
    180          }
   \                     ??emAfOtaStorageEepromInit_0: (+1)
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x.... 0x....      B.W      halInternalAssertFailed
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void emberAfPluginOtaStorageSimpleEepromPageEraseEventHandler(void)
    183          {
    184            emberEventControlSetInactive(emberAfPluginOtaStorageSimpleEepromPageEraseEventControl);
   \                     emberAfPluginOtaStorageSimpleEepromPageEraseEventHandler: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable12
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    185            continueEraseOperation();
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x....             B.N      eraseOperation
    186          }
    187          

   \                                 In section .text, align 2, keep-with-next
    188          static int32s getByteMaskIndexFromEeprom(void)
    189          {
   \                     getByteMaskIndexFromEeprom: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    190            int8u byteMask[BYTE_MASK_READ_SIZE];
    191            int32u readOffset = IMAGE_INFO_START + SAVED_DOWNLOAD_OFFSET_INDEX;
    192            int16u byteMaskIndex;
    193            int8u wordSize = emberAfPluginEepromGetWordSize();
   \   00000004   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   00000008   0x....             LDR.N    R5,??DataTable12_2  ;; 0x7fc0e
   \   0000000A   0x4604             MOV      R4,R0
    194          
    195            for (byteMaskIndex = 0; 
   \   0000000C   0x2600             MOVS     R6,#+0
    196                 byteMaskIndex < MAX_BYTEMASK_LENGTH;
    197                 byteMaskIndex += BYTE_MASK_READ_SIZE,
    198                   readOffset  += BYTE_MASK_READ_SIZE) {
    199              int8u i;
    200              int8u status = emberAfPluginEepromRead(readOffset,
    201                                            byteMask,
    202                                            BYTE_MASK_READ_SIZE);
   \                     ??getByteMaskIndexFromEeprom_0: (+1)
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       emberAfPluginEepromRead
    203              debugPrint("Bytemask read status: 0x%X", status);
    204              EMBER_TEST_ASSERT(status == 0);
    205              
    206              if (byteMaskIndex == 0 && byteMask[0] == 0xFF) {
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xBF04             ITT      EQ 
   \   0000001C   0xF89D 0x0000      LDRBEQ   R0,[SP, #+0]
   \   00000020   0x28FF             CMPEQ    R0,#+255
   \   00000022   0xD014             BEQ.N    ??getByteMaskIndexFromEeprom_1
    207                debugFlush();
    208                debugPrint("All bytes in bytemask erased, assuming index of -1");
    209                return -1;
    210              }
    211          
    212              for (i = 0; i < BYTE_MASK_READ_SIZE; i+=wordSize) {
   \   00000024   0x2000             MOVS     R0,#+0
    213                if (byteMask[i] == 0xFF) {
   \                     ??getByteMaskIndexFromEeprom_2: (+1)
   \   00000026   0xA900             ADD      R1,SP,#+0
   \   00000028   0x5C41             LDRB     R1,[R0, R1]
   \   0000002A   0x29FF             CMP      R1,#+255
   \   0000002C   0xD105             BNE.N    ??getByteMaskIndexFromEeprom_3
    214                  int16u index = (byteMaskIndex + i - 1) / wordSize;
    215                  debugPrint("Last Download offset Bytemask index: %d", 
    216                             index);
    217                  return (index);
   \   0000002E   0x1980             ADDS     R0,R0,R6
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   00000036   0xB280             UXTH     R0,R0
   \   00000038   0xE00B             B.N      ??getByteMaskIndexFromEeprom_4
    218                }
    219              }
   \                     ??getByteMaskIndexFromEeprom_3: (+1)
   \   0000003A   0x1820             ADDS     R0,R4,R0
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0x2814             CMP      R0,#+20
   \   00000040   0xDBF1             BLT.N    ??getByteMaskIndexFromEeprom_2
    220            }
   \   00000042   0x3614             ADDS     R6,R6,#+20
   \   00000044   0xB2B6             UXTH     R6,R6
   \   00000046   0x3514             ADDS     R5,R5,#+20
   \   00000048   0xF5B6 0x7F00      CMP      R6,#+512
   \   0000004C   0xDBDF             BLT.N    ??getByteMaskIndexFromEeprom_0
    221            
    222            debugPrint("Error in determining bytemask index, assuming -1");
    223            return -1;
   \                     ??getByteMaskIndexFromEeprom_1: (+1)
   \   0000004E   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??getByteMaskIndexFromEeprom_4: (+1)
   \   00000052   0xB006             ADD      SP,SP,#+24
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    224          }
    225          
    226          // The bytemask notes the real EEPROM offset of the pages that have been fully 
    227          // downloaded.  Each downloaded page is recorded as a 0 byte.  The OTA offset
    228          // is determined based on the SOC_BOOTLOADING_SUPPORT.  In that case the
    229          // first page is considered to be the combination of the portion of the OTA
    230          // image at the bottom of the EEPROM space (the OTA header) and the first
    231          // full flash page at the top of the EEPROM space (the EBL and its data).
    232          // Without SOC bootloading support the OTA offset is equivalent to number
    233          // of EEPROM pages written minus the overhead of the meta-data (namely this
    234          // bytemask and some other data).
    235          static int32u getOffsetFromByteMaskIndex(int32s byteMaskIndex)
    236          {
    237            // To convert to the number of fully written pages from the bytemask index
    238            // we must add 1.
    239            int32s writtenPages = byteMaskIndex + 1;
    240            int32u otaOffset = (((int32u)(writtenPages)) << determinePageSizeLog());
    241          
    242            debugPrint("Unadjusted offset:    0x%4X", otaOffset);
    243          
    244            if (otaOffset != 0) {
    245          #if defined(SOC_BOOTLOADING_SUPPORT)
    246              otaOffset += emAfGetEblStartOffset();
    247          #else
    248              otaOffset -= OTA_HEADER_INDEX;
    249          #endif
    250            }
    251          
    252            debugFlush();
    253            debugPrint("Last OTA Download offset: 0x%4X", otaOffset);
    254            debugFlush();
    255          
    256            return otaOffset;
    257          }
    258          
    259          static int32s getByteMaskIndexFromOtaOffset(int32u otaOffset)
    260          {
    261            int32s adjustment;
    262          
    263          #if defined(SOC_BOOTLOADING_SUPPORT)
    264            adjustment = emAfGetEblStartOffset();
    265          #else
    266            adjustment = 0 - OTA_HEADER_INDEX;
    267          #endif
    268          
    269            // debugPrint("Offset: 0x%4X, Adjustment: 0x%4X, EBL Start Offset: 0x%4X, Page Log: %d, Page Size: %d",
    270            //            otaOffset,
    271            //            adjustment,
    272            //            emAfGetEblStartOffset(),
    273            //            determinePageSizeLog(),
    274            //            emberAfPluginEepromInfo()->pageSize);
    275          
    276            if (otaOffset < (emberAfPluginEepromInfo()->pageSize + adjustment)) {
    277              return -1;
    278            }
    279          
    280            return (((otaOffset + adjustment) >> determinePageSizeLog()) - 1);
    281          }
    282          

   \                                 In section .text, align 2, keep-with-next
    283          void emAfStorageEepromUpdateDownloadOffset(int32u otaOffsetNew, boolean finalOffset)
    284          {
   \                     emAfStorageEepromUpdateDownloadOffset: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    285            int32s byteMaskIndexNew = getByteMaskIndexFromOtaOffset(otaOffsetNew);
   \   00000008   0x.... 0x....      BL       emAfGetEblStartOffset
   \   0000000C   0x4606             MOV      R6,R0
   \   0000000E   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x1830             ADDS     R0,R6,R0
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xBF38             IT       CC 
   \   0000001A   0xF04F 0x35FF      MOVCC    R5,#-1
   \   0000001E   0xD305             BCC.N    ??emAfStorageEepromUpdateDownloadOffset_0
   \   00000020   0x.... 0x....      BL       determinePageSizeLog
   \   00000024   0x1975             ADDS     R5,R6,R5
   \   00000026   0xFA25 0xF100      LSR      R1,R5,R0
   \   0000002A   0x1E4D             SUBS     R5,R1,#+1
    286          
    287            // debugPrint("Checking whether to update bytemask, New Offset: 0x%4X, new bytemask index: %d, old bytemask index: %d, final update: %c",
    288            //            otaOffsetNew,
    289            //            byteMaskIndexNew,
    290            //            lastRecordedByteMaskIndex,
    291            //            (finalOffset ? 'y' : 'n'));
    292          
    293            if (finalOffset
    294                && byteMaskIndexNew == lastRecordedByteMaskIndex) {
   \                     ??emAfStorageEepromUpdateDownloadOffset_0: (+1)
   \   0000002C   0x....             LDR.N    R6,??DataTable12_3
   \   0000002E   0x6870             LDR      R0,[R6, #+4]
   \   00000030   0xB114             CBZ.N    R4,??emAfStorageEepromUpdateDownloadOffset_1
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xBF08             IT       EQ 
   \   00000036   0x1C6D             ADDEQ    R5,R5,#+1
    295              byteMaskIndexNew++;
    296            }
    297            
    298            if (byteMaskIndexNew > lastRecordedByteMaskIndex) {
   \                     ??emAfStorageEepromUpdateDownloadOffset_1: (+1)
   \   00000038   0x42A8             CMP      R0,R5
   \   0000003A   0xDA11             BGE.N    ??emAfStorageEepromUpdateDownloadOffset_2
    299              int8u status;
                           ^
Warning[Pe550]: variable "status" was set but never used
    300              int8u byteArray[2] = { 0, 0 };
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    301          
    302              debugFlush();
    303              debugPrint("Writing Last Download offset bytemask, new (old): %d (%d)",
    304                         byteMaskIndexNew,
    305                         lastRecordedByteMaskIndex);
    306              debugFlush();
    307              debugPrint("OTA Offsets, new (old): 0x%4X (0x%4X)",
    308                         otaOffsetNew,
    309                         getOffsetFromByteMaskIndex(lastRecordedByteMaskIndex));
    310              debugFlush();
    311          
    312              status = emberAfPluginEepromWrite((IMAGE_INFO_START
    313                                        + SAVED_DOWNLOAD_OFFSET_INDEX
    314                                        + (byteMaskIndexNew
    315                                           * emberAfPluginEepromGetWordSize())),
    316                                       byteArray,
    317                                       emberAfPluginEepromGetWordSize());
   \   00000042   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   00000046   0x4604             MOV      R4,R0
   \   00000048   0x.... 0x....      BL       emberAfPluginEepromGetWordSize
   \   0000004C   0x....             LDR.N    R3,??DataTable12_2  ;; 0x7fc0e
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   00000056   0x.... 0x....      BL       emberAfPluginEepromWrite
    318              debugPrint("EEPROM Write status: 0x%X", status);
    319              EMBER_TEST_ASSERT(status == 0);
    320          
    321              lastRecordedByteMaskIndex = getByteMaskIndexFromEeprom();
   \   0000005A   0x.... 0x....      BL       getByteMaskIndexFromEeprom
   \   0000005E   0x6070             STR      R0,[R6, #+4]
    322              
    323              EMBER_TEST_ASSERT(lastRecordedByteMaskIndex == byteMaskIndexNew);
    324            }
    325          }
   \                     ??emAfStorageEepromUpdateDownloadOffset_2: (+1)
   \   00000060   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void emAfOtaWipeStorageDevice(void)
   \                     emAfOtaWipeStorageDevice: (+1)
   \   00000000   0xBF00             Nop      
    328          {
    329            emberAfOtaStorageDriverInvalidateImageCallback();  
   \   00000002                      REQUIRE emberAfOtaStorageDriverInvalidateImageCallback
   \   00000002                      ;; // Fall through to label emberAfOtaStorageDriverInvalidateImageCallback
    330          }
    331          

   \                                 In section .text, align 2, keep-with-next
    332          EmberAfOtaStorageStatus emberAfOtaStorageDriverInvalidateImageCallback(void)
    333          {
   \                     emberAfOtaStorageDriverInvalidateImageCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    334            lastRecordedByteMaskIndex = -1;
   \   00000002   0x....             LDR.N    R0,??DataTable12_3
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x6041             STR      R1,[R0, #+4]
    335            lastRecordedByteMaskIndexKnown = FALSE;
    336          
    337            return (startEraseOperation(EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_STORAGE_START,
    338                                        EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_STORAGE_END)
    339                    ? EMBER_AF_OTA_STORAGE_OPERATION_IN_PROGRESS
    340                    : EMBER_AF_OTA_STORAGE_ERROR);
   \   0000000A   0xF44F 0x2200      MOV      R2,#+524288
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       eraseOperation
   \   00000018   0xB108             CBZ.N    R0,??emberAfOtaStorageDriverInvalidateImageCallbac_0
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xBD02             POP      {R1,PC}
   \                     ??emberAfOtaStorageDriverInvalidateImageCallbac_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    341          }
    342          

   \                                 In section .text, align 2, keep-with-next
    343          int32u emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback(void)
    344          {
   \                     emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    345            if (!emAfOtaStorageCheckDownloadMetaData()) {
   \   00000002   0x.... 0x....      BL       emAfOtaStorageCheckDownloadMetaData
   \   00000006   0xB188             CBZ.N    R0,??emberAfOtaStorageDriverRetrieveLastStoredOffs_0
    346              return 0;
    347            }
    348          
    349            // Since retrieving the last download offset from the bytemask
    350            // may involve multiple halEepromRead() calls and this may be slow, 
    351            // we cache the offset.
    352          
    353            if (!lastRecordedByteMaskIndexKnown) {
   \   00000008   0x....             LDR.N    R4,??DataTable12_3
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0xB920             CBNZ.N   R0,??emberAfOtaStorageDriverRetrieveLastStoredOffs_1
    354              lastRecordedByteMaskIndex = getByteMaskIndexFromEeprom();
   \   0000000E   0x.... 0x....      BL       getByteMaskIndexFromEeprom
   \   00000012   0x6060             STR      R0,[R4, #+4]
    355              lastRecordedByteMaskIndexKnown = TRUE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    356            }
    357            return getOffsetFromByteMaskIndex(lastRecordedByteMaskIndex);
   \                     ??emberAfOtaStorageDriverRetrieveLastStoredOffs_1: (+1)
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x1C44             ADDS     R4,R0,#+1
   \   0000001C   0x.... 0x....      BL       determinePageSizeLog
   \   00000020   0x4084             LSLS     R4,R4,R0
   \   00000022   0xD002             BEQ.N    ??emberAfOtaStorageDriverRetrieveLastStoredOffs_2
   \   00000024   0x.... 0x....      BL       emAfGetEblStartOffset
   \   00000028   0x1904             ADDS     R4,R0,R4
   \                     ??emberAfOtaStorageDriverRetrieveLastStoredOffs_2: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \                     ??emberAfOtaStorageDriverRetrieveLastStoredOffs_0: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    358          }
    359          

   \                                 In section .text, align 2, keep-with-next
    360          EmberAfOtaStorageStatus emberAfOtaStorageDriverPrepareToResumeDownloadCallback(void)
    361          {
   \                     emberAfOtaStorageDriverPrepareToResumeDownloadCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    362            int32u pageOffsetStart;
    363            
    364            if (lastRecordedByteMaskIndex < 0) {
   \   00000002   0x....             LDR.N    R4,??DataTable12_3
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD410             BMI.N    ??emberAfOtaStorageDriverPrepareToResumeDownloa_0
    365              return EMBER_AF_OTA_STORAGE_ERROR;
    366            }
    367            
    368            pageOffsetStart = (lastRecordedByteMaskIndex + 1) << determinePageSizeLog();
   \   0000000A   0x.... 0x....      BL       determinePageSizeLog
   \   0000000E   0x6861             LDR      R1,[R4, #+4]
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \   00000012   0xFA01 0xF400      LSL      R4,R1,R0
    369            
    370            return (startEraseOperation(pageOffsetStart,
    371                                        pageOffsetStart + emberAfPluginEepromInfo()->pageSize)
    372                    ? EMBER_AF_OTA_STORAGE_OPERATION_IN_PROGRESS
    373                    : EMBER_AF_OTA_STORAGE_ERROR);
   \   00000016   0x.... 0x....      BL       emberAfPluginEepromInfo
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x1902             ADDS     R2,R0,R4
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       eraseOperation
   \   00000026   0xB108             CBZ.N    R0,??emberAfOtaStorageDriverPrepareToResumeDownloa_0
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xBD10             POP      {R4,PC}
   \                     ??emberAfOtaStorageDriverPrepareToResumeDownloa_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    374          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     emberAfPluginOtaStorageSimpleEepromPageEraseEventControl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     newEraseOperation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x0007FC0E         DC32     0x7fc0e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     lastRecordedByteMaskIndexKnown

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x53 0x74          DC8 "Starting erase from offset 0x%4X to 0x%4X"
   \              0x61 0x72    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x65    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x6F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x34 0x58    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x30 0x78    
   \              0x25 0x34    
   \              0x58 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x43 0x6F          DC8 "Could not start ERASE! (0x%X)"
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x45 0x52    
   \              0x41 0x53    
   \              0x45 0x21    
   \              0x20 0x28    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x29 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x45 0x45          DC8 "EEPROM Erase complete"
   \              0x50 0x52    
   \              0x4F 0x4D    
   \              0x20 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x70 0x6C    
   \              0x65 0x74    
   \              0x65 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x6F 0x74          DC8 "ota-storage-eeprom-page-erase.c"
   \              0x61 0x2D    
   \              0x73 0x74    
   \              0x6F 0x72    
   \              0x61 0x67    
   \              0x65 0x2D    
   \              0x65 0x65    
   \              0x70 0x72    
   \              0x6F 0x6D    
   \              0x2D 0x70    
   \              0x61 0x67    
   \              0x65 0x2D    
   \              0x65 0x72    
   \              0x61 0x73    
   \              0x65 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_4:
   \   00000000   0x00 0x00          DC8 0, 0
    375          
    376          #if defined(DEBUG_PRINT)
    377          void emAfEepromTest(void)
    378          {
    379            // This function works only for blocking IO calls
    380          
    381            int16u page = 0;
    382            int8u writeBuffer[16];
    383            int16u i;
    384            int8u status;
    385          
    386            int16u writes = emberAfPluginEepromInfo()->pageSize / 16;
    387          
    388            status = emberAfPluginEepromErase(page * emberAfPluginEepromInfo()->pageSize,
    389                                              emberAfPluginEepromInfo()->pageSize);
    390            if (status != 0) {
    391              debugPrint("Failed to erase page %d, status: 0x%X", page, status);
    392              return;
    393            }
    394          
    395            debugPrint("Number of writes: %d", writes);
    396          
    397            for (i = 0; i < writes; i++) {
    398              MEMSET(writeBuffer, i, 16);
    399              status = emberAfPluginEepromWrite(page + (i * 16),
    400                                                writeBuffer, 
    401                                                16);
    402              debugPrint("Write address 0x%4X, length %d, status: 0x%X",
    403                         page + i,
    404                         16,
    405                         status);
    406              if (status != 0) {
    407                return;
    408              }
    409            }
    410            debugPrint("All data written successfully.");
    411          }
    412          #endif
    413          
    414          #endif // #if !defined(EMBER_AF_PLUGIN_OTA_STORAGE_SIMPLE_EEPROM_READ_MODIFY_WRITE_SUPPORT)
    415          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   checkDelay
         8   -> emberAfEventControlSetDelay
         8   -> emberAfPluginEepromBusy
         8   -> emberAfPluginEepromInfo
       8   determinePageSizeLog
         8   -> emberAfPluginEepromInfo
      16   emAfOtaStorageEepromInit
        16   -> determinePageSizeLog
        16   -> emberAfPluginEepromGetWordSize
        16   -> emberAfPluginEepromInfo
        16   -> halInternalAssertFailed
        16   -> isMultipleOfPageSize
       0   emAfOtaWipeStorageDevice
         0   -> emberAfOtaStorageDriverInvalidateImageCallback
      24   emAfStorageEepromUpdateDownloadOffset
        24   -> determinePageSizeLog
        24   -> emAfGetEblStartOffset
        24   -> emberAfPluginEepromGetWordSize
        24   -> emberAfPluginEepromInfo
        24   -> emberAfPluginEepromWrite
        24   -> getByteMaskIndexFromEeprom
       8   emberAfOtaStorageDriverInvalidateImageCallback
         8   -> eraseOperation
       8   emberAfOtaStorageDriverPrepareToResumeDownloadCallback
         8   -> determinePageSizeLog
         8   -> emberAfPluginEepromInfo
         8   -> eraseOperation
       8   emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback
         8   -> determinePageSizeLog
         8   -> emAfGetEblStartOffset
         8   -> emAfOtaStorageCheckDownloadMetaData
         8   -> getByteMaskIndexFromEeprom
       0   emberAfPluginOtaStorageSimpleEepromPageEraseEventHandler
         0   -> eraseOperation
      16   eraseOperation
        16   -> checkDelay
        16   -> emAfOtaStorageCheckDownloadMetaData
        16   -> emAfOtaStorageWriteDownloadMetaData
        16   -> emberAfGetDefaultSleepControlCallback
        16   -> emberAfPluginEepromErase
        16   -> emberAfPluginEepromInfo
        16   -> emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback
        16   -> emberAfPrintln
        16   -> emberAfSetDefaultSleepControlCallback
      40   getByteMaskIndexFromEeprom
        40   -> emberAfPluginEepromGetWordSize
        40   -> emberAfPluginEepromRead
      16   isMultipleOfPageSize
        16   -> determinePageSizeLog


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       6  ?Subroutine0
      44  ?_0
      32  ?_1
      24  ?_2
      32  ?_3
       2  ?_4
      34  checkDelay
      26  determinePageSizeLog
     110  emAfOtaStorageEepromInit
       2  emAfOtaWipeStorageDevice
      98  emAfStorageEepromUpdateDownloadOffset
      34  emberAfOtaStorageDriverInvalidateImageCallback
      48  emberAfOtaStorageDriverPrepareToResumeDownloadCallback
      46  emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback
      12  emberAfPluginOtaStorageSimpleEepromPageEraseEventHandler
     148  eraseOperation
      86  getByteMaskIndexFromEeprom
      26  isMultipleOfPageSize
       8  lastRecordedByteMaskIndexKnown
          lastRecordedByteMaskIndex
      12  newEraseOperation
          storedSleepControl
          currentEraseOffset
          endEraseOffset

 
  12 bytes in section .bss
   8 bytes in section .data
   2 bytes in section .rodata
 824 bytes in section .text
 
 824 bytes of CODE  memory
   2 bytes of CONST memory
  20 bytes of DATA  memory

Errors: none
Warnings: 1
