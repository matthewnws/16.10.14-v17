###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        14/Oct/2016  17:33:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-level-control\aurora-level-control.c
#    Command line =  
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-level-control\aurora-level-control.c"
#        -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer_tokens.h\""
#        -D "ZA_GENERATED_HEADER=\"app/builder/Aurora_dimmer/Aurora_dimmer.h\""
#        -D APP_BTL -D "BOARD_HEADER=\"../../../16.10.14
#        v17/EmberZNet5.3.0-GA/em35x/app/builder/Aurora_dimmer/Aurora_dimmer_board.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D CORTEXM3
#        -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/Aurora_dimmer/Aurora_dimmer_endpoint_config.h\""
#        -D "__SOURCEFILE__=\"aurora-level-control.c\"" -lC
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --diag_suppress Pa050 -o
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\"
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-level-control\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\app\framework\include\"
#        -I "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\stack\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\" -I
#        "C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\app\builder\Aurora_dimmer\..\..\..\..\..\..\16.09.23
#        Fixedonoff\EmberZNet5.3.0-GA\em35x\hal\..\" -Ohz --use_c++_inline
#    List file    =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\aurora-level-control.lst
#    Object file  =  
#        C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH
#        ETRX357\16.10.14
#        v17\EmberZNet5.3.0-GA\em35x\build\Aurora_dimmer\aurora-level-control.o
#
###############################################################################

C:\Users\matthew.shing\Documents\Projects\AONE ZigBee Dimmer\AUCH ETRX357\16.10.14 v17\EmberZNet5.3.0-GA\em35x\app\framework\plugin\aurora-level-control\aurora-level-control.c
      1          // *******************************************************************
      2          // * level-control.c
      3          // *
      4          // *
      5          // * Copyright 2012 by Ember Corporation. All rights reserved.              *80*
      6          // *******************************************************************
      7          
      8          // this file contains all the common includes for clusters in the util
      9          #include <string.h>
     10          #include "app/framework/include/af.h"
     11          #include "app/framework/util/attribute-storage.h"
     12          
     13          // clusters specific header
     14          #include "aurora-level-control.h"
     15          
     16          #ifdef EMBER_AF_PLUGIN_SCENES
     17            #include "app/framework/plugin/scenes/scenes.h"
     18          #endif //EMBER_AF_PLUGIN_SCENES
     19          
     20          #ifdef EMBER_AF_PLUGIN_ON_OFF
     21            #include "app/framework/plugin/on-off/on-off.h"
     22          #endif //EMBER_AF_PLUGIN_ON_OFF
     23          
     24          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     25            #include "app/framework/plugin/zll-level-control-server/zll-level-control-server.h"
     26          #endif //EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     27          
     28          #if (EMBER_AF_PLUGIN_LEVEL_CONTROL_RATE == 0)
     29            #define FASTEST_TRANSITION_TIME 0
     30          #else
     31            #define FASTEST_TRANSITION_TIME (MILLISECOND_TICKS_PER_SECOND / EMBER_AF_PLUGIN_LEVEL_CONTROL_RATE)
     32          #endif
     33          
     34          #include "aurora-level-control-hal.h"
     35          #include "../aurora-host-protocol/aurora-host-protocol.h"
     36          #include "../aurora-colour-control/aurora-colour-control.h"
     37          
     38          extern void calculateEventDuration_and_stepSize(int16u transitionTimeMs, int16u amount, int32u* eventDurationMs, int16u* stepSize);
     39          
     40          typedef struct {
     41            boolean active;
     42            int8u commandId;
     43            int8u moveToLevel;
     44            int8u moveMode;
     45            int16u stepSize;
     46            boolean moveToLevelUp; // TRUE for up, FALSE for down
     47            boolean useOnLevel;
     48            int8u onLevel;
     49            int32u eventDuration;
     50            int32u transitionTime;
     51            int32u elapsedTime;
     52          } EmberAfLevelControlState;
     53          

   \                                 In section .bss, align 1
     54          static int8u minLevel;
   \                     minLevel:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
     55          static int8u maxLevel;
     56          

   \                                 In section .bss, align 4
     57          static EmberAfLevelControlState stateTable[EMBER_AF_LEVEL_CONTROL_CLUSTER_SERVER_ENDPOINT_COUNT];
   \                     stateTable:
   \   00000000                      DS8 24
     58          
     59          static EmberAfLevelControlState *emAfGetLevelControlState(int8u endpoint);
     60          static EmberAfStatus emAfLevelControlClusterMoveToLevelHandler(int8u commandId, int8u level, int16u transitionTime);
     61          static EmberAfStatus emAfLevelControlClusterMoveHandler(int8u commandId, int8u moveMode, int8u rate);
     62          static EmberAfStatus emAfLevelControlClusterStepHandler(int8u commandId, int8u stepMode, int8u stepSize, int16u transitionTime);
     63          static EmberAfStatus emAfLevelControlClusterStopHandler(int8u commandId);
     64          
     65          static void setOnOffValue(int8u endpoint, boolean onOff);
     66          

   \                                 In section .text, align 2, keep-with-next
     67          static void emAfActivateLevelControl(EmberAfLevelControlState *state,
     68                                               int8u endpoint) 
     69          {
   \                     emAfActivateLevelControl: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x4608             MOV      R0,R1
     70            state->active = TRUE;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7011             STRB     R1,[R2, #+0]
     71            // schedule the first tick
     72            emberAfScheduleServerTickExtended(endpoint,
     73                                              ZCL_LEVEL_CONTROL_CLUSTER_ID,
     74                                              0,
     75                                              EMBER_AF_LONG_POLL,
     76                                              EMBER_AF_STAY_AWAKE);
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2108             MOVS     R1,#+8
   \   00000014   0x.... 0x....      BL       emberAfScheduleServerTickExtended
     77          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
     78          
     79          static void emAfDeactivateLevelControl(EmberAfLevelControlState *state) 
     80          {
     81            state->active = FALSE;
     82          }
     83          

   \                                 In section .text, align 2, keep-with-next
     84          static EmberAfLevelControlState *emAfGetLevelControlState(int8u endpoint)
     85          {
   \                     emAfGetLevelControlState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     86            int8u ep = emberAfFindClusterServerEndpointIndex(endpoint, ZCL_LEVEL_CONTROL_CLUSTER_ID);
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0x.... 0x....      BL       emberAfFindClusterServerEndpointIndex
     87            return (ep == 0xFF ? NULL : &stateTable[ep]);
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD101             BNE.N    ??emAfGetLevelControlState_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
   \                     ??emAfGetLevelControlState_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000014   0x2218             MOVS     R2,#+24
   \   00000016   0xFB02 0x1000      MLA      R0,R2,R0,R1
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
     88          }
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void emberAfLevelControlClusterServerInitCallback(int8u endpoint)
     91          {
   \                     emberAfLevelControlClusterServerInitCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     92            EmberAfLevelControlState *state = emAfGetLevelControlState(endpoint);
   \   00000002   0x.... 0x....      BL       emAfGetLevelControlState
     93            if (state != NULL) 
   \   00000006   0xB108             CBZ.N    R0,??emberAfLevelControlClusterServerInitCallback_0
     94            {
     95              emAfDeactivateLevelControl(state);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
     96            }
     97          
     98            // Set the min and max levels
     99          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
    100            minLevel = EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER_MINIMUM_LEVEL;
    101            maxLevel = EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER_MAXIMUM_LEVEL;
    102          #else
    103            minLevel = EMBER_AF_PLUGIN_AURORA_LEVEL_CONTROL_MINIMUM_LEVEL;
   \                     ??emberAfLevelControlClusterServerInitCallback_0: (+1)
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    104            maxLevel = EMBER_AF_PLUGIN_AURORA_LEVEL_CONTROL_MAXIMUM_LEVEL;
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x7041             STRB     R1,[R0, #+1]
    105          #endif
    106          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    107          
    108          

   \                                 In section .text, align 4, keep-with-next
    109          void emberAfLevelControlClusterServerTickCallback(int8u endpoint)
    110          {
   \                     emberAfLevelControlClusterServerTickCallback: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
    111            EmberAfLevelControlState *state = emAfGetLevelControlState(endpoint);
   \   00000006   0x.... 0x....      BL       emAfGetLevelControlState
   \   0000000A   0x0006             MOVS     R6,R0
    112            EmberAfStatus status;
    113            int8u currentLevel, setNewLevel;
    114            int16u newLevel;
    115          
    116            if (state == NULL) 
   \   0000000C   0xD04C             BEQ.N    ??CrossCallReturnLabel_23
    117            {
    118              return;
    119            }
    120          
    121            //emberAfDebugPrint("Level control tick\r\n");  
    122              
    123            state->elapsedTime += state->eventDuration;
   \   0000000E   0x68F2             LDR      R2,[R6, #+12]
   \   00000010   0x6970             LDR      R0,[R6, #+20]
   \   00000012   0x1810             ADDS     R0,R2,R0
   \   00000014   0x6170             STR      R0,[R6, #+20]
    124          
    125          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
    126            if (emberAfPluginZllLevelControlServerIgnoreMoveToLevelMoveStepStop(endpoint,
    127                                                                                state->commandId)) 
    128            {
    129              state->active = FALSE;
    130            }
    131          #endif
    132          
    133            if (!state->active) 
   \   00000016   0x7830             LDRB     R0,[R6, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD045             BEQ.N    ??CrossCallReturnLabel_23
    134            {
    135              return;
    136            } 
    137            else 
    138            {
    139              // Reschedule the tick
    140              emberAfScheduleServerTickExtended(endpoint,
    141                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    142                                                state->eventDuration,
    143                                                EMBER_AF_LONG_POLL,
    144                                                EMBER_AF_STAY_AWAKE);
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2108             MOVS     R1,#+8
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       emberAfScheduleServerTickExtended
    145            }
    146          
    147            // Read the attribute; print error message and return if it can't be read
    148            status = emberAfReadServerAttribute(endpoint,
    149                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    150                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    151                                                (int8u *)&currentLevel,
    152                                                sizeof(currentLevel));
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0xAB01             ADD      R3,SP,#+4
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2108             MOVS     R1,#+8
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       emberAfReadServerAttribute
    153            if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \   0000003A   0xB118             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_1
    154            {
    155              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
   \   0000003C   0x4602             MOV      R2,R0
   \   0000003E   0x.... 0x....      ADR.W    R1,?_0
   \   00000042   0xE02F             B.N      ??emberAfLevelControlClusterServerTickCallback_2
    156              return;
    157            }
    158          
    159            // If something goes wrong, we will set the newLevel to the currentLevel
    160            newLevel = currentLevel;
    161          
    162            // Handle actions: move-to-level, move, or step
    163            switch (state->commandId) {
   \                     ??emberAfLevelControlClusterServerTickCallback_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R7,??DataTable25_1
   \   00000048   0x7870             LDRB     R0,[R6, #+1]
   \   0000004A   0x783A             LDRB     R2,[R7, #+0]
   \   0000004C   0xF89D 0x5004      LDRB     R5,[SP, #+4]
   \   00000050   0x2806             CMP      R0,#+6
   \   00000052   0x4611             MOV      R1,R2
   \   00000054   0xD873             BHI.N    ??emberAfLevelControlClusterServerTickCallback_3
   \   00000056   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??emberAfLevelControlClusterServerTickCallback_0:
   \   0000005A   0x04 0x4C          DC8      0x4,0x4C,0x4,0x72
   \              0x04 0x72    
   \   0000005E   0x04 0x4C          DC8      0x4,0x4C,0x4,0x0
   \              0x04 0x00    
    164          
    165              // Step and move-to-level are treated the same
    166            case ZCL_MOVE_TO_LEVEL_COMMAND_ID:
    167            case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID:
    168            case ZCL_STEP_COMMAND_ID:
    169            case ZCL_STEP_WITH_ON_OFF_COMMAND_ID:
    170              {
    171                // Are we at the requested level?
    172                if (currentLevel == state->moveToLevel) 
   \                     ??emberAfLevelControlClusterServerTickCallback_4: (+1)
   \   00000062   0x78B3             LDRB     R3,[R6, #+2]
   \   00000064   0x429D             CMP      R5,R3
   \   00000066   0xD120             BNE.N    ??emberAfLevelControlClusterServerTickCallback_5
    173                {
    174                  // Done; stop moving
    175                  state->elapsedTime = state->transitionTime;
   \   00000068   0x6931             LDR      R1,[R6, #+16]
   \   0000006A   0x6171             STR      R1,[R6, #+20]
    176          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE
    177                  {
    178                    int16u remainingTime = 0;
    179                    status = emberAfWriteServerAttribute(endpoint,
    180                                                         ZCL_LEVEL_CONTROL_CLUSTER_ID,
    181                                                         ZCL_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE_ID,
    182                                                         (int8u *)&remainingTime,
    183                                                         sizeof(remainingTime));
    184                    if (status != EMBER_ZCL_STATUS_SUCCESS) 
    185                    {
    186                      emberAfLevelControlClusterPrintln("ERR: writing remaining time %x", status);
    187                    }
    188                  }
    189          #endif
    190                  emAfDeactivateLevelControl(state);
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x7031             STRB     R1,[R6, #+0]
    191                  if (currentLevel == minLevel) 
   \   00000070   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xD17B             BNE.N    ??emberAfLevelControlClusterServerTickCallback_6
    192                  {
    193                    if (state->commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID
    194                        || state->commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) 
   \   00000078   0x2804             CMP      R0,#+4
   \   0000007A   0xBF18             IT       NE 
   \   0000007C   0x2806             CMPNE    R0,#+6
   \   0000007E   0xD177             BNE.N    ??emberAfLevelControlClusterServerTickCallback_6
    195                    {
    196                      setOnOffValue(endpoint, FALSE);
   \   00000080   0x.... 0x....      BL       ?Subroutine8
    197                      if (state->useOnLevel) 
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000084   0x79F0             LDRB     R0,[R6, #+7]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD072             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_6
    198                      {
    199                        currentLevel = state->onLevel;
   \   0000008A   0x7A30             LDRB     R0,[R6, #+8]
   \   0000008C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    200                        status = emberAfWriteServerAttribute(endpoint,
    201                                                             ZCL_LEVEL_CONTROL_CLUSTER_ID,
    202                                                             ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    203                                                             (int8u *)&currentLevel,
    204                                                             ZCL_INT8U_ATTRIBUTE_TYPE);
   \   00000090   0xAB01             ADD      R3,SP,#+4
   \   00000092   0x2020             MOVS     R0,#+32
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0x.... 0x....      BL       ?Subroutine4
    205                        if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD068             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_6
    206                        {
    207                          emberAfLevelControlClusterPrintln("ERR: writing current level %x",
    208                                                            status);
   \   0000009E   0x4602             MOV      R2,R0
   \   000000A0   0x.... 0x....      ADR.W    R1,?_1
   \                     ??emberAfLevelControlClusterServerTickCallback_2: (+1)
   \   000000A4   0x.... 0x....      BL       ?Subroutine9
    209                          return;
   \                     ??CrossCallReturnLabel_23: (+1)
   \   000000A8   0xBDF7             POP      {R0-R2,R4-R7,PC}
    210                        }
    211                      }
    212                    }
    213                  }
    214                  return;
    215                }
    216                
    217                // adjust by the proper amount, either up or down
    218                if (state->moveToLevelUp) 
   \                     ??emberAfLevelControlClusterServerTickCallback_5: (+1)
   \   000000AA   0x79B2             LDRB     R2,[R6, #+6]
   \   000000AC   0xB18A             CBZ.N    R2,??emberAfLevelControlClusterServerTickCallback_7
    219                {
    220                  // Changing level up... 
    221                  if (state->commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID
    222                      || state->commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) 
   \   000000AE   0x2804             CMP      R0,#+4
   \   000000B0   0xBF18             IT       NE 
   \   000000B2   0x2806             CMPNE    R0,#+6
   \   000000B4   0xD102             BNE.N    ??CrossCallReturnLabel_15
    223                  {
    224                    setOnOffValue(endpoint, TRUE);
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x.... 0x....      BL       ??Subroutine8_0
    225                  }
    226                  if ((state->moveToLevel - currentLevel) < state->stepSize)
   \                     ??CrossCallReturnLabel_15: (+1)
   \   000000BC   0x78B5             LDRB     R5,[R6, #+2]
   \   000000BE   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000C2   0x88B0             LDRH     R0,[R6, #+4]
   \   000000C4   0x1A69             SUBS     R1,R5,R1
   \   000000C6   0x4281             CMP      R1,R0
   \   000000C8   0xDB39             BLT.N    ??emberAfLevelControlClusterServerTickCallback_3
    227                  {
    228                      newLevel = state->moveToLevel;  // prevent +ve overflow.
    229                  }
    230                  else
    231                  {
    232                      newLevel = currentLevel + state->stepSize;
   \   000000CA   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000CE   0x1845             ADDS     R5,R0,R1
   \   000000D0   0xE035             B.N      ??emberAfLevelControlClusterServerTickCallback_3
    233                  }        
    234                } 
    235                else 
    236                {
    237                  // Changing level down...                
    238                  if ((currentLevel - state->moveToLevel) < state->stepSize)
   \                     ??emberAfLevelControlClusterServerTickCallback_7: (+1)
   \   000000D2   0x88B2             LDRH     R2,[R6, #+4]
   \   000000D4   0x1AEE             SUBS     R6,R5,R3
   \   000000D6   0x4296             CMP      R6,R2
   \   000000D8   0xBFB4             ITE      LT 
   \   000000DA   0x461D             MOVLT    R5,R3
   \   000000DC   0x1AAD             SUBGE    R5,R5,R2
    239                  {
    240                      newLevel = state->moveToLevel;  // prevent -ve overflow.
    241                  }
    242                  else
    243                  {
    244                      newLevel = currentLevel - state->stepSize;
    245                  }         
    246                  if (newLevel == minLevel) 
   \   000000DE   0xB2AD             UXTH     R5,R5
   \   000000E0   0x428D             CMP      R5,R1
   \   000000E2   0xD12C             BNE.N    ??emberAfLevelControlClusterServerTickCallback_3
    247                  {
    248                    if (state->commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID
    249                        || state->commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) 
   \   000000E4   0x2804             CMP      R0,#+4
   \   000000E6   0xBF18             IT       NE 
   \   000000E8   0x2806             CMPNE    R0,#+6
   \   000000EA   0xD128             BNE.N    ??emberAfLevelControlClusterServerTickCallback_3
    250                    {
    251                      setOnOffValue(endpoint, FALSE);
   \   000000EC   0x.... 0x....      BL       ?Subroutine8
    252                    }
    253                  }
    254                }
    255                
    256                //emberAfLevelControlClusterPrint("Event: move Level %x->%x ", currentLevel, newLevel);
    257                //emberAfLevelControlClusterPrintln("(diff %p%x)", state->moveToLevelUp ? "+" : "-",  amountToMove);
    258                
    259          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE
    260                {
    261                  int16u remainingTime = ((int16u)(state->transitionTime
    262                                                  - state->elapsedTime)) / 100;
    263                  status = emberAfWriteServerAttribute(endpoint,
    264                                                       ZCL_LEVEL_CONTROL_CLUSTER_ID,
    265                                                       ZCL_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE_ID,
    266                                                       (int8u *)&remainingTime,
    267                                                       sizeof(remainingTime));
    268                  if(status != EMBER_ZCL_STATUS_SUCCESS) 
    269                  {
    270                    emberAfLevelControlClusterPrintln("ERR: writing remaining time %x", status);
    271                  }
    272                }
    273          #endif
    274              }
   \                     ??CrossCallReturnLabel_16: (+1)
   \   000000F0   0xE025             B.N      ??emberAfLevelControlClusterServerTickCallback_3
    275              break;
    276          
    277            case ZCL_MOVE_COMMAND_ID:
    278            case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID:
    279              // adjust either up or down
    280              if (state->moveMode == EMBER_ZCL_MOVE_MODE_UP) 
   \                     ??emberAfLevelControlClusterServerTickCallback_8: (+1)
   \   000000F2   0x78F2             LDRB     R2,[R6, #+3]
   \   000000F4   0xB96A             CBNZ.N   R2,??emberAfLevelControlClusterServerTickCallback_9
    281              {
    282                newLevel++;
   \   000000F6   0x1C6D             ADDS     R5,R5,#+1
    283                if (state->commandId == ZCL_MOVE_WITH_ON_OFF_COMMAND_ID) 
   \   000000F8   0x2805             CMP      R0,#+5
   \   000000FA   0xD102             BNE.N    ??CrossCallReturnLabel_14
    284                {
    285                  setOnOffValue(endpoint, TRUE);
   \   000000FC   0x2101             MOVS     R1,#+1
   \   000000FE   0x.... 0x....      BL       ??Subroutine8_0
    286                }
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000102   0x7878             LDRB     R0,[R7, #+1]
   \   00000104   0xB2AD             UXTH     R5,R5
   \   00000106   0x42A8             CMP      R0,R5
   \   00000108   0xD211             BCS.N    ??emberAfLevelControlClusterServerTickCallback_10
    287                // make sure we dont go over the max
    288                if (newLevel > maxLevel) 
    289                {
    290                  newLevel = maxLevel;
   \   0000010A   0x4605             MOV      R5,R0
    291                  emAfDeactivateLevelControl(state);
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x7030             STRB     R0,[R6, #+0]
    292                }
    293              }
   \   00000110   0xE00D             B.N      ??emberAfLevelControlClusterServerTickCallback_10
    294              else if (state->moveMode == EMBER_ZCL_MOVE_MODE_DOWN) 
   \                     ??emberAfLevelControlClusterServerTickCallback_9: (+1)
   \   00000112   0x2A01             CMP      R2,#+1
   \   00000114   0xD10B             BNE.N    ??emberAfLevelControlClusterServerTickCallback_10
    295              {
    296                newLevel--;
   \   00000116   0x1E6D             SUBS     R5,R5,#+1
    297                // make sure we dont go under 0
    298                // unsigned, the number wraps which means the high byte gets a value
    299                if (HIGH_BYTE(newLevel) > 0) 
   \   00000118   0xB2AD             UXTH     R5,R5
   \   0000011A   0x0A2A             LSRS     R2,R5,#+8
   \   0000011C   0xD007             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_10
    300                {
    301                  newLevel = minLevel;
   \   0000011E   0x460D             MOV      R5,R1
    302                  emAfDeactivateLevelControl(state);
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x7031             STRB     R1,[R6, #+0]
    303                  if (state->commandId == ZCL_MOVE_WITH_ON_OFF_COMMAND_ID) 
   \   00000124   0x2805             CMP      R0,#+5
   \   00000126   0xBF04             ITT      EQ 
    304                  {
    305                    setOnOffValue(endpoint, FALSE);
   \   00000128   0x4620             MOVEQ    R0,R4
   \   0000012A   0x.... 0x....      BLEQ     setOnOffValue
    306                  }
    307                }
    308              }
    309              emberAfLevelControlClusterPrintln("Event: move Level %x->%x", currentLevel, newLevel);
   \                     ??emberAfLevelControlClusterServerTickCallback_10: (+1)
   \   0000012E   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   00000132   0x.... 0x....      ADR.W    R1,?_2
   \   00000136   0x462B             MOV      R3,R5
   \   00000138   0x2020             MOVS     R0,#+32
   \   0000013A   0x.... 0x....      BL       emberAfPrintln
    310              break;
    311            }
    312          
    313            // newLevel is 2 bytes to detect rollover in either direction
    314            // need to make it 1 byte to pass to the write attributes call
    315            setNewLevel = LOW_BYTE(newLevel);
    316           
    317            // set the current level, implement a callback if you want
    318            // hardware action at this point.
    319            status = emberAfWriteServerAttribute(endpoint,
    320                                                 ZCL_LEVEL_CONTROL_CLUSTER_ID,
    321                                                 ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    322                                                 (int8u *)&setNewLevel,
    323                                                 ZCL_INT8U_ATTRIBUTE_TYPE);
   \                     ??emberAfLevelControlClusterServerTickCallback_3: (+1)
   \   0000013E   0x2020             MOVS     R0,#+32
   \   00000140   0x9000             STR      R0,[SP, #+0]
   \   00000142   0xF88D 0x5005      STRB     R5,[SP, #+5]
   \   00000146   0xF10D 0x0305      ADD      R3,SP,#+5
   \   0000014A   0x.... 0x....      BL       ?Subroutine4
    324            if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000014E   0xB120             CBZ.N    R0,??CrossCallReturnLabel_22
    325            {
    326              emberAfLevelControlClusterPrintln("Err: writing current level %x", status);
   \   00000150   0x4602             MOV      R2,R0
   \   00000152   0x.... 0x....      ADR.W    R1,?_3
   \   00000156   0x.... 0x....      BL       ?Subroutine9
    327            }
    328            
    329            emberAfPluginAuroraLevelControlSetNewLevelCallback(newLevel);
   \                     ??CrossCallReturnLabel_22: (+1)
   \   0000015A   0xB2E8             UXTB     R0,R5
   \   0000015C   0x.... 0x....      BL       emberAfPluginAuroraLevelControlSetNewLevelCallback
    330            
    331            // the scene has been changed (the value of level has changed) so
    332            // the current scene as descibed in the attribute table is invalid,
    333            // so mark it as invalid (just writes the valid/invalid attribute)
    334            if (emberAfContainsServer(endpoint, ZCL_SCENES_CLUSTER_ID)) 
   \   00000160   0x2105             MOVS     R1,#+5
   \   00000162   0x4620             MOV      R0,R4
   \   00000164   0x.... 0x....      BL       emberAfContainsServer
   \   00000168   0xB110             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_6
    335            {
    336              emberAfScenesClusterMakeInvalidCallback(endpoint);
   \   0000016A   0x4620             MOV      R0,R4
   \   0000016C   0x.... 0x....      BL       emberAfScenesClusterMakeInvalidCallback
    337            }
    338          }
   \                     ??emberAfLevelControlClusterServerTickCallback_6: (+1)
   \   00000170   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \                     ??Subroutine8_0: (+1)
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      setOnOffValue

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      B.W      emberAfWriteServerAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x2020             MOVS     R0,#+32
   \   00000002   0x.... 0x....      B.W      emberAfPrintln
    339          

   \                                 In section .text, align 2, keep-with-next
    340          static void setOnOffValue(int8u endpoint, boolean onOff)
    341          {   
   \                     setOnOffValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    342            if (emberAfContainsServer(endpoint, ZCL_ON_OFF_CLUSTER_ID)) 
   \   00000006   0x2106             MOVS     R1,#+6
   \   00000008   0x.... 0x....      BL       emberAfContainsServer
   \   0000000C   0xB180             CBZ.N    R0,??setOnOffValue_0
    343            {
    344              emberAfLevelControlClusterPrintln("Setting on/off to %p due to level change",
    345                                                onOff ? "ON" : "OFF");
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xBF14             ITE      NE 
   \   00000012   0x....             ADRNE.N  R2,??DataTable22  ;; 0x4F, 0x4E, 0x00, 0x00
   \   00000014   0x....             ADREQ.N  R2,??DataTable22_1  ;; "OFF"
   \   00000016   0x.... 0x....      ADR.W    R1,?_4
   \   0000001A   0x.... 0x....      BL       ?Subroutine9
    346              emberAfOnOffClusterSetValueCallback(endpoint,
    347                                   (onOff ? ZCL_ON_COMMAND_ID : ZCL_OFF_COMMAND_ID),
    348                                   TRUE); 
   \                     ??CrossCallReturnLabel_21: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x2101             MOVNE    R1,#+1
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x.... 0x....      B.W      emberAfOnOffClusterSetValueCallback
    349            }       
    350          }
   \                     ??setOnOffValue_0: (+1)
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    351          

   \                                 In section .text, align 2, keep-with-next
    352          boolean emberAfLevelControlClusterMoveToLevelCallback(int8u level, int16u transitionTime)
    353          {
   \                     emberAfLevelControlClusterMoveToLevelCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    354              emberAfLevelControlClusterPrintln("%pMOVE_TO_LEVEL %x %2x", "RX level-control:", level, transitionTime);    
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000006   0x.... 0x....      ADR.W    R1,?_7
   \   0000000A   0x.... 0x....      BL       ?Subroutine10
    355              EmberAfStatus status = emAfLevelControlClusterMoveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID, level, transitionTime);    
   \                     ??CrossCallReturnLabel_29: (+1)
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       emAfLevelControlClusterMoveToLevelHandler
    356              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
   \   00000018   0x....             B.N      ??Subroutine13_0
    357              return TRUE;  
    358          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x9500             STR      R5,[SP, #+0]
   \   00000006   0x4623             MOV      R3,R4
   \   00000008   0x.... 0x....      ADR.W    R2,?_8
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \   00000000   0x.... 0x....      BL       emberAfSendImmediateDefaultResponse
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x2020             MOVS     R0,#+32
   \   00000002   0x.... 0x....      B.W      emberAfPrintln
    359          

   \                                 In section .text, align 2, keep-with-next
    360          boolean emberAfLevelControlClusterMoveToLevelWithOnOffCallback(int8u level, int16u transitionTime)
    361          {
   \                     emberAfLevelControlClusterMoveToLevelWithOnOffCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    362              emberAfLevelControlClusterPrintln("%pMOVE_TO_LEVEL_WITH_ON_OFF %x %2x", "RX level-control:", level, transitionTime);  
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000006   0x.... 0x....      ADR.W    R1,?_9
   \   0000000A   0x.... 0x....      BL       ?Subroutine10
    363              EmberAfStatus status = emAfLevelControlClusterMoveToLevelHandler(ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID, level, transitionTime);    
   \                     ??CrossCallReturnLabel_28: (+1)
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x.... 0x....      BL       emAfLevelControlClusterMoveToLevelHandler
    364              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
   \   00000018   0x....             B.N      ??Subroutine13_0
    365              return TRUE;  
    366          }
    367          

   \                                 In section .text, align 2, keep-with-next
    368          boolean emberAfLevelControlClusterMoveCallback(int8u moveMode, int8u rate)
    369          {
   \                     emberAfLevelControlClusterMoveCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    370              emberAfLevelControlClusterPrintln("%pMOVE %x %x", "RX level-control:", moveMode, rate);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000006   0x.... 0x....      ADR.W    R1,?_10
   \   0000000A   0x.... 0x....      BL       ?Subroutine10
    371              EmberAfStatus status = emAfLevelControlClusterMoveHandler(ZCL_MOVE_COMMAND_ID, moveMode, rate);
   \                     ??CrossCallReturnLabel_27: (+1)
   \   0000000E   0x....             B.N      ?Subroutine1
    372              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
    373              return TRUE;
    374          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x462A             MOV      R2,R5
   \   00000002   0x4621             MOV      R1,R4
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       emAfLevelControlClusterMoveHandler
   \   0000000A                      REQUIRE ??Subroutine13_0
   \   0000000A                      ;; // Fall through to label ??Subroutine13_0
    375          

   \                                 In section .text, align 2, keep-with-next
    376          boolean emberAfLevelControlClusterMoveWithOnOffCallback(int8u moveMode, int8u rate)
    377          {
   \                     emberAfLevelControlClusterMoveWithOnOffCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    378              emberAfLevelControlClusterPrintln("%pMOVE_WITH_ON_OFF %x %x", "RX level-control:", moveMode, rate);
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000006   0x.... 0x....      ADR.W    R1,?_11
   \   0000000A   0x.... 0x....      BL       ?Subroutine10
    379              emAfLevelControlClusterMoveHandler(ZCL_MOVE_WITH_ON_OFF_COMMAND_ID, moveMode, rate);
   \                     ??CrossCallReturnLabel_26: (+1)
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x2005             MOVS     R0,#+5
   \   00000014   0x.... 0x....      BL       emAfLevelControlClusterMoveHandler
    380              EmberAfStatus status = emAfLevelControlClusterMoveHandler(ZCL_MOVE_COMMAND_ID, moveMode, rate);
   \   00000018                      REQUIRE ?Subroutine1
   \   00000018                      ;; // Fall through to label ?Subroutine1
    381              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
    382              return TRUE;
    383          }
    384          

   \                                 In section .text, align 2, keep-with-next
    385          boolean emberAfLevelControlClusterStepCallback(int8u stepMode, int8u stepSize, int16u transitionTime)
    386          {
   \                     emberAfLevelControlClusterStepCallback: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    387              emberAfLevelControlClusterPrintln("%pSTEP %x %x %2x", "RX level-control:", stepMode, stepSize, transitionTime);  
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000006   0x.... 0x....      ADR.W    R1,?_12
   \   0000000A   0x.... 0x....      BL       ?Subroutine10
    388              EmberAfStatus status = emAfLevelControlClusterStepHandler(ZCL_STEP_COMMAND_ID, stepMode, stepSize, transitionTime);
   \                     ??CrossCallReturnLabel_25: (+1)
   \   0000000E   0x4633             MOV      R3,R6
   \   00000010   0x462A             MOV      R2,R5
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x....             B.N      ?Subroutine2
    389              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
    390              return TRUE;  
    391          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      BL       emAfLevelControlClusterStepHandler
   \   00000004   0x.... 0x....      BL       emberAfSendImmediateDefaultResponse
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x9601             STR      R6,[SP, #+4]
   \   00000008   0x9500             STR      R5,[SP, #+0]
   \   0000000A   0x4623             MOV      R3,R4
   \   0000000C   0x.... 0x....      ADR.W    R2,?_8
   \   00000010   0x4770             BX       LR
    392          

   \                                 In section .text, align 2, keep-with-next
    393          boolean emberAfLevelControlClusterStepWithOnOffCallback(int8u stepMode, int8u stepSize, int16u transitionTime)
    394          {
   \                     emberAfLevelControlClusterStepWithOnOffCallback: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine7
    395              emberAfLevelControlClusterPrintln("%pSTEP_WITH_ON_OFF %x %x %2x", "RX level-control:", stepMode, stepSize, transitionTime);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000006   0x.... 0x....      ADR.W    R1,?_13
   \   0000000A   0x.... 0x....      BL       ?Subroutine10
    396              EmberAfStatus status = emAfLevelControlClusterStepHandler(ZCL_STEP_WITH_ON_OFF_COMMAND_ID, stepMode, stepSize, transitionTime);
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000000E   0x4633             MOV      R3,R6
   \   00000010   0x462A             MOV      R2,R5
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x2006             MOVS     R0,#+6
   \   00000016                      REQUIRE ?Subroutine2
   \   00000016                      ;; // Fall through to label ?Subroutine2
    397              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
    398              return TRUE;      
    399          }
    400          

   \                                 In section .text, align 2, keep-with-next
    401          boolean emberAfLevelControlClusterStopCallback(void)
    402          {
   \                     emberAfLevelControlClusterStopCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    403              emberAfLevelControlClusterPrintln("%pSTOP", "RX level-control:");
   \   00000002   0x.... 0x....      ADR.W    R2,?_8
   \   00000006   0x.... 0x....      ADR.W    R1,?_14
   \   0000000A   0x.... 0x....      BL       ?Subroutine9
    404              EmberAfStatus status = emAfLevelControlClusterStopHandler(ZCL_STOP_COMMAND_ID);
   \                     ??CrossCallReturnLabel_20: (+1)
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x....             B.N      ?Subroutine0
    405              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
    406              return TRUE;      
    407          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       emAfLevelControlClusterStopHandler
   \   00000004   0x.... 0x....      BL       emberAfSendImmediateDefaultResponse
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    408          

   \                                 In section .text, align 2, keep-with-next
    409          boolean emberAfLevelControlClusterStopWithOnOffCallback(void)
    410          {
   \                     emberAfLevelControlClusterStopWithOnOffCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    411              emberAfLevelControlClusterPrintln("%pSTOP_WITH_ON_OFF", "RX level-control:");
   \   00000002   0x.... 0x....      ADR.W    R2,?_8
   \   00000006   0x.... 0x....      ADR.W    R1,?_15
   \   0000000A   0x.... 0x....      BL       ?Subroutine9
    412              EmberAfStatus status = emAfLevelControlClusterStopHandler(ZCL_STOP_WITH_ON_OFF_COMMAND_ID);
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000000E   0x2007             MOVS     R0,#+7
   \   00000010                      REQUIRE ?Subroutine0
   \   00000010                      ;; // Fall through to label ?Subroutine0
    413              emberAfSendImmediateDefaultResponse(status);  // Send ZCl cmd default response.        
    414              return TRUE;
    415          }
    416          

   \                                 In section .text, align 2, keep-with-next
    417          static EmberAfStatus emAfLevelControlClusterMoveToLevelHandler(int8u commandId, int8u level, int16u transitionTime)
    418          {
   \                     emAfLevelControlClusterMoveToLevelHandler: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
    419              EmberAfStatus status;
    420              int8u currentLevel;
    421              int32u transTimeMs;
    422          
    423              EmberAfLevelControlState* state = emAfGetLevelControlState(emberAfCurrentEndpoint());  
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable25_2
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0x4688             MOV      R8,R1
   \   00000012   0x4617             MOV      R7,R2
   \   00000014   0x.... 0x....      BL       emAfGetLevelControlState
   \   00000018   0x0006             MOVS     R6,R0
    424              if (state == NULL) 
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2001             MOVEQ    R0,#+1
    425              {
    426                  return EMBER_ZCL_STATUS_FAILURE;        
   \   0000001E   0xD059             BEQ.N    ??emAfLevelControlClusterMoveToLevelHandler_0
    427              }
    428          
    429              // Cancel any currently active command before fiddling with the state.
    430              emAfDeactivateLevelControl(state);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7030             STRB     R0,[R6, #+0]
    431          
    432              status = emberAfReadServerAttribute(emberAfCurrentEndpoint(),
    433                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    434                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    435                                                (int8u *)&currentLevel,
    436                                                sizeof(currentLevel));
   \   00000024   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000028   0xEA5F 0x0900      MOVS     R9,R0
    437              if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \   0000002C   0xD003             BEQ.N    ??emAfLevelControlClusterMoveToLevelHandler_1
    438              {
    439                  emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
   \   0000002E   0x464A             MOV      R2,R9
   \   00000030   0x.... 0x....      ADR.W    R1,?_0
   \   00000034   0xE025             B.N      ??emAfLevelControlClusterMoveToLevelHandler_2
    440                  return status;
    441              }
    442          
    443              // Don't want to use the on level here
    444              state->useOnLevel = FALSE;
   \                     ??emAfLevelControlClusterMoveToLevelHandler_1: (+1)
   \   00000036   0x71F0             STRB     R0,[R6, #+7]
    445          
    446              // Keep the new level within range.
    447              if (level >= maxLevel) 
   \   00000038   0x....             LDR.N    R0,??DataTable25_1
   \   0000003A   0x7841             LDRB     R1,[R0, #+1]
   \   0000003C   0x4588             CMP      R8,R1
   \   0000003E   0xBF28             IT       CS 
   \   00000040   0x4688             MOVCS    R8,R1
    448              {
    449                  state->moveToLevel = maxLevel;
   \   00000042   0xD203             BCS.N    ??emAfLevelControlClusterMoveToLevelHandler_3
    450              } 
    451              else if (level <= minLevel) 
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x4540             CMP      R0,R8
   \   00000048   0xBF28             IT       CS 
   \   0000004A   0x4680             MOVCS    R8,R0
    452              {
    453                  state->moveToLevel = minLevel;
    454              } 
    455              else 
    456              {
    457                  state->moveToLevel = level;
   \                     ??emAfLevelControlClusterMoveToLevelHandler_3: (+1)
   \   0000004C   0xF886 0x8002      STRB     R8,[R6, #+2]
    458              }
    459          
    460              // Figure out if we're moving up or down.
    461              if (state->moveToLevel > currentLevel) 
   \   00000050   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_30: (+1)
   \   00000054   0xD219             BCS.N    ??emAfLevelControlClusterMoveToLevelHandler_4
    462              {
    463                  state->moveToLevelUp = TRUE;
   \   00000056   0x2001             MOVS     R0,#+1
   \                     ??emAfLevelControlClusterMoveToLevelHandler_5: (+1)
   \   00000058   0x71B0             STRB     R0,[R6, #+6]
    464              } 
    465              else if (state->moveToLevel < currentLevel) 
    466              {
    467                  state->moveToLevelUp = FALSE;
    468              } 
    469              else 
    470              {
    471                  // No change in level, so just send default response.
    472                  return EMBER_ZCL_STATUS_SUCCESS;        
    473              }
    474                  
    475              // If the Transition time field takes the value 0xFFFF, then the time taken to
    476              // move to the new level shall instead be determined by the On/Off Transition
    477              // Time attribute.  If On/Off Transition Time, which is an optional attribute,
    478              // is not present, the device shall move to its new level as fast as it is
    479              // able.
    480              if (transitionTime == 0xFFFF) 
   \   0000005A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xD119             BNE.N    ??emAfLevelControlClusterMoveToLevelHandler_6
    481              {
    482          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    483                  status = emberAfReadServerAttribute(emberAfCurrentEndpoint(),
    484                                                  ZCL_LEVEL_CONTROL_CLUSTER_ID,
    485                                                  ZCL_ON_OFF_TRANSITION_TIME_ATTRIBUTE_ID,
    486                                                  (int8u*)&transTimeMs,
    487                                                  sizeof(transTimeMs));
   \   00000062   0x2004             MOVS     R0,#+4
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0xAB02             ADD      R3,SP,#+8
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x7940             LDRB     R0,[R0, #+5]
   \   0000006E   0x2210             MOVS     R2,#+16
   \   00000070   0x2108             MOVS     R1,#+8
   \   00000072   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000076   0xEA5F 0x0900      MOVS     R9,R0
    488                  if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \   0000007A   0xD00C             BEQ.N    ??emAfLevelControlClusterMoveToLevelHandler_6
    489                  {
    490                      emberAfLevelControlClusterPrintln("ERR: reading on/off transition time %x",
    491                                                          status);
   \   0000007C   0x464A             MOV      R2,R9
   \   0000007E   0x.... 0x....      ADR.W    R1,?_16
   \                     ??emAfLevelControlClusterMoveToLevelHandler_2: (+1)
   \   00000082   0x.... 0x....      BL       ?Subroutine9
    492                      return status;
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000086   0x4648             MOV      R0,R9
   \   00000088   0xE024             B.N      ??emAfLevelControlClusterMoveToLevelHandler_0
    493                  }
    494          
    495                  // Transition time comes in (or is stored, in the case of On/Off Transition
    496                  // Time) as tenths of a second, but we work in milliseconds.
    497                  transTimeMs = transitionTime * MILLISECOND_TICKS_PER_SECOND / 10;
    498          #else //ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    499              // If the Transition Time field is 0xFFFF and On/Off Transition Time,
    500              // which is an optional attribute, is not present, the device shall move to
    501              // its new level as fast as it is able.
    502                  transTimeMs = FASTEST_TRANSITION_TIME;
    503          #endif //ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    504              } 
   \                     ??emAfLevelControlClusterMoveToLevelHandler_4: (+1)
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xBF38             IT       CC 
   \   0000008E   0x2000             MOVCC    R0,#+0
   \   00000090   0xD3E2             BCC.N    ??emAfLevelControlClusterMoveToLevelHandler_5
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE01E             B.N      ??emAfLevelControlClusterMoveToLevelHandler_0
    505              else 
    506              {
    507                  // Transition time comes in (or is stored, in the case of On/Off Transition
    508                  // Time) as tenths of a second, but we work in milliseconds.
    509                  transTimeMs = transitionTime * MILLISECOND_TICKS_PER_SECOND / 10;
   \                     ??emAfLevelControlClusterMoveToLevelHandler_6: (+1)
   \   00000096   0x02B8             LSLS     R0,R7,#+10
   \   00000098   0x210A             MOVS     R1,#+10
   \   0000009A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000009E   0x9002             STR      R0,[SP, #+8]
    510              }
    511              
    512              int8u amount;
    513              if (state->moveToLevel > currentLevel)
    514              {      
    515                  amount = state->moveToLevel - currentLevel;    
    516                  state->moveToLevelUp = TRUE;
    517              }
    518              else
    519              {      
    520                  amount = currentLevel - state->moveToLevel;    
    521                  state->moveToLevelUp = FALSE;
    522              }
    523              state->transitionTime = transTimeMs;
    524              calculateEventDuration_and_stepSize(state->transitionTime, amount, &state->eventDuration, &state->stepSize);     
   \   000000A0   0xF106 0x020C      ADD      R2,R6,#+12
   \   000000A4   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_31: (+1)
   \   000000A8   0xBF39             ITTEE    CC 
   \   000000AA   0x1A41             SUBCC    R1,R0,R1
   \   000000AC   0x2001             MOVCC    R0,#+1
   \   000000AE   0x1A09             SUBCS    R1,R1,R0
   \   000000B0   0x2000             MOVCS    R0,#+0
   \   000000B2   0x71B0             STRB     R0,[R6, #+6]
   \   000000B4   0x1D33             ADDS     R3,R6,#+4
   \   000000B6   0x9802             LDR      R0,[SP, #+8]
   \   000000B8   0x6130             STR      R0,[R6, #+16]
   \   000000BA   0xB2C9             UXTB     R1,R1
   \   000000BC   0xB280             UXTH     R0,R0
   \   000000BE   0x.... 0x....      BL       calculateEventDuration_and_stepSize
    525              
    526              // The setup was successful, so mark the new state as active and return.
    527              emAfActivateLevelControl(state, emberAfCurrentEndpoint());
   \   000000C2   0x6828             LDR      R0,[R5, #+0]
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x7941             LDRB     R1,[R0, #+5]
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       emAfActivateLevelControl
    528          
    529              state->elapsedTime = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x6170             STR      R0,[R6, #+20]
    530              state->commandId = commandId;
   \   000000D2   0x7074             STRB     R4,[R6, #+1]
    531          
    532          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
    533              if (commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID) 
    534              {
    535                  emberAfPluginZllLevelControlServerMoveToLevelWithOnOffZllExtensions(emberAfCurrentCommand());
    536              }
    537          #endif
    538          
    539              return EMBER_ZCL_STATUS_SUCCESS;    
   \                     ??emAfLevelControlClusterMoveToLevelHandler_0: (+1)
   \   000000D4   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    540          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x78B0             LDRB     R0,[R6, #+2]
   \                     ??Subroutine11_0: (+1)
   \   00000002   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xAB01             ADD      R3,SP,#+4
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7940             LDRB     R0,[R0, #+5]
   \   0000000E   0x2108             MOVS     R1,#+8
   \   00000010   0x.... 0x....      B.W      emberAfReadServerAttribute
    541          

   \                                 In section .text, align 2, keep-with-next
    542          static EmberAfStatus emAfLevelControlClusterMoveHandler(int8u commandId, int8u moveMode, int8u rate)
    543          {
   \                     emAfLevelControlClusterMoveHandler: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    544              EmberAfLevelControlState *state = emAfGetLevelControlState(emberAfCurrentEndpoint());
   \   00000004   0x....             LDR.N    R5,??DataTable25_2
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0xB083             SUB      SP,SP,#+12
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0x460E             MOV      R6,R1
   \   00000012   0x4690             MOV      R8,R2
   \   00000014   0x.... 0x....      BL       emAfGetLevelControlState
   \   00000018   0x0007             MOVS     R7,R0
    545              EmberAfStatus status;
    546              int8u currentLevel;
    547          
    548              if (state == NULL) 
   \   0000001A   0xD102             BNE.N    ??emAfLevelControlClusterMoveHandler_0
    549              {
    550                  return EMBER_ZCL_STATUS_FAILURE;    
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??emAfLevelControlClusterMoveHandler_1: (+1)
   \   0000001E   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    551              }
    552          
    553              // Cancel any currently active command before fiddling with the state.
    554              emAfDeactivateLevelControl(state);
   \                     ??emAfLevelControlClusterMoveHandler_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x7038             STRB     R0,[R7, #+0]
    555          
    556              status = emberAfReadServerAttribute(emberAfCurrentEndpoint(),
    557                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    558                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    559                                                (int8u *)&currentLevel,
    560                                                sizeof(currentLevel));
   \   00000026   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000002A   0xEA5F 0x0900      MOVS     R9,R0
    561              if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \   0000002E   0xD004             BEQ.N    ??emAfLevelControlClusterMoveHandler_2
    562              {
    563                  emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
   \   00000030   0x464A             MOV      R2,R9
   \   00000032   0x.... 0x....      BL       ?Subroutine6
    564                  return status;
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000036   0x4648             MOV      R0,R9
   \   00000038   0xE7F1             B.N      ??emAfLevelControlClusterMoveHandler_1
    565              }
    566          
    567              // Don't want to use the on level here
    568              state->useOnLevel = FALSE;
   \                     ??emAfLevelControlClusterMoveHandler_2: (+1)
   \   0000003A   0x71F8             STRB     R0,[R7, #+7]
    569          
    570              // Start the level calculation (initialization)
    571              state->moveMode = moveMode;
   \   0000003C   0x70FE             STRB     R6,[R7, #+3]
    572              switch (moveMode) 
   \   0000003E   0x....             LDR.N    R0,??DataTable25_1
   \   00000040   0xB116             CBZ.N    R6,??emAfLevelControlClusterMoveHandler_3
   \   00000042   0x2E01             CMP      R6,#+1
   \   00000044   0xD010             BEQ.N    ??emAfLevelControlClusterMoveHandler_4
   \   00000046   0xE018             B.N      ??emAfLevelControlClusterMoveHandler_5
    573              {
    574                  case EMBER_ZCL_MOVE_MODE_UP:
    575                      if (currentLevel == maxLevel) 
   \                     ??emAfLevelControlClusterMoveHandler_3: (+1)
   \   00000048   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000004C   0x7840             LDRB     R0,[R0, #+1]
   \   0000004E   0x4281             CMP      R1,R0
   \   00000050   0xD00F             BEQ.N    ??emAfLevelControlClusterMoveHandler_6
    576                      {
    577                          return EMBER_ZCL_STATUS_SUCCESS;      
    578                      }
    579                      state->moveToLevelUp = TRUE;
   \   00000052   0x2001             MOVS     R0,#+1
   \                     ??emAfLevelControlClusterMoveHandler_7: (+1)
   \   00000054   0x71B8             STRB     R0,[R7, #+6]
    580                      break;
    581              
    582                  case EMBER_ZCL_MOVE_MODE_DOWN:
    583                      if (currentLevel == minLevel) 
    584                      {
    585                          return EMBER_ZCL_STATUS_SUCCESS;              
    586                      }
    587                      state->moveToLevelUp = FALSE;
    588                      break;
    589                      
    590                  default:
    591                      return EMBER_ZCL_STATUS_INVALID_FIELD;
    592                      
    593              }
    594          
    595              // If the Rate field is 0xFF, the device should move as fast as it is able.
    596              if (rate == 0xff) 
   \   00000056   0xF1B8 0x0FFF      CMP      R8,#+255
   \   0000005A   0xBF0E             ITEE     EQ 
   \   0000005C   0x2000             MOVEQ    R0,#+0
   \   0000005E   0xF44F 0x6080      MOVNE    R0,#+1024
   \   00000062   0xFBB0 0xF0F8      UDIVNE   R0,R0,R8
    597              {
    598                  state->eventDuration = 0;
    599              } 
    600              else 
    601              {
    602                  state->eventDuration = MILLISECOND_TICKS_PER_SECOND / rate;
   \   00000066   0xE00A             B.N      ??emAfLevelControlClusterMoveHandler_8
    603              }
   \                     ??emAfLevelControlClusterMoveHandler_4: (+1)
   \   00000068   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xD101             BNE.N    ??emAfLevelControlClusterMoveHandler_9
   \                     ??emAfLevelControlClusterMoveHandler_6: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE7D3             B.N      ??emAfLevelControlClusterMoveHandler_1
   \                     ??emAfLevelControlClusterMoveHandler_9: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE7EC             B.N      ??emAfLevelControlClusterMoveHandler_7
   \                     ??emAfLevelControlClusterMoveHandler_5: (+1)
   \   0000007A   0x2085             MOVS     R0,#+133
   \   0000007C   0xE7CF             B.N      ??emAfLevelControlClusterMoveHandler_1
   \                     ??emAfLevelControlClusterMoveHandler_8: (+1)
   \   0000007E   0x60F8             STR      R0,[R7, #+12]
    604          
    605              // The setup was successful, so mark the new state as active and return.
    606              emAfActivateLevelControl(state, emberAfCurrentEndpoint());
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0x.... 0x....      BL       ?Subroutine12
    607              state->commandId = commandId;
   \                     ??CrossCallReturnLabel_35: (+1)
   \   00000086   0x707C             STRB     R4,[R7, #+1]
   \   00000088   0xE7F3             B.N      ??emAfLevelControlClusterMoveHandler_6
    608          
    609              return EMBER_ZCL_STATUS_SUCCESS;  
    610          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x7941             LDRB     R1,[R0, #+5]
   \   00000004   0x4638             MOV      R0,R7
   \   00000006   0x....             B.N      emAfActivateLevelControl

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,?_0
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      B.W      emberAfPrintln
    611          

   \                                 In section .text, align 2, keep-with-next
    612          static EmberAfStatus emAfLevelControlClusterStepHandler(int8u commandId, int8u stepMode, int8u stepSize, int16u transitionTime)
    613          {
   \                     emAfLevelControlClusterStepHandler: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
    614              EmberAfLevelControlState *state = emAfGetLevelControlState(emberAfCurrentEndpoint());
   \   00000004   0x....             LDR.N    R6,??DataTable25_2
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x6830             LDR      R0,[R6, #+0]
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0x4692             MOV      R10,R2
   \   00000012   0x461D             MOV      R5,R3
   \   00000014   0x.... 0x....      BL       emAfGetLevelControlState
   \   00000018   0x4607             MOV      R7,R0
    615              EmberAfStatus status;
    616              int8u currentLevel;
    617              int32u transTime;
    618              boolean overUnder = FALSE;
   \   0000001A   0x2400             MOVS     R4,#+0
    619          
    620              if (state == NULL) 
   \   0000001C   0xB917             CBNZ.N   R7,??emAfLevelControlClusterStepHandler_0
    621              {
    622                  return EMBER_ZCL_STATUS_FAILURE;    
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??emAfLevelControlClusterStepHandler_1: (+1)
   \   00000020   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    623              }
    624          
    625              // Cancel any currently active command before fiddling with the state.
    626              emAfDeactivateLevelControl(state);
   \                     ??emAfLevelControlClusterStepHandler_0: (+1)
   \   00000024   0x703C             STRB     R4,[R7, #+0]
    627          
    628              status = emberAfReadServerAttribute(emberAfCurrentEndpoint(),
    629                                                  ZCL_LEVEL_CONTROL_CLUSTER_ID,
    630                                                  ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    631                                                  (int8u *)&currentLevel,
    632                                                  sizeof(currentLevel));
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0xAB01             ADD      R3,SP,#+4
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x7940             LDRB     R0,[R0, #+5]
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2108             MOVS     R1,#+8
   \   00000036   0x.... 0x....      BL       emberAfReadServerAttribute
   \   0000003A   0xEA5F 0x0B00      MOVS     R11,R0
    633              if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \   0000003E   0xD004             BEQ.N    ??emAfLevelControlClusterStepHandler_2
    634              {
    635                  emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
   \   00000040   0x465A             MOV      R2,R11
   \   00000042   0x.... 0x....      BL       ?Subroutine6
    636                  return status;
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000046   0x4658             MOV      R0,R11
   \   00000048   0xE7EA             B.N      ??emAfLevelControlClusterStepHandler_1
    637              }
    638          
    639              // Don't want to use the on level here
    640              state->useOnLevel = FALSE;
   \                     ??emAfLevelControlClusterStepHandler_2: (+1)
   \   0000004A   0x71F8             STRB     R0,[R7, #+7]
    641          
    642              state->moveMode = stepMode;
    643              switch (stepMode) 
   \   0000004C   0x....             LDR.N    R2,??DataTable25_1
   \   0000004E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000052   0x70F8             STRB     R0,[R7, #+3]
   \   00000054   0xF89D 0x3008      LDRB     R3,[SP, #+8]
   \   00000058   0xB113             CBZ.N    R3,??emAfLevelControlClusterStepHandler_3
   \   0000005A   0x2B01             CMP      R3,#+1
   \   0000005C   0xD01B             BEQ.N    ??emAfLevelControlClusterStepHandler_4
   \   0000005E   0xE02E             B.N      ??emAfLevelControlClusterStepHandler_5
    644              {
    645                  case EMBER_ZCL_STEP_MODE_UP:
    646                      if (currentLevel == maxLevel) 
   \                     ??emAfLevelControlClusterStepHandler_3: (+1)
   \   00000060   0x7852             LDRB     R2,[R2, #+1]
   \   00000062   0xF89D 0x3004      LDRB     R3,[SP, #+4]
   \   00000066   0x4293             CMP      R3,R2
   \   00000068   0xD013             BEQ.N    ??emAfLevelControlClusterStepHandler_6
    647                      {
    648                          return EMBER_ZCL_STATUS_SUCCESS;              
    649                      } 
    650                      else if (maxLevel - currentLevel > stepSize) 
   \   0000006A   0x1AD3             SUBS     R3,R2,R3
   \   0000006C   0x459A             CMP      R10,R3
   \   0000006E   0xDA04             BGE.N    ??emAfLevelControlClusterStepHandler_7
    651                      {
    652                          state->moveToLevel = currentLevel + stepSize;
   \   00000070   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000074   0xEB0A 0x0201      ADD      R2,R10,R1
   \   00000078   0xE003             B.N      ??emAfLevelControlClusterStepHandler_8
    653                      } 
    654                      else 
    655                      {
    656                          // If the new level was pegged at the maximum level, the transition
    657                          // time shall be proportionally reduced.
    658                          overUnder = TRUE;
    659                          transTime = (transitionTime * (maxLevel - currentLevel)) / stepSize;
   \                     ??emAfLevelControlClusterStepHandler_7: (+1)
   \   0000007A   0x436B             MULS     R3,R3,R5
   \   0000007C   0x2401             MOVS     R4,#+1
   \   0000007E   0xFB93 0xF8FA      SDIV     R8,R3,R10
    660                          state->moveToLevel = maxLevel;
   \                     ??emAfLevelControlClusterStepHandler_8: (+1)
   \   00000082   0x70BA             STRB     R2,[R7, #+2]
    661                      }
    662                      state->moveToLevelUp = TRUE;
   \   00000084   0x2101             MOVS     R1,#+1
   \                     ??emAfLevelControlClusterStepHandler_9: (+1)
   \   00000086   0x71B9             STRB     R1,[R7, #+6]
    663                      break;
    664                      
    665                  case EMBER_ZCL_STEP_MODE_DOWN:
    666                      if (currentLevel == minLevel) 
    667                      {
    668                          return EMBER_ZCL_STATUS_SUCCESS;              
    669                      } 
    670                      else if (currentLevel - minLevel > stepSize) 
    671                      {
    672                          state->moveToLevel = currentLevel - stepSize;
    673                      } 
    674                      else 
    675                      {
    676                          // If the new level was pegged at the minimum level, the transition
    677                          // time shall be proportionally reduced.
    678                          overUnder = TRUE;
    679                          transTime = (transitionTime * (currentLevel - minLevel)) / stepSize;
    680                          state->moveToLevel = minLevel;
    681                      }
    682                      state->moveToLevelUp = FALSE;
    683                      break;
    684                      
    685                  default:
    686                      return EMBER_ZCL_STATUS_INVALID_FIELD;            
    687              }
    688          
    689              if (state->moveToLevel == currentLevel) 
   \   00000088   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   0000008C   0x78B9             LDRB     R1,[R7, #+2]
   \   0000008E   0x4291             CMP      R1,R2
   \   00000090   0xD117             BNE.N    ??emAfLevelControlClusterStepHandler_10
    690              {
    691                  return EMBER_ZCL_STATUS_SUCCESS;        
   \                     ??emAfLevelControlClusterStepHandler_6: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE7C4             B.N      ??emAfLevelControlClusterStepHandler_1
    692              }
   \                     ??emAfLevelControlClusterStepHandler_4: (+1)
   \   00000096   0x7812             LDRB     R2,[R2, #+0]
   \   00000098   0xF89D 0x3004      LDRB     R3,[SP, #+4]
   \   0000009C   0x4293             CMP      R3,R2
   \   0000009E   0xD0F8             BEQ.N    ??emAfLevelControlClusterStepHandler_6
   \   000000A0   0x1A9B             SUBS     R3,R3,R2
   \   000000A2   0x459A             CMP      R10,R3
   \   000000A4   0xDA04             BGE.N    ??emAfLevelControlClusterStepHandler_11
   \   000000A6   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000AA   0xEBA1 0x020A      SUB      R2,R1,R10
   \   000000AE   0xE003             B.N      ??emAfLevelControlClusterStepHandler_12
   \                     ??emAfLevelControlClusterStepHandler_11: (+1)
   \   000000B0   0x436B             MULS     R3,R3,R5
   \   000000B2   0x2401             MOVS     R4,#+1
   \   000000B4   0xFB93 0xF8FA      SDIV     R8,R3,R10
   \                     ??emAfLevelControlClusterStepHandler_12: (+1)
   \   000000B8   0x70BA             STRB     R2,[R7, #+2]
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0xE7E3             B.N      ??emAfLevelControlClusterStepHandler_9
   \                     ??emAfLevelControlClusterStepHandler_5: (+1)
   \   000000BE   0x2085             MOVS     R0,#+133
   \   000000C0   0xE7AE             B.N      ??emAfLevelControlClusterStepHandler_1
    693              
    694              // If the Transition Time field is 0xFFFF, the device should move as
    695              // fast as it is able.
    696              if (transitionTime == 0xFFFF) 
   \                     ??emAfLevelControlClusterStepHandler_10: (+1)
   \   000000C2   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000C6   0x428D             CMP      R5,R1
   \   000000C8   0xBF08             IT       EQ 
   \   000000CA   0xF04F 0x0800      MOVEQ    R8,#+0
    697              {
    698                  transTime = FASTEST_TRANSITION_TIME;
   \   000000CE   0xD007             BEQ.N    ??emAfLevelControlClusterStepHandler_13
    699              } 
    700              else if (!overUnder) 
   \   000000D0   0x2C00             CMP      R4,#+0
   \   000000D2   0xBF0C             ITE      EQ 
   \   000000D4   0x02A8             LSLEQ    R0,R5,#+10
   \   000000D6   0xEA4F 0x2088      LSLNE    R0,R8,#+10
    701              {
    702                  // Transition time comes in as tenths of a second, but we work in milliseconds.
    703                  transTime = transitionTime * MILLISECOND_TICKS_PER_SECOND / 10;
    704              } 
    705              else 
    706              {
    707                  transTime = transTime * MILLISECOND_TICKS_PER_SECOND / 10;
   \   000000DA   0x210A             MOVS     R1,#+10
   \   000000DC   0xFBB0 0xF8F1      UDIV     R8,R0,R1
    708              }
    709              
    710              // The duration between events will be the transition time divided by
    711              // the distance we must move.
    712              state->eventDuration = transTime / stepSize;    
   \                     ??emAfLevelControlClusterStepHandler_13: (+1)
   \   000000E0   0xFBB8 0xF0FA      UDIV     R0,R8,R10
   \   000000E4   0x60F8             STR      R0,[R7, #+12]
    713              state->transitionTime = transTime;
   \   000000E6   0xF8C7 0x8010      STR      R8,[R7, #+16]
    714              
    715              // The setup was successful, so mark the new state as active and return.
    716              emAfActivateLevelControl(state, emberAfCurrentEndpoint());
   \   000000EA   0x6830             LDR      R0,[R6, #+0]
   \   000000EC   0x.... 0x....      BL       ?Subroutine12
    717              state->commandId = commandId;
    718              state->elapsedTime = 0;
   \                     ??CrossCallReturnLabel_34: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xF887 0x9001      STRB     R9,[R7, #+1]
   \   000000F6   0x6178             STR      R0,[R7, #+20]
   \   000000F8   0xE7CB             B.N      ??emAfLevelControlClusterStepHandler_6
    719          
    720              return EMBER_ZCL_STATUS_SUCCESS;  
    721          }
    722          

   \                                 In section .text, align 2, keep-with-next
    723          static EmberAfStatus  emAfLevelControlClusterStopHandler(int8u commandId)
    724          {
   \                     emAfLevelControlClusterStopHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    725              EmberAfLevelControlState *state = emAfGetLevelControlState(emberAfCurrentEndpoint());
   \   00000004   0x....             LDR.N    R0,??DataTable25_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x7940             LDRB     R0,[R0, #+5]
   \   0000000C   0x.... 0x....      BL       emAfGetLevelControlState
    726              EmberAfStatus status;
                                   ^
Warning[Pe177]: variable "status" was declared but never referenced
    727          
    728              if (state == NULL) 
   \   00000010   0xB908             CBNZ.N   R0,??emAfLevelControlClusterStopHandler_0
    729              {
    730                  return EMBER_ZCL_STATUS_FAILURE;    
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xBD10             POP      {R4,PC}
    731              }
    732          
    733              // Cancel any currently active command.
    734              emAfDeactivateLevelControl(state);
   \                     ??emAfLevelControlClusterStopHandler_0: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    735              state->commandId = commandId;
   \   0000001A   0x7044             STRB     R4,[R0, #+1]
    736              return EMBER_ZCL_STATUS_SUCCESS;  
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    737          }
    738          

   \                                 In section .text, align 2, keep-with-next
    739          void emAfPluginLevelControlClusterOnOffEffectHandler(int8u commandId,
    740                                                               int8u level,
    741                                                               boolean onLevel,
    742                                                               int16u transitionTime)
    743          {
   \                     emAfPluginLevelControlClusterOnOffEffectHandler: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    744            EmberAfLevelControlState *state = emAfGetLevelControlState(emberAfCurrentEndpoint());
   \   00000004   0x....             LDR.N    R7,??DataTable25_2
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x6838             LDR      R0,[R7, #+0]
   \   0000000A   0xB083             SUB      SP,SP,#+12
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0x460C             MOV      R4,R1
   \   00000012   0x4616             MOV      R6,R2
   \   00000014   0x4699             MOV      R9,R3
   \   00000016   0x.... 0x....      BL       emAfGetLevelControlState
   \   0000001A   0x0005             MOVS     R5,R0
    745            EmberAfStatus status;
    746            int8u currentLevel;
    747            int32u transTimeMs;
    748          
    749            if (state == NULL) 
   \   0000001C   0xD050             BEQ.N    ??emAfPluginLevelControlClusterOnOffEffectHandl_0
    750            {
    751              status = EMBER_ZCL_STATUS_FAILURE;
    752              return;
    753            }
    754          
    755            // Cancel any currently active command before fiddling with the state.
    756            emAfDeactivateLevelControl(state);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    757          
    758            status = emberAfReadServerAttribute(emberAfCurrentEndpoint(),
    759                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    760                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    761                                                (int8u *)&currentLevel,
    762                                                sizeof(currentLevel));
   \   00000022   0xAB01             ADD      R3,SP,#+4
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x6838             LDR      R0,[R7, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x7940             LDRB     R0,[R0, #+5]
   \   00000030   0x2108             MOVS     R1,#+8
   \   00000032   0x.... 0x....      BL       emberAfReadServerAttribute
    763            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   00000036   0xB118             CBZ.N    R0,??emAfPluginLevelControlClusterOnOffEffectHandl_1
    764              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
   \   00000038   0x4602             MOV      R2,R0
   \   0000003A   0x.... 0x....      BL       ?Subroutine6
    765              return;
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000003E   0xE03F             B.N      ??emAfPluginLevelControlClusterOnOffEffectHandl_0
    766            }
    767          
    768            // Is the level the ad hoc on level?
    769            state->useOnLevel = onLevel;
    770            state->onLevel = minLevel;
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_1: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable25_1
   \   00000042   0x71EE             STRB     R6,[R5, #+7]
   \   00000044   0x7801             LDRB     R1,[R0, #+0]
   \   00000046   0x7229             STRB     R1,[R5, #+8]
    771          
    772            // Keep the new level within range.
    773            if (onLevel) 
   \   00000048   0xB10E             CBZ.N    R6,??emAfPluginLevelControlClusterOnOffEffectHandl_2
    774            {
    775              state->onLevel = level;
   \   0000004A   0x722C             STRB     R4,[R5, #+8]
    776              state->moveToLevel = minLevel;
   \   0000004C   0xE007             B.N      ??emAfPluginLevelControlClusterOnOffEffectHandl_3
    777            } 
    778            else if (level >= maxLevel) 
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_2: (+1)
   \   0000004E   0x7840             LDRB     R0,[R0, #+1]
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xBF28             IT       CS 
   \   00000054   0x4601             MOVCS    R1,R0
    779            {
    780              state->moveToLevel = maxLevel;
   \   00000056   0xD202             BCS.N    ??emAfPluginLevelControlClusterOnOffEffectHandl_3
    781            } 
    782            else if (level <= minLevel) 
   \   00000058   0x42A1             CMP      R1,R4
   \   0000005A   0xBF38             IT       CC 
   \   0000005C   0x4621             MOVCC    R1,R4
    783            {
    784              state->moveToLevel = minLevel;
    785            } 
    786            else 
    787            {
    788              state->moveToLevel = level;
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_3: (+1)
   \   0000005E   0x70A9             STRB     R1,[R5, #+2]
    789            }
    790          
    791            // Figure out if we're moving up or down and by how much.
    792            if (state->moveToLevel > currentLevel) 
   \   00000060   0x78A8             LDRB     R0,[R5, #+2]
   \   00000062   0x.... 0x....      BL       ??Subroutine11_0
   \                     ??CrossCallReturnLabel_32: (+1)
   \   00000066   0xD20C             BCS.N    ??emAfPluginLevelControlClusterOnOffEffectHandl_4
    793            {
    794              state->moveToLevelUp = TRUE;
   \   00000068   0x2101             MOVS     R1,#+1
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_5: (+1)
   \   0000006A   0x71A9             STRB     R1,[R5, #+6]
    795            } 
    796            else if (state->moveToLevel < currentLevel) 
    797            {
    798              state->moveToLevelUp = FALSE;
    799            } 
    800            else 
    801            {
    802              return;
    803            }
    804            
    805            // If the Transition time field takes the value 0xFFFF, then the time taken to
    806            // move to the new level shall instead be determined by the On/Off Transition
    807            // Time attribute.  If On/Off Transition Time, which is an optional attribute,
    808            // is not present, the device shall move to its new level as fast as it is
    809            // able.
    810            if (transitionTime == 0xFFFF) 
   \   0000006C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000070   0x4589             CMP      R9,R1
   \   00000072   0xBF0F             ITEEE    EQ 
   \   00000074   0x2200             MOVEQ    R2,#+0
   \   00000076   0xEA4F 0x2189      LSLNE    R1,R9,#+10
   \   0000007A   0x220A             MOVNE    R2,#+10
   \   0000007C   0xFBB1 0xF2F2      UDIVNE   R2,R1,R2
    811            {
    812              transTimeMs = FASTEST_TRANSITION_TIME;
    813            } 
    814            else 
    815            {
    816              // Transition time comes in (or is stored, in the case of On/Off Transition
    817              // Time) as tenths of a second, but we work in milliseconds.
    818              transTimeMs = transitionTime * MILLISECOND_TICKS_PER_SECOND / 10;
   \   00000080   0xE003             B.N      ??emAfPluginLevelControlClusterOnOffEffectHandl_6
    819            }
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_4: (+1)
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD21C             BCS.N    ??emAfPluginLevelControlClusterOnOffEffectHandl_0
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0xE7EF             B.N      ??emAfPluginLevelControlClusterOnOffEffectHandl_5
    820            
    821            int8u amount;
    822            if (state->moveToLevel > currentLevel)
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_6: (+1)
   \   0000008A   0x.... 0x....      BL       ??Subroutine11_0
   \                     ??CrossCallReturnLabel_33: (+1)
   \   0000008E   0xBF39             ITTEE    CC 
   \   00000090   0x1A41             SUBCC    R1,R0,R1
   \   00000092   0x2001             MOVCC    R0,#+1
   \   00000094   0x1A09             SUBCS    R1,R1,R0
   \   00000096   0x2000             MOVCS    R0,#+0
    823            {      
    824                amount = state->moveToLevel - currentLevel;    
    825                state->moveToLevelUp = TRUE;
    826            }
    827            else
    828            {      
    829                amount = currentLevel - state->moveToLevel;    
    830                state->moveToLevelUp = FALSE;
   \   00000098   0x71A8             STRB     R0,[R5, #+6]
    831            }            
    832            state->transitionTime = transTimeMs;
   \   0000009A   0x612A             STR      R2,[R5, #+16]
    833            calculateEventDuration_and_stepSize(state->transitionTime, amount, &state->eventDuration, &state->stepSize);   
   \   0000009C   0x1D2B             ADDS     R3,R5,#+4
   \   0000009E   0x6928             LDR      R0,[R5, #+16]
   \   000000A0   0xF105 0x020C      ADD      R2,R5,#+12
   \   000000A4   0xB2C9             UXTB     R1,R1
   \   000000A6   0xB280             UXTH     R0,R0
   \   000000A8   0x.... 0x....      BL       calculateEventDuration_and_stepSize
    834              
    835            state->elapsedTime = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x6168             STR      R0,[R5, #+20]
    836            state->commandId = commandId;
   \   000000B0   0xF885 0x8001      STRB     R8,[R5, #+1]
    837          
    838            // The setup was successful, so mark the new state as active and return.
    839            emAfActivateLevelControl(state, emberAfCurrentEndpoint());
   \   000000B4   0x6838             LDR      R0,[R7, #+0]
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x7941             LDRB     R1,[R0, #+5]
   \   000000BA   0x4628             MOV      R0,R5
   \   000000BC   0x.... 0x....      BL       emAfActivateLevelControl
    840          }
   \                     ??emAfPluginLevelControlClusterOnOffEffectHandl_0: (+1)
   \   000000C0   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    841          

   \                                 In section .text, align 2, keep-with-next
    842          EmberAfStatus emAfPluginLevelControlClusterGetCurrentLevel(int8u* currentLevel)
    843          {
   \                     emAfPluginLevelControlClusterGetCurrentLevel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    844              EmberAfStatus status;
    845          
    846              status = emberAfReadServerAttribute(1,
    847                                                  ZCL_LEVEL_CONTROL_CLUSTER_ID,
    848                                                  ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    849                                                  currentLevel,
    850                                                  1);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0x4603             MOV      R3,R0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2108             MOVS     R1,#+8
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000014   0x0004             MOVS     R4,R0
    851              
    852              if (status != EMBER_ZCL_STATUS_SUCCESS) 
   \   00000016   0xD002             BEQ.N    ??CrossCallReturnLabel_8
    853              {
    854                  emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);                                        
   \   00000018   0x4622             MOV      R2,R4
   \   0000001A   0x.... 0x....      BL       ?Subroutine6
    855              } 
    856              else 
    857              {
    858                  //GB emberAfLevelControlClusterPrintln("Current level %d", *currentLevel);
    859              }
    860              
    861              return status;
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    862          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x4F 0x4E          DC8      0x4F, 0x4E, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x4F 0x46          DC8      "OFF"
   \              0x46 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     stateTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     minLevel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     emAfCurrentCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x45 0x52          DC8 "ERR: reading current level %x"
   \              0x52 0x3A    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x69    
   \              0x6E 0x67    
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x72 0x65    
   \              0x6E 0x74    
   \              0x20 0x6C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x20 0x25    
   \              0x78 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x52          DC8 "ERR: writing current level %x"
   \              0x52 0x3A    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x72 0x65    
   \              0x6E 0x74    
   \              0x20 0x6C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x20 0x25    
   \              0x78 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x45 0x76          DC8 "Event: move Level %x->%x"
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x6D    
   \              0x6F 0x76    
   \              0x65 0x20    
   \              0x4C 0x65    
   \              0x76 0x65    
   \              0x6C 0x20    
   \              0x25 0x78    
   \              0x2D 0x3E    
   \              0x25 0x78    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 "Err: writing current level %x"
   \              0x72 0x3A    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x72 0x65    
   \              0x6E 0x74    
   \              0x20 0x6C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x20 0x25    
   \              0x78 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x4F 0x4E          DC8 "ON"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x4F 0x46          DC8 "OFF"
   \              0x46 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x53 0x65          DC8 "Setting on/off to %p due to level change"
   \              0x74 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x6F 0x6E    
   \              0x2F 0x6F    
   \              0x66 0x66    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x25 0x70    
   \              0x20 0x64    
   \              0x75 0x65    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x6C 0x65    
   \              0x76 0x65    
   \              0x6C 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x25 0x70          DC8 "%pMOVE_TO_LEVEL %x %2x"
   \              0x4D 0x4F    
   \              0x56 0x45    
   \              0x5F 0x54    
   \              0x4F 0x5F    
   \              0x4C 0x45    
   \              0x56 0x45    
   \              0x4C 0x20    
   \              0x25 0x78    
   \              0x20 0x25    
   \              0x32 0x78    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x52 0x58          DC8 "RX level-control:"
   \              0x20 0x6C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x2D 0x63    
   \              0x6F 0x6E    
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x3A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x25 0x70          DC8 "%pMOVE_TO_LEVEL_WITH_ON_OFF %x %2x"
   \              0x4D 0x4F    
   \              0x56 0x45    
   \              0x5F 0x54    
   \              0x4F 0x5F    
   \              0x4C 0x45    
   \              0x56 0x45    
   \              0x4C 0x5F    
   \              0x57 0x49    
   \              0x54 0x48    
   \              0x5F 0x4F    
   \              0x4E 0x5F    
   \              0x4F 0x46    
   \              0x46 0x20    
   \              0x25 0x78    
   \              0x20 0x25    
   \              0x32 0x78    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x25 0x70          DC8 "%pMOVE %x %x"
   \              0x4D 0x4F    
   \              0x56 0x45    
   \              0x20 0x25    
   \              0x78 0x20    
   \              0x25 0x78    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x25 0x70          DC8 "%pMOVE_WITH_ON_OFF %x %x"
   \              0x4D 0x4F    
   \              0x56 0x45    
   \              0x5F 0x57    
   \              0x49 0x54    
   \              0x48 0x5F    
   \              0x4F 0x4E    
   \              0x5F 0x4F    
   \              0x46 0x46    
   \              0x20 0x25    
   \              0x78 0x20    
   \              0x25 0x78    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x25 0x70          DC8 "%pSTEP %x %x %2x"
   \              0x53 0x54    
   \              0x45 0x50    
   \              0x20 0x25    
   \              0x78 0x20    
   \              0x25 0x78    
   \              0x20 0x25    
   \              0x32 0x78    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x25 0x70          DC8 "%pSTEP_WITH_ON_OFF %x %x %2x"
   \              0x53 0x54    
   \              0x45 0x50    
   \              0x5F 0x57    
   \              0x49 0x54    
   \              0x48 0x5F    
   \              0x4F 0x4E    
   \              0x5F 0x4F    
   \              0x46 0x46    
   \              0x20 0x25    
   \              0x78 0x20    
   \              0x25 0x78    
   \              0x20 0x25    
   \              0x32 0x78    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x25 0x70          DC8 "%pSTOP"
   \              0x53 0x54    
   \              0x4F 0x50    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x25 0x70          DC8 "%pSTOP_WITH_ON_OFF"
   \              0x53 0x54    
   \              0x4F 0x50    
   \              0x5F 0x57    
   \              0x49 0x54    
   \              0x48 0x5F    
   \              0x4F 0x4E    
   \              0x5F 0x4F    
   \              0x46 0x46    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x45 0x52          DC8 "ERR: reading on/off transition time %x"
   \              0x52 0x3A    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x69    
   \              0x6E 0x67    
   \              0x20 0x6F    
   \              0x6E 0x2F    
   \              0x6F 0x66    
   \              0x66 0x20    
   \              0x74 0x72    
   \              0x61 0x6E    
   \              0x73 0x69    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x25 0x78    
   \              0x00         
   \   00000027   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   emAfActivateLevelControl
         8   -> emberAfScheduleServerTickExtended
       8   emAfGetLevelControlState
         8   -> emberAfFindClusterServerEndpointIndex
      40   emAfLevelControlClusterMoveHandler
        40   -> emAfActivateLevelControl
        40   -> emAfGetLevelControlState
        40   -> emberAfPrintln
        40   -> emberAfReadServerAttribute
      40   emAfLevelControlClusterMoveToLevelHandler
        40   -> calculateEventDuration_and_stepSize
        40   -> emAfActivateLevelControl
        40   -> emAfGetLevelControlState
        40   -> emberAfPrintln
        40   -> emberAfReadServerAttribute
      48   emAfLevelControlClusterStepHandler
        48   -> emAfActivateLevelControl
        48   -> emAfGetLevelControlState
        48   -> emberAfPrintln
        48   -> emberAfReadServerAttribute
       8   emAfLevelControlClusterStopHandler
         8   -> emAfGetLevelControlState
      16   emAfPluginLevelControlClusterGetCurrentLevel
        16   -> emberAfPrintln
        16   -> emberAfReadServerAttribute
      40   emAfPluginLevelControlClusterOnOffEffectHandler
        40   -> calculateEventDuration_and_stepSize
        40   -> emAfActivateLevelControl
        40   -> emAfGetLevelControlState
        40   -> emberAfPrintln
        40   -> emberAfReadServerAttribute
      16   emberAfLevelControlClusterMoveCallback
        16   -> emAfLevelControlClusterMoveHandler
        16   -> emberAfPrintln
        16   -> emberAfSendImmediateDefaultResponse
      16   emberAfLevelControlClusterMoveToLevelCallback
        16   -> emAfLevelControlClusterMoveToLevelHandler
        16   -> emberAfPrintln
        16   -> emberAfSendImmediateDefaultResponse
      16   emberAfLevelControlClusterMoveToLevelWithOnOffCallback
        16   -> emAfLevelControlClusterMoveToLevelHandler
        16   -> emberAfPrintln
        16   -> emberAfSendImmediateDefaultResponse
      16   emberAfLevelControlClusterMoveWithOnOffCallback
        16   -> emAfLevelControlClusterMoveHandler
        16   -> emberAfPrintln
        16   -> emberAfSendImmediateDefaultResponse
       8   emberAfLevelControlClusterServerInitCallback
         8   -> emAfGetLevelControlState
      32   emberAfLevelControlClusterServerTickCallback
        32   -> emAfGetLevelControlState
        32   -> emberAfContainsServer
        32   -> emberAfPluginAuroraLevelControlSetNewLevelCallback
        32   -> emberAfPrintln
        32   -> emberAfReadServerAttribute
        32   -> emberAfScenesClusterMakeInvalidCallback
        32   -> emberAfScheduleServerTickExtended
        32   -> emberAfWriteServerAttribute
        32   -> setOnOffValue
      24   emberAfLevelControlClusterStepCallback
        24   -> emAfLevelControlClusterStepHandler
        24   -> emberAfPrintln
        24   -> emberAfSendImmediateDefaultResponse
      24   emberAfLevelControlClusterStepWithOnOffCallback
        24   -> emAfLevelControlClusterStepHandler
        24   -> emberAfPrintln
        24   -> emberAfSendImmediateDefaultResponse
       8   emberAfLevelControlClusterStopCallback
         8   -> emAfLevelControlClusterStopHandler
         8   -> emberAfPrintln
         8   -> emberAfSendImmediateDefaultResponse
       8   emberAfLevelControlClusterStopWithOnOffCallback
         8   -> emAfLevelControlClusterStopHandler
         8   -> emberAfPrintln
         8   -> emberAfSendImmediateDefaultResponse
      16   setOnOffValue
        16   -> emberAfContainsServer
        16   -> emberAfPrintln


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       8  ??Subroutine13_0
      12  ?Subroutine0
      10  ?Subroutine1
       6  ?Subroutine10
      10  ?Subroutine11
       8  ?Subroutine12
      12  ?Subroutine2
      20  ?Subroutine3
      10  ?Subroutine4
      14  ?Subroutine5
      10  ?Subroutine6
      18  ?Subroutine7
       6  ?Subroutine8
       6  ?Subroutine9
      32  ?_0
      32  ?_1
      16  ?_10
      28  ?_11
      20  ?_12
      32  ?_13
       8  ?_14
      20  ?_15
      40  ?_16
      28  ?_2
      32  ?_3
      44  ?_4
       4  ?_5
       4  ?_6
      24  ?_7
      20  ?_8
      36  ?_9
      26  emAfActivateLevelControl
      28  emAfGetLevelControlState
     138  emAfLevelControlClusterMoveHandler
     216  emAfLevelControlClusterMoveToLevelHandler
     250  emAfLevelControlClusterStepHandler
      32  emAfLevelControlClusterStopHandler
      34  emAfPluginLevelControlClusterGetCurrentLevel
     196  emAfPluginLevelControlClusterOnOffEffectHandler
      16  emberAfLevelControlClusterMoveCallback
      26  emberAfLevelControlClusterMoveToLevelCallback
      26  emberAfLevelControlClusterMoveToLevelWithOnOffCallback
      24  emberAfLevelControlClusterMoveWithOnOffCallback
      26  emberAfLevelControlClusterServerInitCallback
     370  emberAfLevelControlClusterServerTickCallback
      24  emberAfLevelControlClusterStepCallback
      22  emberAfLevelControlClusterStepWithOnOffCallback
      18  emberAfLevelControlClusterStopCallback
      16  emberAfLevelControlClusterStopWithOnOffCallback
       2  minLevel
          maxLevel
      50  setOnOffValue
      24  stateTable

 
    26 bytes in section .bss
     8 bytes in section .rodata
 2 120 bytes in section .text
 
 2 120 bytes of CODE  memory
     8 bytes of CONST memory
    26 bytes of DATA  memory

Errors: none
Warnings: 1
